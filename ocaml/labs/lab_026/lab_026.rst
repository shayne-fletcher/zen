
html,
    h1 {
    font-family: Helvetica, Geneva, Arial,  SunSans-Regular, sans-serif 
    }
    body {
    font-family:Verdana, Geneva, sans-serif; 
   }
Weekly Exercises : #26
2016-06-09 by 
Difficulty level :
Medium
Problem :
This is a pencil and paper exercise. The idea is to take on the role of the compiler and perform the value calculations and type derivations by hand. Treat them as mathematical proofs (show your workings!)
Derive the type of each of the following functions:

let z = fun k ¨ k []
let s n k x = n (fun v ¨ k (x :: v))
let p a = a (fun x ¨ x)
 
Derive the type of each of the following function applications:

p z
p (s z)
p (s (s z))

 Reduce each of the expressions given in (2) to beta normal form.
 
 Describe the (pseudo -) expression p (si z) in plain English. What does it represent?
Solutions :

Assume [] to be of type ƒ¿ list. Since k is applied to [] then k must have type ƒ¿ list ¨ ƒÀ for some type ƒÀ. Now z is a function in k returning through invocation of k that is, z is of type (ƒ¿ list ¨ ƒÀ) ¨ ƒÀ.
 
x is "consed" onto v so, v has type ƒ¿ list for some ƒ¿ and x therefore types to ƒ¿. k is then applied to the value of ƒ¿ list yielding a value of type ƒÀ (say) so k is of type ƒ¿ list ¨ ƒÀ. Summarizing we have:
val x : ƒ¿
val v : ƒ¿ list
val k : ƒ¿ list ¨ ƒÀ
n is applied to a function taking an ƒ¿ list ¨ ƒÀ so n has type (ƒ¿ list ¨ ƒÀ) ¨ ƒÁ for some ƒÁ and so finally we may write
val s : ((ƒ¿ list ¨ ƒÀ) ¨ ƒÁ) ¨ (ƒ¿ list ¨ ƒÀ) ¨ ƒ¿ ¨ ƒÁ


Let x have type ƒ¿. Then a must have type (ƒ¿  ¨ ƒ¿) ¨ ƒÀ, so p has type ((ƒ¿  ¨ ƒ¿) ¨ ƒÀ) ¨ ƒÀ.
 

Given,
val z : (ƒ¿ list ¨ ƒÀ) ¨ ƒÀ
val p : ((ƒ¿  ¨ ƒ¿) ¨ ƒÀ) ¨ ƒÀ
by unification, it must be ƒ¿ list.

Given,
val z : (ƒ¿ list ¨ ƒÀ) ¨ ƒÀ
val s : ((ƒ¿ list ¨ ƒÀ) ¨ ƒÁ) ¨ (ƒ¿ list ¨ ƒÀ) ¨ ƒ¿ ¨ ƒÁ
val p : ((ƒ¿  ¨ ƒ¿) ¨ ƒÀ) ¨ ƒÀ
consider the expression s z. By unification we have ƒÀ = ƒÁ and s z = (ƒ¿ list ¨ ƒÀ) ¨ ƒ¿ ¨ ƒÀ.  So now we have the equations
s z : (ƒ¿ list ¨ ƒÀ) ¨ (ƒ¿ ¨ ƒÀ)
p   : ((ƒÁ ¨ ƒÁ) ¨ İ) ¨ İ
(we engaged in an ƒ¿ conversion for p in the above in order to avoid confusion). Now, by unification we see that ƒÁ = ƒÀ = ƒ¿ list, İ = ƒ¿ ¨ ƒ¿ list and therefore p (s z) has type ƒ¿ ¨ ƒ¿ list.

 Given,
s z : (ƒ¿ list ¨ ƒÀ) ¨ (ƒ¿ ¨ ƒÀ)
s   : ((ƒ¿ list ¨ ƒÀ) ¨ ƒÁ) ¨ (ƒ¿ list ¨ ƒÀ) ¨ ƒ¿ ¨ ƒÁ
we have ƒÁ = ƒ¿ ¨ ƒÀ and s (s z) = (ƒ¿ list ¨ ƒÀ) ¨ ƒ¿ ¨ (ƒ¿ ¨ ƒÀ). That is,
s (s z) : (ƒ¿ list ¨ ƒÀ) ¨ ƒ¿ ¨ (ƒ¿ ¨ ƒÀ)
p       : ((ƒÁ ¨ ƒÁ) ¨ İ) ¨ İ
providing, ƒÁ = ƒÀ = ƒ¿ list, İ = (ƒ¿ ¨ (ƒ¿ ¨ ƒ¿ list)) and finally p (s (s z)) is revealed to have type ƒ¿ ¨ ƒ¿ ¨ ƒ¿ list.




p z = z (fun x ¨ x) = (fun k ¨ k []) (fun x ¨ x) = []


p (s z) = (s z) (fun x ¨ x)
        = (fun k x ¨ z (fun v ¨ k (x :: v))) (fun x ¨ x)
        = fun x ¨ z (fun v ¨ x :: v)
        = fun x ¨ (fun k ¨ k []) (fun v ¨ x :: v)
        = fun x ¨ (fun v ¨ x :: v) []
        = fun x ¨ [x]


p (s (s z)) 
        = (fun k' x' ¨ (s z) (fun v' ¨ k' (x' :: v'))) (fun x ¨ x) 
        = fun x' ¨ (s z) (fun v' ¨ x' :: v')
        = fun x' ¨ fun k x ¨ z (fun v ¨ k (x :: v))) (fun v' ¨ x' :: v')
        = fun x' ¨ fun x ¨ z (fun v ¨ (fun v' ¨ x' :: v') (x :: v))
        = fun x' ¨ fun x ¨ (fun k ¨ k []) (fun v ¨ (fun v' ¨ x' :: v') (x :: v))
        = fun x' ¨ fun x ¨ (fun v ¨ (fun v' ¨ x' :: v') (x :: v)) []
        = fun x' ¨ fun x ¨ (fun v' ¨ x' :: v') [x]
        = fun x' ¨ fun x ¨ [x'; x]

p (si z) is a function in i arguments which returns those arguments in a list.
 
For further reading, see this (http://okmij.org/ftp/Computation/extra-polymorphism.html) page.
