<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
          "http://www.w3.org/TR/html4/strict.dtd">
<html>
  <head>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
      extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js"],
      jax: ["input/TeX", "output/HTML-CSS"],
      tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      },
      "HTML-CSS": { availableFonts: ["TeX"] }
      });
    </script> 
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
    <title>Narbel</title>
  </head>
  <body>
    <h2>Generic programming via modules and functors</h2>

    <h3>Modular programming</h3>
    <p>
    The readability, development, finding of errors, testability,
    robustness and adaptability of a program depends mainly on the
    organization into its independent parts and hierarchies. Without
    the adoption of boundaries, the development of a program quickly
    proves difficult to manage and maintenance a burden. Additionally,
    a program often relies on parts that are more general than
    it. Distinuishing these parts permits reutilization of their use
    in other settings and aids in the realization of other
    programs. Structuring, hierarchization and partitioning are the
    essential ingredients of programs ambitious in size and life-time.
    </p>
    <p>
    The possibility of building environments protected from each other
    is already provided for in functional programming through the
    notion of closures. This sub-spacing favors indeed some of the
    properties mentioned above. Nevertheless, the functions are
    limited to values, the protection they impose uniform and not
    lending easily to certain adaptions or extensions. Similarly, type
    structures such as records are likely to generate sub-spaces of
    names used for encapsulation purposes. However, these subspaces
    are equally as limiting as function closures.
    </p>
    <p>
    It is natural therefore to offer a more general means of
    construction for encapsulation. We have already met and used this
    means in fact through OCaml libraries : modules. This new form of
    encapsulation will indeed:
    <ul>
      <li>
      Allow for the construction of sub-spaces of names that do not
      impose restrictions on the elements of the language : modules
      can contain values, the definition of types, exceptions, other
      modules, etc.
      </li>
      <li>
      Allow control of the visibility of each of the elements
      encapsulated.
      </li>
    </ul>
    </p>
    <p>
    Modules are certainly not an original construction of ML
    languages. They exist in most current programming
    languages. However, ML modules possess specifics on which the
    following sections will expand on fully : the type system includes
    them in their own right. Each module posses a unique type : it is
    an instance of this type and recognized as such by the type
    system. From this point of view, a module resembles a typed value
    such as an integer or a character string. The typing system can
    thus extend to the global properties of a program and intervene in
    the elaboration and validation of a software architecture.
    </p>

    <h4>Modules : A general encapsulator</h4>

    <h5>Defining modules</h5>
    <p>
    The syntax of a module in OCaml comes down to framing a series of
    definitions and expressions by the keywords <code>struct</code>
    and <code>end</code>. As earlier announced, there are few
    restrictions as to the nature of the entities that may be placed
    there:
    <pre class="prettyprint ml">
      struct
        type ...          exception ...
        let ...           module ...
        module type ...   open ...
        include ...       &lt;exp&gt;
        ...
      end
    </pre>
    The first three kinds of
    definitions, <code>type</code>, <code>exception</code>
    and <code>let</code> are familiar. The occurence
    of <code>&lt;exp&gt;</code> indicates a module can also contain
    any expression. We introduce the other key-words and extents in
    the following.
    </p>
    <p>
    The encapsulation mechanism above does not alone define a value,
    it is necessary to explicitly associate it with name. To do this
    one uses the <code>module</code> keyword and the chosen names must
    start with a capital letter:
    <pre class="prettyprint ml">
    module &lt;name&gt; = struct
      ...
    end
    </pre>
    </p>
    <p>
    <i>Rules of a module definition : All the elements enclosed by
    a <code>struct</code>-<code>end</code> are compiled and evaluated
    sequentially in the order they appear. Each new element can use
    the previously defined elements and is strictly associated with
    the module. The overall result is bound to the
    identifier <code>&lt;name&gt;</code></i>.
    </p>
    <p>
    For simple bindings, if the overall evaluation is interrupted due
    to the emergence of an exception due to the evaluation of an
    individual element, the module is not built.
    </p>
    <p>
    Here is the first example of a module:
    <pre class="prettyprint ml">
    module Math = struct

      let rec fact n =
        if n &lt;= 1 then 1 else n * fact (n - 1)

      let rec fib n =
        if n &lt;= 0 then 0
        else if n = 1 then 1
        else fib (n - 1) + fib (n - 2)

      let rec sum f n0 n =
        if n < n0 then 0
        else (f n) + (sum f n0 (n - 1))

    end
    </pre>
    So here we have assembled a collection of arithmetic functions
    into a module of name <code>Math</code>.
    </p>

    <h5>Accessing module elements</h5>
    <p>
    By default, the elements of a module are accessible from its
    exterior. As observed in using the standard libraries, the access
    to these items is through indirection using a "member selection
    notation": <i>&lt;Module&gt.&lt;element&gt</i>. So, with the
    module <code>Math</code> of the preceding section:
    <pre>
    # Math.fact 5;;
    - : int = 120

    # Math.fib 6;;
    - : int  = 8 

    # Math.sum (fun n &rarr; n) 0 4;;
    - : int = 10

    # Math.sum (fun n &rarr; Math.fact n) 1 4;;
    - : int = 33
    </pre>
    </p>

    <h5>The modular form of data-types</h5>
    <p>
    Modules used to organize sets of definitions of functions can also
    include definitions of types and thus can serve as a means of
    encapsulation of data-types. That is to say, it is possible then
    to collect in a module the definition of a type and the functions
    that are associated with that type.
    </p>
    <p>
    Here is an example based on complex numbers:
    <pre class="prettyprint ml">
    module Complex = struct

      type complex = {re : float; im : float}

      let make (r, i) = {re = r; im = i}
      let add z w = {re = z.re +. w.re; im = z.im +. w.im}
      let norm z = sqrt (z.re ** 2. +. z.im ** 2.)

    end
    </pre>
    The representation of values is achieved by the use of a record
    type <code>{re : float; im : float}</code>. All the elements of
    this module are public and can be used directly:
    <pre class="prettyprint ml">
    # let z1 = Complex.make (4., 3.);;
    val z1 : Complex.complex = {Complex.re = 4.; Complex.im = 3.}

    # Complex.add z1 z1;;
    - : Complex.complex = {Complex.re = 8.; Complex.im = 6.}

    # Complex.norm z1;;
    - : float = 5.

    # z1.Complex.re;;
    - : float = 4.
    </pre>
    Note that these complex numbers are instances of the
    data-type <code>complex</code>. These instances are dependent on
    the the functions contained in the module, that is to
    say, <code>add</code> and <code>norm</code>. The encapsulation of
    a data-type in a module is indeed often characterized by such a
    centralized organisation. By contrast, we can compare this case
    with that record types, that is here, each instance contains both
    values and functions. We will discuss this important point of
    comparison later.
    </p>
    <p>
    Here are some more examples of data-types in modular form. First,
    let us consider a type that represents points in a plane
    associated with the usual Euclidean distance.
    <pre class="prettyprint ml">
    module Plane = struct
      type point = P of float * float

      let make_point (x, y) = P (x, y)

      let dist (P (x1, y1), P (x2, y2)) =
        sqrt ((x1 -. x2) ** 2. +. (y1 -. y2.) ** 2.)
    end
    </pre>
    A difference of this example from the preceding is that here, the
    representation of values of <code>point</code> are as instances of
    a singlar sum type. The techniques of expressing types we already
    know apply equally well in the context of modules.
    </p>
    <p>
    Data structures (or containers) can also take a coherent form by
    means of modules. For example, here's how to gather the
    definitions associated with lists:
    <pre class="prettyprint ml">
    module L = struct
      type &alpha; lin = Empty | Cons of &alpha; * &alpha; lin

      let empty () = Empty

      let add x l = Cons (x, l)

      let rec mem x l = match l with
        | Empty &rarr; false
        | Cons (x, xs) &rarr; x = y || mem x xs

      let rec apend l1 l2 = match l1 with
        | Empty &rarr; l2
        | Cons (x, xs) &rarr; Cons (x, append xs l2)
    end;;

    # let l1 = L.add 3 (L.empty ())
    val l1 : int L.lin = L.Cons (3, L.Empty)

    # let l1 = L.add 4 l1;;
    val l1 : int L.lin= L.Cons (4, L.cons (3, L.Empty))

    # L.mem 42 l1;
    - : bool = false
    </pre>
    The type of the containers is naturally generic as the the
    representation of values of <code>&alpha; lin</code> is:
    <pre>
    # L.add 3.1415926 (L.Empty);;
    - : float L.lin = L.Cons (3.1415926, L.Empty)

    # L.add "colorisation des esprits" (L.empty ());;
    - : string L.lin = L.cons ("colorisation des esprits", L.Empty)
    </pre>
    In fact, most data types defined in the standard OCaml library are
    implemented using this technique.
    </p>

    <h5>Remarks on the rules of module definitions</h5>
    <p>
    It is useful to have a precise idea about the consequences of the
    rules of definitions associated with the construction of a
    module. These are some of the important points:
    <ul>
      <li>
      <i>The evaluation of elements in a module follow their
      individual evaluation rules</i>.
      <br/>
      <br/>
      Here is an example illustrating the case of functions:
      <pre class="prettyprint ml">
      # module M = struct
          let f () = 1 / 0
        end;;
      # M.f ();;
      Exception : Division_by_zero.
      </pre>
      It is only when <code>f</code> is applied that an exception is
      thrown. Constrast this with the case of the construction of a value:
      <pre class="prettyprint ml">
      # module M = struct
          let x = 1 / 0
        end;;
      Exception : Division_by_zero.
      # M.x ;;
      Unbound value M.x
      </pre>
      The evaluation of the body of a <code>let</code> occurs during
      the construction of the module. Similarly, simple expressions:
      <pre class="prettyprint ml">
      # module M = struct
          print_endline "Inside M"
          let f x = x + 1
        end;;
      Inside M
 
      #M.f;;
      - : int &rarr; int
      </pre>
      The printing of the character string is effected during the
      construction of <code>M</code>. In the case where such
      expressions are followed, it is neccessary to use
      seperators. One can make use of double semi-colons:
      <pre class="prettyprint ml">
      # module M = struct
          print_endline "in M" ;;
          print_endline "yes, in M";;
          let f x = x + 1
        end;;
      </pre>
      However, the tradition in OCaml requires rather that we stick.
      with <code>let</code> bindings. Evaluations that only occur
      during the construction of a module are really only useful in
      edge cases (the construction of a module generates a
      module). Therefore, the type of these expressions is
      necessarily <code>unit</code> and the following form is also
      possible:
      <pre class="prettyprint ml">
      # module M = struct
          let () = print_endline "in M"
          let () = print_endline "yes, M"
          let f x = x + 1
      </pre>
      What we've written here are artifical <code>let</code>
      constructions by way of pattern matching on a unique instances
      of type <code>unit</code>. Thus the form <code>let () =
      ...</code> in a module invariably indicates an expression that
      will be evaluated during the construction of the module.
      <br/>
      <br/>
      </li>
      <li>
      <i>Dependence on the placement of elements in a module</i>
      <br/>
      <br/> The evaluation of a module is sequential. A definition in
      a module may not utilize a definition that follows it:
      <pre class="prettyprint ml">
      # module M = struct
          let f x = (g x) + 1
          let g x = x + 2
        end;;
      Unbound value g
      </pre>
      In the case you wanted to override this rule, it is necessary to
      make use of a <code>let rec</code> construction and define
      mutally recursive functions:
      <pre class="prettyprint ml">
      # module M = struct
          let rec f x = (g x) + 1
          and g x = x + 2
        end;;
      </pre>
      <br/>
      <br/>
     </li>
     <li>
       <i>Internal module state</i>
       <br/>
       <br/>
       It is possible to define modifiable variables in a module. Such
       variables constitute internal state. Reconsider the earlier
       example of points in the plane. We can provide a way to measure
       the extent of their establishment through such internal state
       wich will be denoted here as <code>count</code>:
       <pre class="prettyprint ml">
         module Plane_count = struct
           type point = {number : int; coord : float * float}

           let count = ref 0 (*Initialization*)

           let make_point (x, y) =
             incr count; {number = !count; coord = (x, y)}

           let dist p1 p2 =
             let (x1, y1) = p1.coord and (x2, y2) = p2.coord in 
               sqrt ((x1 -. x2) ** 2. +. (y1 -. y2.) ** 2.)
         end;;
       </pre>
       For example:
       <pre class="prettyprint ml">
       # Plane_count.make (0., 0.);;
       - : Plane_count.point = {Plane_count.number = 1;
                                Plane_count.coord = (0., 0.)}
       # Plane_count.make (1., 1.);;
       - : Plane_count.point = {Plane_count.number = 2;
                                Plane_count.coord = (1., 1.)}
       </pre>
       <br/>
       <br/>
     </li>
     <li>
       <i>Multiple definitions and redefinitions of elements in a
       module</i> <br/> <br/> If an association is defined multiple
       times in a module, it is only the last definition that will be
       taken into account. The sequential evaluation of elements in a
       module imply behaviors consistent with similar evaluations in
       the global environment. For example:
       <pre class="prettyprint ml">
       module M = struct
         let number = 1
         let number = 2.1
         let number = "three"
       end;;

       # M.number;;
       - : string = "three"
       </pre>
     </li>
    </ul>
    </p>

    <h5>Local modules</h5>
    <p>
    In OCaml, modules can emerge in local environments defined by way
    of a new <code>let</code> construction:
    <pre class="prettyprint ml">
    let module &lt;name&gt; = struct ... end in &lt;exp&gt;
    </pre>
    where the name of the module is usable in the
    expression <code>&lt;exp&gt;</code>. One of the main interest of
    local modules is to remedy the limitations of environments defined
    by <code>let</code>-<code>in</code> that can not in fact, include
    certain entities. On the contrary, local modules are not subjected
    to these restrictions. They allow, among other things, to
    associate types or exceptions to an expression. For example, we
    observe that sum types can clarify code. As such, they can
    sometimes be considered as a localized and specific aid. Consider
    this example in polynomials of degree 2:
    <pre class="prettyprint ml">
    # let poly2 a b c =
        let module O = struct
          type order = Less | Equal | Greater
          let less_or_equal x y =
            if x < y then Less else
            if x = y then Equal 
            else Greater
           end in
           match (O.less_or_equal ...) with
             | O.Equal &rarr; ...
             | O.Greater &rarr; ...
             | O.Less &rarr; ...;;
     val poly2 : float &rarr; float &rarr; float &rarr; solution
    </pre>
    The type <code>order</code> resides privately and solely in the
    function <code>poly2</code>. We will see other uses of local
    modules.
    </p>

   <h4>Signatures : the type of modules</h4>

   <h5>Inferred signatures</h5>
   <p>
   The behavior of modules in OCaml is similar to that of values in
   many ways. In paricular, each module possesses a type that is
   integrated with and used by the type-system. The type of a module
   can be computed by inference from the module's definition. As
   stressed in the introduction, this is one of the specifics of ML
   languages. However, the somewhat different nature of these types
   justifies distinguishing them from others. The types of modules are
   called <i>signatures</i>.  <br/> <br/> <b>Property (1) of signatures</b> :
   A signature can be inferred from the definition of a module.  <br/>
   <br/> For example, recall the module corresponding to the
   implementation of a type for complex numbers. The resulting
   signature obtained by type inference follows:
   <pre class="prettyprint">
   module Complex :
     sig
       type complex = {re : float; im : float}
       val make : float * float &rarr; complex
       val add : complex &rarr; complex &rarr; complex
       val norm : complex &rarr; float
     end
   </pre>
   A signature is essentially a summary of all the elements of the
   module to which it corresponds.
   </p>

   <h5>Defining signatures</h5>
   <p>
   As is the case for types of values, it is possible to define
   signatures independently of modules. A signature then consists of a
   simple suite of definitions and declarations enclosed in the
   keywords <code>sig</code> and <code>end</code>:
   <pre class="prettyprint ml">
   sig
     val ...             type ...
     exception ...       module ...
     module type ...     open ...
     include ...         ...
   end
   </pre>
   Note that the identifiers must be delcared with the
   keyword <code>val</code> (rather than <code>let</code>). For
   example:
   <pre class="prettyprint ml">
   val x : char
   val f : int &rarr; float
   val g : &alpha; &rarr; int
   </pre>
   As for modules, it is neccessary to link a signature to a name
   using the keywords <code>module type</code>:
   <pre class="prettyprint ml">
   module type &lt;NAME&gt; = sig
       ...
   end
   </pre>
   There are no syntactic constraints regarding the names of of module
   types with respect to enforcing uppercase or lowercase
   characters. However, to distinguish the names of signatures from
   other identifiers, a convention adopted in the ML literature is to
   spell them entirely in capital letters. Here are some definitions
   of signatures corresponding to the modules presented in early
   sections. For example, here is the signature for <code>Math</code>:
   <pre class="prettyprint ml">
   module type MATH = sig
    val fact : int &rarr; int
    val fib : int &rarr; int
    val sum : (int &rarr; int) &rarr; int &rarr; int &rarr; int
   end
   </pre>
   And here are the signatures of the modules <code>Complex</code>
   and <code>Plane</code> respectively and, the module <code>L</code>
   associated with lists.
   <pre class="prettyprint ml">
   module type COMPLEX = sig
     type complex
     val make : float * float &rarr; complex
     val add : complex &rarr; complex &rarr; complex
     val norm : complex &rarr; float
   end;;

   module type METRIC_SPACE_2D = sig
     type point
     val make_point : float * float &rarr; point
     val dist : point &rarr; point &rarr; float
   end;;

   module type LINEAR_CONTAINER = sig
     type &alpha; lin
     val empty : unit &rarr; &alpha; lin
     val add : &alpha; &rarr; &alpha; lin &rarr; &alpha; lin
     val mem : &alpha; &rarr; &alpha; lin &rarr; bool
     val append : &alpha; lin &rarr; &alpha; lin &rarr; &alpha; lin
   end;;
   </pre>
   The examples illustrate the following important point:
   <br/>
   <br/>
   <b>The fundamental interest of signatures :</b> They express certain
   characteristics of modules without including any implmentation.
   <br/>
   <br/>
   </p>

   <h5>Abstract types</h5>
   <p>
   The signatures of the last section have show that it is possible to
   use the keyword <code>type</code> without necessarily associating
   it with an explicit definition. We saw there for example:
   <pre class="prettyprint ml">
     type complex
     type point
     type &alpha; lin
   </pre>
    That is, it can be limited to the names of types declared in
    signatures:
    <br/>
    <br/>
    <b>Definition:</b> In a signature, a simple declaration of a name
    of a type is called an abstract type.  <br/> <br/> This name is
    justified because these types allow for an abstraction of the
    existence of particular types. To be precise:
    <br/>
    <br/>
    <b>The interest of abstract types and the coherence of a
    signature:</b> The abstract types of a signature <code>S</code>
    declare the names of types which are usable for the types of other
    elements in <code>S</code>. They thus impose a global coherence to
    typing other elements of the signature <code>S</code>, and this
    without being dependent on the definitions of these types.<br/>
    <br/> <br/> Moreover, when the parameters are abstract types, this
    makes possible expressions of typing patterns. For example, in the
    signature <code>LINEAR_CONTAINER</code>, there were the following
    generic declarations:
    <pre class="prettyprint ml">
    type &alpha; lin
    val add : &alpha; &rarr; &alpha; lin &rarr; &alpha; lin
    val mem : &alpha; &rarr; &alpha; lin &rarr; bool
    </pre>
    So, for example, the type <code>&alpha; &rarr; &alpha; lin &rarr;
    &alpha; lin</code> describes a generic operation of adding an
    element of type <code>&alpha;</code> to an <code>&alpha;
    lin</code> containing other items of the same type. In the
    implementation, the typing consistency will be ensured.
   </p>

   <h5>Elements implemented in signatures</h5>
   <p>
   Even if the main part of a signature is constituted merely of
   simple declarations, some of the elements can be implemented. It is
   possible to define exceptions:
   <pre>
   module type S = sig
     exception No
     exception Out_of_bounds of float
     ...
   end
   </pre>
   On the other hand, types can also be defined in a signature. For
   example, the signature <code>COMPLEX</code> includes the definition
   of a record type:
   <pre class="prettyprint ml">
   module COMPLEX = sig
     type complex = {re : float; im : float}
     ...
   end
   </pre>
   Such types are called "concrete types" (or "manifest types")
   distinguishing them from abstract types.
   </p>

   <h5>Signatures for explicitly typing modules</h5>
   <p>
   Signature definitions only make sense if they can be linked to
   modules. As for simple values, it is possible to explicitly ascribe
   a signature to a module. The syntax is similar:
   <pre class="prettyprint">
     module &lt;NAME&gt; : &lt;SIGNATURE&gt; = struct
       ...
     end
   </pre>
   The first application of this is to add explicit typing information
   to the definition of a module. Type inference can put this into
   correspondence with its own calculation. We can therefore check by
   inference that a module corresponds to its signing. For example, if
   we use the module <code>L</code> associated with lists we can
   explicitly type it to the signature <code>LINEAR_CONTAINER</code>.
   <pre class="prettyprint ml">
   # module L : LINEAR_CONTAINER = struct
       type &alpha; lin = Empty | Cons of &alpha; * &alpha; lin
       let empty () = Empty
       let add x l = ...
       let rec mem x l = ...
       let rec append l1 l2 = ...
     end;;
   module L : LINEAR_CONTAINER
   </pre>
   Here we get a terse response from the type system indicating
   acceptance that <code>L</code> can be typed as
   a <code>LINEAR_CONTAINER</code>. In contrast, an invalid explicit
   typing not sanctioned by inference will be documented as a type
   error. For example, consider a situation where a module does not
   implement all the elements of the
   signature <code>LINEAR_CONTAINER</code>:
   <pre class="prettyprint ml">
   # module L : LINEAR_CONTAINER = struct
       type &alpha; lin = Empty | Cons of &alpha; * &alpha; lin
       let add x l = Cons (x, l)
     end;;
   The field &alpha;ppend' is required but not provided
   The field 'mem' is required but not provided
   The field 'empty' is required but not provided
   </pre>
   The main rule of explicit typing with signatures follows:
   <br/>
   <br/>
   <b>Rule of explicit typing by signature:</b> The explicit typing of
   a module <code>M</code> to a signature <code>S</code> is valid only
   if the elements defined and declared in <code>S</code> are
   implemented in <code>M</code> (with exactly the same names). The
   elements of <code>M</code> must be equal, consistent with or more
   general than those indicated in <code>S</code>.
   <br/>
   <br/>
   Here are some examples to help explain the rules:
   <ul>
   <li><i>Independence from the order of definitions.</i>
   <br/>
   <br/>
   The order of appearance of the elements of the module is not
   important as long as its type corresponds with the signature.
   <br/>
   <br/>
   </li>
   <li>
   <i>The effect of explicitly typing on individual elements.</i>
   <br/>
   <br/>
   Signing by explicit typing acts to explicitly type each individual
   element of the module. For example:
   <pre class="prettyprint ml">
   module type S = sig
     val fst : int * float &rarr; int
   end;;

   module M : S = struct
     let fst (x, y) = x
   end;;

   #M.fst ;;
   - : int * float &rarr; int
   </pre>
   Here the function <code>fst</code> given by the explicit typing to
   the signature <code>S</code> is equivalent to:
   <pre class="prettyprint ml">
     let fst ((x, y) : int * float) : int = x;;
   </pre>
   An occassional error is to implement an element of a module that is
   less general than its declaration. For example:
   <pre class="prettyprint ml">
   module type S = sig
     val f : &alpha; &rarr; &alpha;
   end;;

   module M : S = struct
     let f x = x + 1
   end;;
   </pre>
   The above is an error. This point will later be discussed in more
   detail.  
   <br/>
   <br/>
   </li>
   <li>
   <i>Parameteric abstract types</i>
   <br/>
   <br/>
   An implementation of an abstract type can make use of
   type variable parameters. For example:
   <pre class="prettyprint ml">
   module type S = sig
     type (&alpha;, &beta; &gamma;) t
   end;;

   module M : S = struct
     type (&alpha;, &beta; &gamma;) t = int
   end;;
   </pre>
   One can restrict the generiticity of a type paramter of an abstract
   type. The inverse is not possible:
   <pre class="prettyprint ml">
   # type t = &alpha; list;;
   Unbound type parameter &alpha;
   </pre>
   <br/>
   </li>
   <li>
   <i>Globale coherence of the type of a module</i>
   <br/>
   <br/>
   Using abstract types in a signature permits expressing the overall
   typing coherence between the elements of a signature. For example,
   reconsider the module <code>Plane</code>:
   <pre class="prettyprint ml">
   module Plane = struct
     type point = P of float * float

     let make_point (x, y) = P (x, y)

     let dist (P (x1, y1)) (P (x2, y2)) =
       sqrt ((x1 -. x2) ** 2. +. (y1 -. y2) ** 2.)
   end;;
   </pre>
   The inferred signature is:
   <pre class="prettyprint ml">
   module Plane : sig
     type point = P of float * float
     val make_point : float * float &rarr; point
     val dist : point &rarr; point &rarr; float
   end
   </pre>
   The use of the simple inductive type permits the use of the
   type <class>point</class> in the type of the
   functions <code>make</code> and <code>dist</code>. But here,
   another version of the module uses a type abbreviation:
   <pre class="prettyprint ml">
   module Plane = struct
     type point = float * float

     let make_point (x, y) = (x, y)

     let dist (x1, y1) (x2, y2) = 
       sqrt ((x1 -. x2) ** 2. +. (y1 -. y2) ** 2.)
   end;;
   </pre>
   The inferred signature follows:
   <pre class="prettyprint ml">
   module Plane : sig
     type point = float * float
     val make_point : &alpha; * &beta; &rarr; &alpha; * &beta;
     val dist : float * float &rarr; float * float &rarr; float
   end
   </pre>
   The type <code>point</code> here is a priori without manifest
   utility and the associated functions don't use it (the type
   inference possesses no evidence to connect them with the
   type <code>point</code>). Explicit typing with a signature remedies
   the situation. Indeed, reconsider signing with:
   <pre class="prettyprint ml">
   module type METRIC_SPACE_2D = sig
     type point
     val make_point : float * float &rarr; point
     val dist : point &rarr; point &rarr; float
   end;;
   </pre>
   Then,
   <pre class="prettyprint ml">
   # module Plane : METRIC_SPACE_2D = struct

       type point = float * float

       let make_point (x, y) = (x, y)

       let dist (x1, y1) (x2, y2) = 
         sqrt ((x1 -. x2) ** 2. +. (y1 -. y2) ** 2.)
     end;;
   module Plane : METRIC_SPACE_2D

   # Plane.make_point;;
   - : float * float &rarr; Plane.point

   # Plane.dist;;
   - : Plane.point * Plane.point &rarr; float
   </pre>
   The types of the functions here became specific. The explicit
   typing by signature has had a structuring effect on the collection
   of the types of the elements of the module.
   <br/>
   <br/>
   </li>
   <li>
   <i>Concrete types and exceptions</i> 
   <br/>
   <br/>
   If a signature <code>S</code> contains concrete types of
   exceptions, the modules that implment it must necessarily contain
   the same definitions. For example:
   <pre class="prettyprint ml">
   module type S = sig
     exception Bad of int
     type &alpha; inverse = Full | Empty of &alpha;
   end;;

   module M : S = struct
     exception Bad of int
     type &alpha; inverse = Full | Empty of &alpha;
   end;;
   </pre>
   </li>
   </ul>
   </p>

   <h5>The instantiation relationship between modules and signatures</h5>
   <p>
   A signature may be inferred by the type system for a particular
   module. On the other hand, a module may correspond with a signature
   by explicit typing. It is then said that the module
   implementation <i>satisfies</i> that signature. To stick to that
   though would be to forget an important and original characteristic
   of the module system:
   <br/>
   <br/>
   <b>Property (2) of signatures:</b> The same signature may be
   implemented by multiple distinct modules.
   <br/>
   <br/>
   To highlight the similarity of modules with simply typed values, we
   can extend the meaning of the word "instance".
   <br/>
   <br/>
   <b>Definition:</b> A module that implements (or satisfies) a
   signature, we say is an <i>instance</i>.  <br/> <br/> For example,
   consider a new signature that describes a two-dimensional space
   equipped with a distance metric:
   <pre class="prettyprint ml">
   module type METRIC_SPACE_2D = sig
     type point
     val make_point : float * float &rarr; point
     val dist : point &rarr; point &rarr; float
   end;;
   </pre>
   It is possible to instantiate it in many different ways:
   <pre class="prettyprint">
   module Plane : METRIC_SPACE_2D = struct
    type point = float * float
    let make_point (x, y) = ...
    let dist (x1, y1) (x2, y2) = ...
   end;;

   module Plane_count : METRIC_SPACE_2D = struct
     type point = {number : int; coord : float * float }
     let make_point (x, y) = ...
     let dist p1 p2 = ...
   end;;

   module Manhattan_plane : METRIC_SPACE_2D = struct
    type point = float * float
    let make_point (x, y) = (x, y)
    let dist (x1, y1) (x2, y2) = 
      abs_float (x1 -. x2) +. abs_float (y1 -. y2)
   end;;
   </pre>
   With this, these three spaces can coexist in the same progam:
   <pre class="prettyprint ml">
   # Plane.dist;;
   - : Plane.point &rarr; Plane.point &rarr; float

   # Plane_count.dist;;
   - : Plane_count.point &rarr; Plane_count.point &rarr; float

   # Manhattan_plane.dist;;
   - : Manhattan_plane.point &rarr; Manhattan_plane.point &rarr; float
   </pre>
   </p>
   <p>
   Note that the two properties highlighted above - inference and
   multiple instantiation - are absent from most other
   languages. Multiple instantiation not only increases the reuse of
   signatures, but we will also see that it turns out to be natural in
   defining "functions of mouldes" whose parameters are the types of
   signatures.
   </p>

   <h4>Techniques for writing signatures</h4>

   <h5>Signatures as a means of specification and interface</h5>

   <p>If there is a singularity of ML relative to other languages
   (modules are instances of signatures), their basic use is very
   usual. Indeed, explicit typing of modules showcases signatures as a
   means of interface specification:
   <ul>
   <li><i>Formal description.</i> The prior elaboration of signatures
    admits the design of programs without having to face the practical
    problems of implementation: we focus on the organization of
    sub-spaces of names, on the relations, the constraints to be
    specified there. It is only in the second phase that we undertake
    implementation. The implmementation of a program is then based on
    the collection of pre-existing signatures.
    <br/>
    <br/>
   </li>
   <li><i>Transmission of documentation.</i> Signatures also lend
    themselves as a means of transmission of an abridged form of the
    possibilities their bodies offer the potential user.
   </li>
   These links between signatures and modules thus induce a method of
   production of programs that is measured and thoughtful. This method
   applied during program development takes a certain thoroughness.
   </ul>
   </p>

   <h5>The limitations of signatures as specifications</h5>

   <p>The signatures of ML provide a limited means of
   specification. Signatures can only include properties whose
   verification can be realized within the reach of the type
   system. For example, reconsider the
   signature <code>METRIC_SPACE_2D</code>. The
   declaration <code>dist</code> there is deemed to specify a function
   of distance. The declaration describes binary function acting on
   the <code>point</code> type and computing a number of
   type <code>float</code>:
   <ul>
     <li><i>Weakness in the implementation.</i> A programmer can not
     rely on the system to check the character of the distance
     function an implementation of <code>dist</code> will have
     produced.  <br/> <br/>
     </li>
     <li><i>Weakness of use.</i> A user of an instance of the
     signature <code>METRIC_SPACE_2D</code> can not be sure of the
     character of the distance function provided by <code>dist</code>.
     </li>
   </ul>
   For example, the module following satisfies the signature
   of <code>METRIC_SPACE_2D</code> but it's function <code>dist</code>
   is not a distance:
   <pre class="prettyprint ml">
   module Buggy_plane : METRIC_SPACE_2D = struct
     type point = float * float
     let make_point (x, y) = (x, y)
     let dist (x1, y1) (x2, y2) = x1 +. y1 +. x2 +. y2
   end
   </pre>
   As part of a complete description of a metric space , the axioms of
   the definition of a distance would be included:
   \[
   \begin{eqnarray}
   \forall x,y \in point,&\;\;&0 \le dist (x, y) \le \infty \nonumber \\
   \forall x,y \in point,&\;\;& dist(x, y) = 0 \iff x = y \nonumber \\
   \forall x,y \in point,&\;\;& dist(x, y) = dist(y, x) \nonumber \\
   \forall x,y \in point,&\;\;& dist(x, z) \le  dist(x, y) + dist (y, z)
   \end{eqnarray}
   \]
   Only their verification on <code>dist</code> would ensure the
   character of the distance function. That verification is quite out
   of reach of the type system. Languages that include such
   possibilities of specification require production of mathematical
   evidence adapted case by case. In the language of OCaml, we resort
   to verification of specific implementations via assertions and
   tests.
   </p>

   <h5>Mitigation of the limitations of specification via signatures</h5>

   <p>
   The simpliest and most traditional method of mitigating the
   limitations consists of associating signatures with documentation
   in the form of comments. The constraints, the properties, the
   behaviors of elements may be made more or less formal and
   precise. For example:
   <pre class="prettyprint ml">
   module type METRIC_SPACE_2D = sig
     type point
     val make_point : float * float &rarr; point
     val dist : point &rarr; point &rarr; float
     (*Satisifies the axioms of a distance function, can raise
      [Invalid_argument] *) 
   end
   </pre>
   This tactic can be applied generally and systematically during the
   elaboration of signatures. It is obviously understood to be a
   compromise since the type system can exert no control over them.
   </p>
   <p>
   We wil later see however that sometimes OCaml offers more effective
   means by nesting signatures in other modules or the use of
   functions of modules. Also, technically, a specification can
   combine the type system. For example, in the
   signature <code>MATH</code> we have:
   <pre class="prettyprint ml">
   val sum : (int &rarr; int) &rarr; int &rarr; int
   </pre>
   In this declaration, while it defines the form of the function, we
   are guessing the first parameter represents the operation that
   defines the sum. On the other hand, the declaration fails to
   describe the remaining two parameters. The use of comments would
   remedy this lack of precision but OCaml provides an extension which
   offers a solution which integrates better with this kind of problem
   : labeled parameters. We can use this feature in the signature to
   clarify the role of these parameters. For example:
   <pre class="prettyprint ml">
   val sum : f : (int &rarr; int) &rarr; start : int &rarr; goal : int &rarr; int
   </pre>
   Then, modules that satisfy the signature will have these types
   labeled providing coherence. For example:
   <pre class="prettyprint ml">
   let rec sum ~f ~start ~goal =
     if goal < start then 0
     else (f goal) + sum ~f:f ~start:start ~goal:(goal - 1)
   </pre>
   Any gaps in the naming of the parameters will be sanctioned by a
   type error. The labeling of parameters then permits an enriched
   signature in terms of documentation and is verifiable by the type
   system during instantiation.
   </p>

   <h5>The generalization of signatures</h5>

   <p>
   The existence of abstract types in signatures permits a new
   technique of generalistation. For example, consider once again the
   signature <code>MATH</code>:
   <pre class="prettyprint ml">
   module type MATH = sig
    val fact : int &rarr; int
    val fib : int &rarr; int
    val sum : (int &rarr; int) &rarr; int &rarr; int &rarr; int
   end
   </pre>
   This signature restricts the declarations to numbers of the
   type <code>int</code>. The specification sets here a representation
   that leads to a particular precision in implementations. We can
   replace the occurences of <code>int</code> with an abstract type:
   <pre class="prettyprint ml">
   module type MATH_GEN = sig
    type t
    val fact : t &rarr; t
    val fib : t &rarr; t
    val sum : (t &rarr; t) &rarr; t &rarr; t &rarr; t
   end
   </pre>
   We have obtained a generalization of the
   signature <code>MATH</code> over the the type <code>int</code>.
   <br/>
   <br/>
   <b>Principle of generalization of a signature :</b> Replace the
   specific type in the signature with an abstract type.
   <br/>
   <br/>
   </p>

   <h5>Signatures and the functional or imperative style</h5>

   <p>
   A signature can induce a programming style. In particular, those
   operations with the result type <code>unit</code> indicate an
   imperative program. For example, here is a variation on the
   specification of the type of linear containers:
   <pre class="prettyprint ml">
   module type LINEAR_CONTAINER_IMP = sig
     type &alpha; lin
     val empty : unit &rarr; &alpha; lin
     val mem : &alpha; &rarr; &alpha; lin &rarr; bool
     val add : &alpha; &rarr; &alpha; lin &rarr; unit (*procedure*)
     val append : &alpha; lin &rarr; &alpha; lin &rarr; unit (*procedure*)
     val length : &alpha; lin; &rarr; int
     val nth : &alpha; lin &rarr; int &rarr; &alpha;
   end
   </pre>
   The functions <code>add</code> and <code>append</code> here have
   return type <code>unit</code> which imposes the requirement of an
   implmentation necessarily of imperative character.
   </p>
   <p>
   On the other hand, the items specified by a signature may overall
   lead one to adopt an imperative rather than a functional style. For
   example, conser a new version of the preceding signature:
   <pre class="prettyprint ml">
   module type LINEAR_CONTAINER = sig
     type &alpha; lin
     val empty : unit &rarr; &alpha; lin
     val mem : &alpha; &rarr; &alpha; lin &rarr; bool
     val add : &alpha; &rarr; &alpha; lin &rarr; &alpha; lin (*function*)
     val append : &alpha; lin &rarr; &alpha; lin &rarr; &alpha; lin (*function*)
     val length : &alpha; lin; &rarr; int
     val nth : &alpha; lin &rarr; int &rarr; &alpha;
   end
   </pre>
   Apriori this signatures specifies an implementation of functional
   character because the functions <code>add</code>
   and <code>append</code> compute containers rather than a unit
   value. Suppose that we have at our disposal such a representation,
   and suppose we wished to obtain a function that runs through the
   elements of <code>&alpha; lin</code> instances. Here as the only
   access function is <code>nth</code>, which accesses the $n$-th
   element of an instance, it might be tempting to go the way of
   imperative loops adapted to the management of indices. Thus, a
   signature that specifies a data structure have functional character
   that lends itself to recursive decomposition, should also specify
   directly generalized processing functions like iterators or folds.
   </p>

   <h4>Public and private modules</h4>

   <p>
   The mechanisms of encapsulation induce rules about the visibility
   of elements in a structure. An element that is <i>public</i> (or
   'exported') is usable from outside of the encapsulation. An element
   that is <i>private</i> (or 'hidden') is not. So for example, the
   local bindings of a function are private while the fields of a
   record are public. Modules offer a mechanism more nuanced where it
   is possible to explicitly render individual elements public or
   private. This control of visibility allows us to apply techniques
   of information hiding and precise control of the links between
   modules.
   </p>

   <h4>Public and private modules</h4>

   <h5>Public</h5>

   <p>
   First of all, we have already exercised the following rule of visibility:
   <br/>
   <br/>
   <b>Rule (1) of the visibility of modules: </b> The contents of a
   module without an explicit signature are public.  <br/> <br/> For
   example, recall the implementation of a datatype for lists:
  <pre class="prettyprint ml">
   module L = struct 
     type &alpha;lpha lin = Empty | Cons of &alpha; * &alpha; lin
     let empty () = Empty
     let add x l = Cons (x, l)
   end 
  </pre>
   Without explicit signing,
   the module exposes all its contents. The representation of such
   values, <code>&alpha; lin</code> is therefore usable for direct use:
   <pre class="prettyprint ml">
   # L.empty ();;
   - : &alpha; L.lin - L.Emtpy

   # let l1 = L.add 3 (L.empty ());;
   val l1 : int L.lin = L.Cons (3, L.Empty)
   </pre>
   </p>

   <h5>Private</h5>

   <p>
   During the presentation of the rules of explicit typing via
   signatures we did not highlight an important point : the explicit
   typing of a module <code>M</code> by a signature <code>S</code>
   remains valid if at least all of the elements of <code>S</code> are
   defined in <code>M</code>. The rule that follows is the natural
   complement of the behavior of explicit typing since the signature
   acts as interfaces between modules:
   <br/>
   <br/>
   <b>Rule (2) of the visibility of modules: </b> The elements of a
   module <code>M</code> typed explicitly with a
   signature <code>S</code> are public only if they appear
   in <code>S</code> (except for abstract types). All other elements
   in <code>M</code> are private.
   <br/>
   <br/>
   For example, reconsider the
   module <code>Plane_count</code>. This one possesses the following
   signature:
   <pre class="prettyprint ml">
   module type METRIC_SPACE_2D_COUNT = sig
     type point
     val count : int ref
     val make_point : float * float &rarr; point
     val dist : point &rarr; point &rarr; float
   end
   </pre>
   The internal state <code>count</code> appears in the signature. In
   the original rendering of <code>METRIC_SPACE_2D</code> this
   variable was absent:
   <pre class="prettyprint ml">
   module Plane_count : METRIC_SPACE_2D = struct
     type point = {number : int; coord : float * float}
     let count = ref 0 (*Initialization*)
     let make_point (x, y) = incr count; {number = !count; coord = (x, y)}
     let dist p1 p2 = ...
   end;;

   # Plane_count.make_point ;;
   - : float * float &rarr; Plane_count.point

   # Plane_count.count ;;
   Unbound value Plane_count.count
   </pre>
   It is not possible to acces the variable denoted
   by <code>count</code>. Notice that the
   module <code>Plane_count</code> can be considered an instantiation
   of both signatures <code>METRIC_SPACE_2D</code>
   and <code>METRIC_SPACE_2D_COUNT</code>.
   </p>
   <p>Explicit typing implies which properties are important and
   underlies the independence of signatures relative to modules:
   <br/>
   <br/>
   <b>Property (3) of signatures:</b> The same module may instantiate
   multiple distinct signatures.
   </p>

   <h5>Compatibility of signatures</h5>

   <p>
   By what has been said in the previous section, we can now specify a
   reinterpration of the rules of explict typing by signature.
   <br/>
   <br/>
   <b>Compatibility between signatures : </b>
   Suppose <code>M<sub>1</sub></code> is a module satisfying the
   signature <code>S<sub>1</sub></code>; also, <code>M<sub>1</sub></code>
   also satisfies <code>S<sub>2</sub></code>. Then if:
   <ol>
   <li><code>S<sub>1</sub></code> includes <code>S<sub>2</sub></code>
   in terms of its set of elements.</li>
   <li>The types of the elements of <code>S<sub>1</sub></code> are
   respectively, equal to, compatible with or more general than those
   of <code>S<sub>2</sub></code>.</li>
   <li>Certain concrete types in <code>S<sub>1</sub></code> are
   abstract in <code>S<sub>2</sub></code>.</li>
   </ol>
   In this case we will say, the signature <code>S<sub>1</sub></code>
   is compatible with the signature <code>S<sub>2</sub></code>
   and <code>M<sub>1</sub></code> is an instance of both.
   <br/>
   <br/>
   So, the example of the preceding section, the
   signature <code>METRIC_SPACE_2D_COUNT</code> is compatible
   with <code>METRIC_SPACE_2D</code>. Note this definition is in
   general accord with the general definition of the compatibility of
   types. It can also be described as <i>structural</i> : it depends
   only on the form of the signatures, it does not need to be made
   explicit by the programmer.
   </p>

   <p>
   The compatibility between signatures must be associated with
   another possibility of modules which brings them closer to the
   usual behavior of values : a module may be bound to an arbitrary
   number of distinct identifiers. It is indeed possible to construct
   new bindings of modules to existing modules. For example:
   <pre class="prettyprint ml">
   # module P = Plane_count;;
   </pre>
   Here the module <code>P</code> is made to be a reference to the
   same implementation of the module <code>Plane_count</code>. It is
   similar to the effect to that which governs the definition of new
   bindings by <code>let</code> : a new copy of the
   module <code>Plane_count</code> is not produced (in this imperative
   example, the internal counter of the <code>Plane_count</code>
   points will be shared).
   </p>

   The construction of such module links can obviously be accompanied
   by explicit typing and under the umbrella of the notion of
   compatibility:
   <pre class="prettyprint ml">
   # module P1 : METRIC_SPACE_2D = Plane_count;;
   # module P2 : METRIC_SPACE_2D_COUNT = Plane_count;;
   </pre>
   or, in an equivalent manner:
   <pre class="prettyprint ml">
   # module P1 = (Plane_count : METRIC_SPACE_2D);;
   # module P2 = (Plane_count : METRIC_SPACE_2D_COUNT);;
   </pre>
   The explicit typing here authorises multiple visibilities of the
   same module : the module <code>P<sub>2</sub></code> exports all the
   elements of the <code>Plane_count</code> module whereas the
   module <code>P<sub>1</sub></code> just those elements that appear
   in the signature <code>METRIC_SPACE_2D</code>. Such multiple views
   can make sense in many situations. For example:
   <ul>
   <li><i>Distinguishing between error search phases.</i>  Elements
   are made public to be deprived but on which an error search applies
   (I have no idea what this means either)</li>
   <li><i>Distinguishing between access levels.</i> More or less of
   complete access is granted to the users of a module.</li>
   </ul>
   Note that this explicit typing via signatures can be phrased in
   terms of the classical type-transformation term of an "up-cast", a
   term which tenotes transformation of the the type of an element in
   the sense of a compatibility relation. A restriction on the "window
   of visibility" of a module by becoming the instance of a more
   general signature. The reverse, that is a type-transformation of
   the form of a "down-cast" is not allowed. There are in fact no more
   traces of the initial shape of a module after an up-cast. For
   example, if we now reconsider the previous example:
   <pre class="prettyprint ml">
   # module P1 : METRIC_SPACE_2D = Plane_count;;
   # module P2 : METRIC_SPACE_2D_COUNT = P1 ;;
   Signature error
   </pre>
   It is not possible to retrieve the initial module by an <i>a
   posteriori</i> retyping to its complete signature.
   </p>

   <h5>Public exceptions</h5>

   <p>
   In the context of explicit typing, the exporting of exceptions
   necessarily passes through their definition in the signature. For
   example:
   <pre class="prettyprint ml">
   module type FACT = sig
     exception Neg
     val fact : int &rarr; int
     (*Raises [Neg] if the given argument is negative*)
   end;;

   module E : FACT = struct
     exception Neg
     let rec fact n = ...
   end;;
   </pre>
   Conforming to the rules of explicit typing by signatures, an
   instantiation of the signature <code>FACT</code> includes
   necessarily the exception <code>Neg</code>. This double definition
   is a mark of exporting an exception and makes it usuable outside
   the module:
   <pre class="prettyprint ml">
   # E.Neg ;;
   - : exn = E.Neg
   </pre>
   The interest in exporting them of course is to make possible their
   processing from outside the module. Their appearence in the
   signature gives more opportunity to specify the character of the
   functions likely to use them. Their commentary can thus help
   prepare for the treatment of errors. Note however, some exceptions
   need not be exported. They can sometimes be restricted to
   exploitation by the private implementation of the module. Recall
   also that their exists in OCaml a fairly large collection of
   predefined exceptions that are global.
   </p>

   <h5>Public types</h5>

   <p>
   With explicit typing by signatures, as for exceptions, to export
   types from a module requires their implementation in the
   signature. In other words, the types must be concrete and not
   abstract if they are to be exported. For example, consider complex
   numbers, but this time with a representation in the form of records
   which integrate both the real part, their imaginary part and their
   precalculated norm:
   <pre class="prettyprint ml">
   module type COMPLEX = sig
     type complex = {real : float; im : float; norm : float}
     val make : float * float &rarr; complex
     val add : complex &rarr; complex &rarr; complex
     val norm : complex &rarr; float
   end;;
   </pre>
    The definition of the type <code>complex</code> within the
    signature renders it public for any instantiation. In particular,
    the fields of the record are directly usable:
   <pre class="prettyprint ml">
   module Complex : COMPLEX = struct
     type complex = {real : float; im : float; norm : float}

     let make (r, i) = {re = r; im = i;
                        norm = sqrt (r ** 2. + i ** 2.)}
     let add z w = ...
     let norm z = z.norm
   end;;

   # let zq = Complex.make (4., 3.);;
   val z1 : Complex.comple = 
     {Complex.re = 4.; Complex.im = 3.; Complex.norm = 5}

   # z1.Complex.re;;
   - : float = 4.

   # z1.Complex.norm;;
   - : float = 5.
   </pre>
   However, the interest of exporting types is questionable. For
   example, one observes here an interaction between the
   field <code>norm</code> and the function <code>norm</code> and
   assumes an equivalence. The relationship between the declared norm
   and the calculated norm can nevertheless take a more sophisticted
   turn.
   </p>

   <h5>Private and abstract types</h5>

   <p>
   A final development is necessary regarding visibility and the
   explicit typing of modules. As stated in the "rule (2) of the
   visibility of modules", there is a particular case: when explicitly
   typing modules with signatures, an abstract type is not rendered
   public. The abstract character of such types is
   maintained. Modifying the previous example:
   <pre class="prettyprint ml">
   module type COMPLEX = sig
     type complex (*abstract*)
     val make : float * float &rarr; complex
     ...
   end;;
    
   module Complex : COMPLEX = struct (*explicit type*)
     type complex = {real : float; im : float; norm : float}

     let make (r, i) = {re = r; im = i;
                        norm = sqrt (r ** 2. + i ** 2.)}
     ...
   end;;

   # let z1 = Complex.make (4., 3.);;
   val z1 : Complex.complex = &lt;abstr&gt;

   # z1.Complex.re
   Unbound record field label
   </pre>
   The responses of the type inference hide here the representation of
   the type mentioning only that it is <code>&lt;abstr&gt;</code>. It
   is therefore impossible to access directly, even to display, the
   values associated with a complex number. Specific accessors are now
   indispensable. It is possible to extend the
   signature <code>COMPLEX</code> with a general accessor, here we'll
   name it <code>show</code> which returns a complex number in the
   form of a pair of <code>float</code>:
   <pre class="prettyprint ml">
   module type COMPLEX = sig
     type complex (*abstract*)
     val make : float * float &rarr; complex
     val show : complex &rarr; float * float
     ...
   end;;

   module Complex : COMPLEX = struct (*explicit type*)
     type complex = {real : float; im : float; norm : float}

     let make (r, i) = {re = r; im = i;
                        norm = sqrt (r ** 2. + i ** 2.)}

     let show z = (z.re, z.im)

     ...
   end;;
   </pre>
   The type <code>complex</code> is henceforth hidden, instantiable
   and exploitable:
   <pre class="prettyprint ml">
   # let z1 = Complex.make (4., 3.);;
   val z1 : Complex.complex = &lt;abstr&gt;

   # Complex.show z1;
   - : float * float = (4., 3.)
   </pre>
   </p>

   <p>
   Certain types of data lend themselves to the hiding of their
   representation better than others. For example, those
   data-structures that naturally provide accessors and constructors
   of empty structures or of particular sizes. Let us recall the
   following example:
   <pre class="prettyprint ml">
   module type LINEAR_CONTAINER = sig
     type &alpha; lin
     val empty : unit &rarr; &alpha; lin (*constructor*)
     val add : &alpha; &rarr; &alpha; lin &rarr; &alpha; lin
     val nth : &alpha; lin; &rarr; int &rarr; &alpha; (*accessor*)
   end;;

   module L : LINEAR_CONTAINER = struct
     type &alpha; lin = Empty | Cons of &alpha; * &alpha lin
     let empty () = Empty
     let add x l = ...
     let nth l n = ...
   end;

   # let l1 = L.add 111 (L.add 666 (L.empty ()));;
   val l1 : int L.lin = &lt;abstr&gt;

   # L.nth l1 1;;
   - : int = 666
   </pre>
   The universal type parameter <code>&alpha;</code> can be equally
   well instantiated with a hidden type as with a public type. In
   other words, the responsibility of msasking the values contained by
   the containers is left in the hands of the users. For example, it is
   possible to insert a hidden complex number in the container of
   type <code>&alpha; lin</code>:
   <pre class="prettyprint ml">
   # let l1 = L.add (Complex.make (4.0, 3.0)) (L.empty ());;
   val l1 : Complex.complex L.lin = &lt;abstr&gt;

   # L.nth l1 0;;
   - : Complex.complex = &lt;abstr&gt;
   </pre>
   Of course, the application of the <code>show</code> accessor is required if it is desired to obtain the explicit values:
   <pre class="prettyprint ml">
   # Complex.show (L.nth l1 0);;
   - : float * float = (4., 3.)
   </pre>
   We therefore have the possibility to implement controlled
   visibility of the elements which make up a module. In the case of
   the implementation of data types, this complete mastery of
   visibility permits us to define abstract data types where details
   of the representation are necessarily hidden (and therefore based
   on abstract types in the corresponding signatures).
   </p>

   <h4>Abstract data types</h4>

   <h5>The reasons for hiding and substitution</h5>
   <p>
   Visibility control of the elements of modules, in other words
   - <i>implementation hiding</i> - is an important tool for the
   production of modular programs of quality. Hiding in effect assures
   indepdence between modules. Without that independence, certain
   properties mentioned at the outset of the section are
   compromised. For example, implementation dissemination can make it
   difficult to make any subsequent changes and adapations and
   extensions tedious and delicate to carry out.
   </p>
   <p>
   On the other hand, hiding is based on signatures, that is, elements
   that describe the programm without fixing on or revealing an
   implementation (the specification). The signatures contain the
   abstractions, the interfaces, a screen over the particulars of a
   program. However the signatures indicate as well the organisation
   of the program composed as distinct modules. They represent by
   themselves the logical architecture.
   </p>
   <p>
   If the properties sought through modular programming have so far
   been expressed in a very general way, what has just been said has
   allowed us to establish a principal that more concretely
   characterize a good modular organisation:
   <br/>
   <br/>
   <b>The principle of modular substitutivity : </b> Let <b>S</b> be
   the set of signatures that specify a modular program <i>Prog</i>,
   and let <code>M</code> be a component of <i>Prog</i> that satisfies
   a signature <code>S</code> \(\in\) <b>S</b>. Then, any component
   that also satisfies <code>S</code> may be substituted
   for <code>M</code> without any other modifications of <i>Prog</i>.
   <br/>
   <br/>
   This principle expresses what is meant by "to be independent" in
   the case of a set of modular components. It gives rise to a similar
   virtue of the notion of referential transparency in functional
   programming, that is to say, a strict localization of the effects
   of an action on the program. Under the aegis of the "principle of
   substitutivity", a program can be first specified and its
   realization and development broken down component by component.
   </p>
   <p>
   In the following, we now illustrate some of the ideas of
   implementation of abstract data types and present precise
   techniques offed by OCaml to implement them. We shall then return
   to these general questions.
   </p>

   <h5>How to evolve datatypes</h5>

   <p>A representative situation for evolution in modifying programs
   consists of adaptions in the interest of performance improvments in
   time and space. Optimisation is often performed after an operation
   is revealed to be complex and tedious. It is therefore economic in
   the early phases of development of a program to make it easy to
   return thereafer and substitute more efficient code.
   </p>
   <p>
   In the context of abstract data types, these modifications lead
   generally to representations that are very far removed from those
   that seem natural at the outset. In effect, the implementations
   then carry technical information which contributes to the
   optimization of their associated functions. We have already seen
   several examples. For example, consider the case of the
   specification of a datatype for queues:
   <pre class="prettyprint ml">
   module type FIFO_CONTAINER = sig
     type &alpha; queue
     val empty : unit &rarr; &alpha; queue
     val add : &alpha; &rarr; &alpha; queue &rarr; &alpha; queue
     val fst : &alpha; queue &rarr; &alpha;
     val out : &alpha; queue &rarr; &alpha; queue
   end;;
   </pre>
   The signature could be directly implemented with a list and without
   too much regard to the effects of the persistent nature resulting
   from being of functional character:
   <pre class="prettyprint ml">
   module Q_list : FIFO_CONTAINER = struct
     type &alpha; queue = &alpha; list
     let empty () = []
     let add x q = q @ [x]
     let fst q = ...
     let out q = ...
   end;;
   </pre>
   The signature however, equally allows for an implementation
   optimized for queues:
   <pre class="prettyprint ml">
   module Q_burton : FIFO_CONTAINER = struct
     type &alpha; queue = Q of &alpha; list * &alpha; list
     let empty () = Q ([], [])
     let add x (Q (l1, l2)) = ...
     let fst q = ...
     let out q = ...
   end;;
   </pre>
   This change of representation is transparent to any user who is
   restricted to the signature <code>FIFO_CONTAINER</code> : the
   module <code>Q_burton</code> may be directly substituted
   for <code>Q_list</code> even though the representations are quite
   different.
   </p>
   <p>
   Here's another classic example for the structure of association
   tables. These tables may be initially specified in a minimal way:
   <pre class="prettyprint ml">
   module type ASSOC_TABLE = sig
     type (&alpha;, &beta;) assoc
     val empty : unit &rarr; (&alpha;, &beta;) assoc
     val get_pair : (&alpha;, &beta;) assoc &rarr; &alpha; * &beta;
     val assoc : (&alpha;, &beta;) assoc &rarr; &alpha; &rarr; &beta;
     val add : &alpha; &rarr; &beta; &rarr; (&alpha;, &beta;) assoc &rarr; (&alpha;, &beta;) assoc
     val sub : &alpha; &rarr; (&alpha;, &beta;) assoc &rarr; (&alpha;, &beta;) assoc
   end;;
   </pre>
   This signature is easily implemented as a list:
   <pre class="prettyprint ml">
   module Assoc_list : ASSOC_TABLE = struct
     type (&alpha;, &beta;) assoc = (&alpha; * &beta;) list

     let empty () = []

     let get_pair l = 
       try
         List.hd l 
       with
       | Failure "hd" &rarr; failwith "No pair"

      let assoc l key = List.assoc key l

      let add key data l =
        try (assoc l key; failwith "Already inserted")
        with | Not_found &rarr; (key, data) :: l
     
      let sub key l = ...
   end;;

   # let t1 = Assoc_list.add 1 &alpha;' (Assoc_list.empty ());;
   val t1 : (int, char) Assoc_list.assoc = &lt;abstr&gt;

   # let t1 = Assoc_list.add 2 &beta;' t1;;
   val t1 : (int, char) Assoc_list.assoc = &lt;abstr&gt;

   # Assoc_list.assoc t1 1;;
   - : char = &alpha;'
   </pre>
   When the elements of an association table are frequently accessed,
   it is normal to organise the association table in order that
   accessing elements is of logarithmic complexity. For this we can
   utilize the simple definition of binary search trees but of the
   balanced variety, for example, red-black trees:
   <pre class="prettyprint ml">
   module Assoc_rb_tree : ASSOC_TABLE = struct
     type color = R | B

     type (&alpha;, &beta;) assoc =
       | Empty
       | Node of color * (&alpha;, &beta;) * (&alpha;, &beta;) assoc * (&alpha;, &beta;) assoc

     let empty () = Empty
 
     let get_pair t = match t with
       | Empty &rarr; failwith "No pair"
       | Node (_, x, _, _) &rarr; x

     let rec assoc t key = match t with
       | Empty &rarr; raise Not_found
       | Node (_, (key', data), l, r) &rarr;
           if key = key' then data else
           if key < key' then assoc l key 
           else assoc r key

      let local_balance = ...
      let add key data t = ...
      let sub key t = ...
   end;;
   </pre>
   Again, the optimisation can be used transparently due to
   conformance to the <code>ASSOC_TABLE</code> signature:
   <pre class="prettyprint ml">
   # let t1 = Assoc_rb_tree.add 1 &alpha;' (Assoc_rb_tree.empty ());;
   val t1 : (int, char) Assoc_rb_tree.assoc = &lt;abstr&gt;

   # let t1 = Assoc_rb_tree.add 2 &beta;' t1;;
   val t1 : (int, char) Assoc_rb_tree.assoc = &lt;abstr&gt;

   # Assoc_rb_tree.assoc t1 1;;
   - : char = &alpha;'
   </pre>
   One obtains the same behavior as for the preceding implementation.
   </p>

   <h5>Optimizing datatypes by "memoization"</h5>

   <p>
   Here are other examples of abstract data types using a particular
   optimization technique. Recall the case of complex numbers with a
   representation that includes a pre-calculated norm. If this value
   is not used, this calculation becomes useless. One way to remedy
   this situation is to calculate it on first use (this is called
   "memoization"). Here is an implementation which qpplies this
   technique that equally well satisfies the
   signature <code>COMPLEX</code>:
   <pre class="prettyprint ml">
   module Complex_memo : COMPLEX = struct
     type complex = { re : float; im : float;
                      mutable norm : float option } (*memoization*)

     let make (r, i) = { re : r; im : i; norm = None}

     let show z = (z.re; z.im )

     let add z w = make (z.re +. w.re, z.im +. w.im)

     let norm z = match z.norm with
       | Some x &rarr; x
       | None &rarr; let m = sqrt (z.re ** 2. + z.im ** 2.) in
                 (z.norm <- Some m; m)
   end;;
   </pre>
   This optimization is transparent from the point of view of using
   complex numbers through the signature <code>COMPLEX</code>:
   <pre class="prettyprint ml">
   # let z1 = Complex_memo.make (3., 4.);;
   val z1 : Complex_memo.complex = &lt;abstr&gt;

   # let z2 = Complex_memo.add z1 z1;
   val z2 : Complex_memo.complex = &lt;abstr&gt;

   # Complex_memo.show z2;;
   - : float * float = (8., 6.)
   </pre>
   There are cases where memoization of all calculations proves to be
   unsuitable or too heavy. For example, successive searches into a
   data structure can not all be transformed into immediate
   access. The idea is rather to put in place "caches" which provide
   direct references only for the most recent searches. These caches
   act as a set of opportunities to take "shortcuts". A problem then
   arises when one modifies the data structure: elements that are
   deleted by are nevertheless referenced by a cache are not
   recoverable by the garbage collector; they remain referenced by
   their shortcuts but they may not be utilized as they no longer
   exist... A solution to this paradox is offered by the notion of
   a <i>weak</i> reference, that is a reference to an element the
   garbage collector is entitled to recover. As long as these element
   exist, these references make it possible to reach them; if these
   elements are to be destroyed, these references do not impede the
   garbage collector in harvesting them.
   </p>
   <p>
   The <code>Weak</code> module in the OCaml stanard library provides
   an implementation of a table of weak references. For example, we
   can integrate the technique of memoization by caches with an
   inmplementation of a table of associations : each will have an
   individual cache that will allow to reach directly the elements
   previously accessed. The association function will therefore give
   priority to the cache and then, in the case of failure on the table
   of associations. This operation will also be responsible for
   updating the cache. Here is an implementation based on binary trees
   that satisfies the signature <code>ASSOC_TABLE</code>:
   <pre class="prettyprint ml">
   module Assoc_tree : ASSOC_TABLE = struct
     let cache_size = 5 (*fixed cache size*)

     type (&alpha;, &beta;) bintree = 
       | Bin_empty
       | Bin_node of (&alpha; * &beta;) * (&alpha;, &beta;) bintree * (&alpha;, &beta;) bintree

     type (&alpha;, &beta;) assoc = { tree : (&alpha;, &beta;) bintree ;
                             cache : (&alpha; * &beta;) Weak.t ;
                             mutable index : int
                          }

      let empty () = { tree = Bin_empty; 
                       cache = Weak.create cache_size;  
                       index = 0}

      let get_pair { tree = t } = match t with
        | Bin_empty &rarr; failwith "No pair"  
        | Bin_node &rarr; (x, _, _) &rarr; x

      let assoc_direct table key =
        let rec aux t = match t with
          | Bin_empty &rarr; raise Not_found
          | Bin_node ((key'; data'), t1, t2) &rarr;
              if key = key' then data' else
              if key < key' then aux t1 else aux t2
        in aux table.tree

      let assoc table key =
        let res = ref None in
        let index = ref 0 in
        begin (*search the cache*)
          while (!index < cache_size) && (!res = None) do
            match Weak.get table.cache !index with
              | Some (key', data) &rarr;
                  if key = key' then res := Some data else incr index
              | None &rarr; incr index
          done ;
          match !res with
            | Some x &rarr; x
            | None &rarr;
                let data = assoc_direct table key in
                Weak.set table.cache table.index (Some (key, data));
                table.index <- (table.index + 1) mod cache_size;
                data
        end

       let add key data table = ...
       let sub key table = ...
   end;;
   </pre>
   Obviously, this implementation is much more complex than the others
   and only really justified for very large trees. However, the
   optimization is still transparent to the user. All these examples
   show that an improvement of a data type could include radical
   changes in the form of its instances. Exporting of the
   representation of these types would be very bad if they had to be
   modified after their dissemination into the code. This work could
   prove to be not only laborious but problematic. Indeed, the user
   might find herself in the necessity of managing the creation, the
   coherence and the processing in the module associated with the
   datatype. That said, implementation hiding is a technique not
   without difficulties and traps. We will develop some of them in the
   following. Let us first recall that the type
   variables <code>&alpha;</code>, <code>&beta;</code> etc are instantiable in
   masked types. On the other hand, only structural functions are
   capable of offering a universal generiticy, that is to say, a truly
   uniform treatment of their arguments whatever the representation.
   </p>

   <h5>Hiding and generating predefined predicates</h5>

   <p>
   The multiple implementations of the last few pages have established
   the framework of the "principle of module substituion". Optimized
   versions have replaced non-optimized versions transparently. This
   is only possible however if we take care to avoid transmitting
   implicitly someting concealed between the components in spite of
   their adherence to their respective signatures.
   </p>
   <p>
   There exists a case in OCaml which is particularly representative
   of this difficulty. For example, reconsider the complex number
   type <code>Complex_memo</code> which uses memoization for the
   norm. The representation of values of the type is the following:
   <pre class="prettyprint ml">
   type complex = {re : float; im : float; mutable norm : float option}
   </pre>
   Recall that the predefined equality operator '<code>=</code>' over
   records, compares each field. Under these conditions, the equality
   function is no long valid on such a lazy representation:
   <pre class="prettyprint ml">
   # let z1 = Complex_memo.make (1., 1.1)
     let z2 = Complex_memo.make (1., 1.1);;

   # z1 = z2;; 
   - : bool = true

   # Complex_memo.norm z1;
   - : float = 1.414213

   # z1 = z2;;
   - : bool = false
   </pre>
   The origin of this behavior may be even more difficult to discover
   when comparison predicates are used by other functions. For example:
   <pre class="prettyprint ml">
   # let z1 = Complex_memo.make (1., 1.)
     let z2 = Complex_memo.make (1., 1.)
     let l1 = [z1; z1; z1];;

   # List.mem z2 l1;;
   - : bool = trure

   # Complex_memo.norm z1;;

   #List.mem z2 l1;
   - : bool = false
   </pre>
   Implmentation of the function <code>List.mem</code> utilizes the
   default equality function.
   </p>
   <p>Thus, the contribution of these comparison predicates puts in
   peril the independence of modular components. The earlier example
   shows that moving from a trivial implementation of complex numbers
   to an implementation with memoisation induces noticeable
   differences in behavior.
   <br/>
   <br/>
   <b>Constraint (1) of substitutivity : </b> The principle of module
   substitutivity is not strictly applicable in OCaml when abstract
   types are used by functions that use comparison functions of their
   instances.  <br/> <br/> In particular, a signature for complex
   numbers must inclue an explicit specification of functions to
   compare them to work around the problems just discussed:
   <pre class="prettyprint ml">
   module type COMPLEX = sig
     type complex
     val make : float &rarr; float &rarr; complex
     val show : complex &rarr; float * float
     val eq : complex &rarr; complex &rarr; bool
     val less_than_eq : complex &rarr; complex &rarr; bool
     ...
   end;;
   </pre>
   </p>

   <h5>Hiding and imperative optimizations</h5>

   <p>
   We have seen examples using imperative features whilst ensuring
   partioning of this style: nothing was visible outside of the
   module. The values were simply associated with modifiable
   information that optimized their evaluation. The only noticeable
   effect in this case is an "evaluation sharing" which does not alter
   referential transparency. The preceding section illustrates the
   problem of comparing values by means of the default predicates but
   this difficulty was related only to an interaction between hiding
   and restrained generiticy of the predicates. It would be possible
   to envisage transformations of the implementation of a module
   integrating more fully the imperative style. For example, here is a
   signature specifying the type of sets:
   <pre class="prettyprint ml">
   module type SET = sig
     type &alpha; set
     val empty : unit &rarr; &alpha; set
     val mem : &alpha; &rarr; &alpha; set &rarr; bool
     val add : &alpha; &rarr; &alpha; set &rarr; &alpha; set
     val union : &alpha; set &rarr; &alpha; set &rarr; &alpha; set
     val inter : &alpha; set &rarr; &alpha; set &rarr; &alpha; set
   end;;
   </pre>
   It is possible first of all to utilize a functional representation
   of sets:
   <pre class="prettyprint ml">
   module Set_fun : SET = struct
     type &alpha; set = &alpha; &rarr; bool
     let empty () = fun y &rarr; false
     let mem x s = s x
     let add x s = if mem x s then s else fun y &rarr; s y || x = y
     let rec union s1 s2 = fun y &rarr; s1 y || s2 y
     let rec inter s1 s2 = fun y &rarr; s1 && s2 y
   end;;
   </pre>
   So,
   <pre class="prettyprint ml">
   # let s1 = Set_fun.add 1 (Set_fun.add 2 (Set_fun.empty ()));;
   val s1 : int Set_fun = &lt;abstr&gt;

   # Set_fun.mem 2 s1;;
   - : = true
   </pre>
   The purely functional style allows here a terse and not conductive
   to errors program. On the other hand, the complexities in time and
   space are high. Consequently, seceral possibilities of optimization
   might be contemplated. Association tables for example might be
   considered for exploiting an ordering of the elements of the set
   and thereby inducing a tree like structure. One could also
   contribute a hash table of imperative character such as to be found
   in the <code>Hashtable</code> module of the standard library. Note
   that tables are presented as association tables. In order to use
   them as simple tables, the usual tactic is to systematically
   associate keys with constants. The latter can then correspond to
   the elements of the set. Here is a new implementation that
   satisfies <code>SET</code>:
   <pre class="prettyprint ml">
   module Set_h : SET = struct
     type &alpha; set = (&alpha;, unit) Hashtbl.t

     let dummy = ()

     let empty () = Hashtbl.create 0

     let mem x h = Hashtbl.mem x

     let add x h1 =
       if mem x h1 then h1
       else let h = Hashtbl.copy h1 in (Hashtbl.add h x dummy; h)

     let union h1 h2 =
       let h = Hashtbl.copy h1 in
       Hashtbl.iter (fun x _ &rarr; ignore (add x h)) h2; h

     let inter h1 h2 =
       let h = empty () in
       Hashtbl.iter (fun x _ &rarr;
         if (Hashtbl.mem h1 x) && (Hashtbl.mem h2 x) then
           Hashtbl.add h x dummy) h1; h
   end;;
   </pre>
   Then, in the same manner as <code>Set_func</code> :
   <pre class="prettyprint ml">
   # let s1 = Set_h.add 1 (Set_h.add 2 (Set_h.empty ()));;
   val s1 : int Set_h = &lt;abstr&gt;

   # Set_h.mem 2 s1;;
   - : = true
   </pre>
   Due to the use of hash tables, accessing the elements of the set is
   fast (the function <code>mem</code> is guaranteed to return in
   constant time). However, it should be noted this implementation
   preserves the functional character of the specification of the
   operation <code>add</code>, that is,
   <pre class="prettyprint ml">
   val add : &alpha; &rarr; &alpha; set &rarr; &alpha; set
   </pre>
   Indeed, the implementation of <code>add</code>
   in <code>Set_h</code> causes the sets to be persistent : each
   insertion implies a complete copy of the hash table. We could of
   course override this property of <code>add</code> so as to
   camouflage it's imperative behavior :
   <pre class="prettyprint ml">
   # let add x h1 =
       if mem x h1 then h1
       else (Hashtbl.add h1 x dummy; h1)
   val add : &alpha; &rarr; &alpha; set &rarr; &alpha; set
   </pre>
   We refer here to the table <code>h1</code> after
   modification. However, doing so give rise to the problems of
   referential transparency no longer being verified in an expression
   making use of these sets and delicate errors may result.
   </p>
   <p>
   This exmaple illustrates the neccessity of reflecting clearly the
   intent of the style of the signature and to conform to it.
   <br/>
   <br/>
   <b>Constraint (2) of substitutivity : </b> The pricinciple of
   module substitutivity is not strictly applicable in a functional
   framework if imperative features are not strictly
   compartmentalized.
   <br/>
   <br/>
   In other words, the preservation of the substitution principle
   justfies what is illustrated in:
   <br/>
   <br/>
   <b>Indication of imperative features in the specificiation : </b>
   In signatures, those operations with imperative behavior appear as
   procedure declarations (results are of type <code>unit</code>).
   <br/> <br/> For example, if full use were to be made of a table of
   imperative style, the signature <code>SET</code> should reflect
   this:
   <pre class="prettyprint ml">
   module type SET = sig
     type &alpha; set
     val add : &alpha; &rarr; &alpha; set &rarr; unit
     ...
   end;;
   </pre>
   The function for adding an element to a set exhibits an imperative
   character.
   <pre class="prettyprint ml">
   # let add x h =
       if not (mem x h) then Hashtbl.add h x dummy;;
   val add : &alpha; &rarr; &alpha; set &rarr; unit
   </pre>
   This example shows again the difficulties of preventing propagation
   of the imperative style. If its application gives rise to
   behavioral changes which escape a specification, they will surprise
   and demand consequent work of a search for errors : an expected
   effect when the principle of substitutivity applies only in
   pretense. The strict partitioning of styles however here leads to a
   multiplication of signatures : the ones in a style purely
   functional, the others in the imperative style. Optmization via
   imperative constructs is not directly applicable. It is however
   possible to unify signatures by application of a generalization for
   the return types of functions. Indeed, in the framework of
   implementing abstract data types, these types characterize the
   style alone. For example,
   <pre class="prettyprint ml">
   module type SET_GEN = sig
     type &alpha; set
     type &alpha; result
     ...
     val add : &alpha; &rarr; &alpha; set &rarr; &alpha; result
     ...
   end;;
   </pre>
   The type <code>&alpha; result</code> can be instaniated either by
   the same type as <code>&alpha; set</code> indicating a functional
   implementation or, by by <code>unit</code> indicating an imperative
   one.
   </p>
   
   <h5>The need for individual hiding of abstract types</h5>

   <p>
   Our current knowledge of the control of type visibility is
   summarized in the following alternative when a
   signature <code>S</code> is used to explicitly type a
   module <code>M</code>:
   <ul>
   <li>A concrete type in <code>S</code> is public</li>
   <li>A type abstract in <code>S</code> is private to <code>M</code></li>
   </ul>
   These possibilities lack a little nuance. We might sometimes want
   to export an abstract type of <code>S</code> after its
   implmentation in <code>M</code>. But what are the situations that
   engener the need to derogate from type abstraction? Here is the
   representative case. When the represntation of values is to be
   hidden but there is a need to use its constructors as
   accessors. The constructors must then have arguments whose types
   are public and the accessors must also have results whose types are
   public. For example, the signature <code>COMPLEX</code> declares
   functions in the following form:
   <pre class="prettyprint ml">
   val make : float * float &rarr; complex
   val show : comple &rarr; float * float
   </pre>
   Here the respective types of the parameters and the result are
   based on the predefined type <code>float</code>. This constraint is
   probably acceptable for conventional use but it will prevent the
   implementation of certain implementations. Suppose we wished to
   obtain a type for "big complex numbers" from the library
   module <code>Num</code>, that is to say,
   <pre class="prettyprint ml">
   module Complex_num = struct
     type complex = C of Num.num * Num.num

     let make (str_r, str_i) = 
       C (Num.num_of_string str_r, Num.num_of_string str_i)

     let show (C (r, i)) =
       (Num.string_of_num r, Num.string_of_num i)

     let add (C (r1, i1)) (C (r2, i2)) =
       C (Num.( + ) r1 r2, Num.( + ) i1 i2)

     let norm (C (r, i)) =
       sqrt (Num.float_of_num 
         (Num.add_num (Num.square_num r) (Num.square_num i)))
   end;;
   </pre>
   These complex numbers possess real and imaginary parts that are
   abitrarily large and precise:
   <pre class="prettyprint ml">
   # let z1 = Complex_num.make ("3214321/764365", "8920146398/4291")
     let z2 = Complex_num.add z1 z1;;
   # Complex_num.show z2;
   - : string * string = ("3214321/764365", "8920146398/4291")
   </pre>
   It is observed that the types of the parameters of the constructor
   and the accessor of the module <code>Complex_num</code> have
   undergone a transformation. The exterior representation of large
   numbers from <code>Num</code> uses strings instead of floating
   numbers.
   <pre class="prettyprint ml">
   val make : string * string &rarr; complex
   val show : complex &rarr; string * string
   </pre>
   The module <code>Complex_num</code> does not satisfy the
   signature <code>COMPLEX</code>. We can nevertheless generalize will
   this signature with respect to the types of constructors of the
   accessors.
   <br/>
   <br/>
   <b>Technique of generalization of constructors/accessors for
   external types</b> : If <code>t</code> is the representation of
   values of a datatype, we associate a type <code>extern_t</code>
   which constitues the externally view of an instance of
   type <code>t</code>.  
   <br/>
   <br/>
   Thus, in <code>COMPLEX</code> we replace the type <code>float *
   float</code> with a new abstract type <code>extern_complex</code>:
   <pre class="prettyprint ml">
   module type COMPLEX_MASK = sig
     type complex
     type extern_complex
     val make : extern_complex -> complex
     val show : complex -> extern_complex
     val add : complex -> complex -> complex
     val norm : complex -> float
   end;;
   </pre>
   The definition of the type <code>extern_complex</code> can then be
   added to <code>Complex_num</code>:
   <pre class="prettyprint ml">
   module Complex_num = struct
     type complex = C of Num.num * Num.num
     type extern_complex = string * string
     ...    
   end;;
   </pre>
   This implementation becomes compliant to the
   signature <code>COMPLEX_MASK</code>:
   <pre class="prettyprint ml">
   module Complex_num : COMPLEX_MASK = struct
    ...
   end;;
   </pre>
   However, the types <code>complex</code>
   and <code>extern_complex</code> are now both made private by this
   explict typing. The functions <code>make</code>
   and <code>show</code> have become unusable:
   <pre class="prettyprint ml">
   # let z1 = Complex_num.make ("3214321/764365", "8920146398/4291");;
   Type error
   </pre>
   This technique of generalization has augmented the possibilities of
   instantiation of the signature but has neccessarily requires to
   export certain abstract types after their implementation. This
   situation find itself in connection with the
   signature <code>SET_GEN</code> whose definitions of the generalized
   type <code>&alpha; result</code> will also have to be exported. In
   other words, we need a new rule of visibility of individual hiding
   of abstract types. The more careful control of the visibility of
   the types will be possible thanks to a new construction which will
   be described in the following.
   </p>

   <h5>Individual hiding and type constraints</h5>
   <p>
   Signatures can be supplemented by explicit type constraints. The
   constraints are capable of associating <i>a posteriori</i> with
   definitions of abstract types, and are expressed through the
   construction <code>with type</code>:
   <pre class="prettyprint ml">
   &lt;SIGNATURE&gt; with type &lt;type 1&gt; = &lt;expression of type 1&gt;
                     and type ...
                     and type &lt;type n&gt; = &lt;expression of type n&gt;
   </pre>
   where the <code>&lt;type i&gt;</code> denote types included
   in <code>&lt;SIGNATURE&gt;</code> and the <code>&lt;expression of
   type i&gt;</code> is a valid type definition in the environment at
   the moment of application of the type constraint. For example:
   <pre class="prettyprint ml">
   # module type S1 = sig
       type t
       val f : t -> t
     end;;

   # module type S2 = (S1 with type t = int);;
   module type S2 = sig
     type t = int
     val f : t -> t
   end
   </pre>
   Thanks to this constraint, the abstract type <code>t</code> is
   abstract in <code>S1</code> and made concrete in <code>S2</code>.
   <br/>
   <br/>
   <b>Making types concrete with the <code>with type</code>
   construction</b>: Type constraints can make concrete types of types
   that were not originally so. These types then become exportable.
   <br/> <br/> A signature can thus see some of its abstract types
   become concrete. This transformation resolves the problem posed by
   the signature <code>CONCRETE_MASK</code> of the preceding section:
   <pre class="prettyprint ml">
   module Complex_num : COMPLEX_MASK
      with type extern_complex = string * string =
   struct
     type complex = C of of Num.num * Num.num
     type extern_complex = string * string
     let make (str_r, str_i) = ...
     let show (C (r, i)) = ...
       ...
   end;;
   </pre>
   The constructor <code>make</code> becomes accessible from outside
   the module:
   <pre class="prettyprint ml">
   # let z1 = Complex_num.make ("3214321/764365", "8920146398/4291");;
   val z1 : Complex_num.complex = &lt;abstr&gt;
   </pre>
   </p>
   <p>
   Here are some remarks to help with usage of type constraints:
   <ul>
   <li><i>Neccessary duplication.</i> The syntax imposed by the
   construction <code>with type</code> sometimes seems somwhat
   fastidious since it requires a flagrant duplication between the
   type constraints and the definitions in the module. The
   implementation of the module must be consistent with the signature
   transformed by the addition of the type constraint. This
   duplication of code is the same as that which occurs in the
   relationship between signatures directly containing concrete types
   and their instantiations.
   <br/>
   <br/>
   </li>
   <li><i>Irreversibility of hiding. </i> A type which is hidden may not become revealed by the addition of a type constraint. For example,
   <pre class="prettyprint ml">
   # module type S1 = sig type t end;;
   # module M1 : S1 = struct type t = int end;;
   # module M2 : S1 with type t = int = struct type t = M.t end;;
   Type error
   </pre>
   The system cannot make the link here between <code>int</code>
   and <code>M.t</code>. Indeed, the name of a hidden type is
   definitiely associated with it's module : the name of
   the <code>int</code> type hidden in <code>M</code>
   is <code>M.t</code>. It will no longer be equivalent to "int". Type
   abstraction is directly reflected in OCaml by this syntactic
   difference between the names of types. 
   </li>
   </ul>
   </p>
   <p>
   Type constraints are the last ingredient needed to systematically
   implement abstract data type and more generally, modules whose
   implementations are systematically masked even in the case where it
   is necessary to export abstract types.
   <br/>
   <br/>
   <b>Modular programming with rigorous hiding</b>
   <ol>
   <li>No type definition is given in the signatures (no type
   definitively fixed as concrete)</li>
   <li>
   All modules are explicitly typed with a signature. <code>with
   type</code> constructions are applied on those types that need to be
   exported.
   </li>
   </ol>
   <br/> <br/> We will discuss again the interest in this modular
   programming style. Note that the first point above does not
   prohibit making use of global types like for example, the
   predefined types. The generalization of types in signatures is not
   an obligation, this is only a means of which we will still say a
   few words in the next section.
   </p>

   <h5>The conceptual generalization of signatures</h5>
   <p>
   Generalization renders signatures adaptable without having to
   redefine them, to rename them and thus to organize their
   variations. Additionally, the possibilities offered by type
   constraints make it possible to not fear the effects of the rules
   of visibility. If the examples of the preceding pages reveal
   essential techniques, it is important to remark that generalization
   can also extend conceptually the field of description of a
   signature. For example, consider a new signature of the notion of a
   bi-dimensional space with a distance:
   <pre class="prettyprint ml">
   module type METRIC_SPACE_2D = sig
     type point
     val make_point : float * float -> point
     val dist : point -> point -> float
   end;;
   </pre>
   The number of dimensions of the space is fixed by the type of the
   constructor <code>make_point</code>. Applying the external type
   technique it is possible to work around this constraint and propose
   a more general specification of spaces:
   <pre class="prettyprint ml">
   module type METRIC_SPACE = sig
     type point
     type extern_point
     val make_point : extern_point -> point
     val dist : point -> point -> float
   end;;
   </pre>
   And here first of all an instance adapted from one previously
   presented which could do all the business:
   <pre class="prettyprint ml">
   module Plane_count : METRIC_SPACE
     with type extern_point = float * float = 
   struct
     type point = { number : int; coord : float * float }
     type extern_point = float * float
     let count = ref 0
     let make_point (x, y) = ...
     let dist (x1, y1) (x2, y2) = ...
   end;;
   </pre>
   But, it is equally possible to define spaces with different
   dimensions. For example, a space of dimension \(1\):
   <pre class="prettyprint ml">
   module Line : METRIC_SPACE
     with type extern_point = float =
   struct
     type point = float
     type extern_point = float
     let make_point x = x
     let dist x1 x2 = abs_float (x1 -. x2)
   end;;
   </pre>
   It is also possible to envisage instantiations of the
   signature <code>METRIC_SPACE</code> with a dramatically different
   nature. For example, recognition and compression of alphanumeric
   character strings are based generally on quantitative comparisons
   and their representations as binary numbers. The functions of
   distance can then be put into contribution in order to structure
   the set of recognized characters and the characters to be
   recognized. The simplest of these functions is to count the number
   of pixels different from the respective representations. Here is a
   possible implementation of this novel space also
   satisfying <code>METRIC_SPACE</code>:
   <pre class="prettyprint ml">
   module Bit_map : METRIC_SPACE
     with type extern_point = int array array =
   struct
     type point = Bitmap of int array array
     type extern_point = int array array

     let make_point b = Bitmap b

     let dist (Bitmap b1) (Bitmap b2) =
       let len_x = Array.length b1 in
       let len_y = Array.length b1.(0)  in
       let diff_count = ref 0 in
       if len_x = Array.length b2 &&
          len_y = Array.lgength b2.(0)
       then
         for i = 0 to len_x -1 do
           for j = 0 to len_y - 1 do
             if b1.(i).(j) <> b2.(i).(j) then incr diff_count
           done
         done
       else failwith "Bitmap sizes different"
       float (!diff_count)
   end;;
   </pre>
   </p>

   <h5>Tactics for naming abstract data types</h5>
   <p>
   The implementation of abstract data types by modular means is
   dependent on the relationships mainted by three elements:
   <ol>
   <li>The signature of the datatype</li>
   <li>The type of the data itself</li>
   <li>The representation of values included in the datatype</li>
   </ol>
   These three elements must of course bear names and their choice is
   not so innocent of that. The names participate in the quality of
   the abstraction and they predispose more or less to
   compatibility. One point in particular distinguishes many "tactics
   of naming" (which we have already observed in previous examples):
   <ul>
   <li><i>Homogenous naming tactics.</i> The distinctions between the
   three elements above are reduced by names which are as similar as
   possible. For example:
   <pre class="prettyprint ml">
   module type COMPLEX = sig
     type complex
     val add : complex -> complex -> complex
     ...
   end;;

   module Complex : COMPLEX = struct
     type complex = ...
     ...
   end;;
   </pre>
   This homogeneity of naming expresses here that there is only one
   element that counts : the type of complex numbers.
   <br/>
   <br/>
   </li>
   <li><i>Algebraic naming tactics.</i> The distinctions between the
   three elements are emphasized by giving them distinct names. The
   "algebraic" character of the type of data are also made apparent :
   a type of data is endeed a set of values structured by associated
   operations.
   <br/>
   <br/>
   <ul>
   <li><i>Strong distinction.</i> We assert the difference between the
   type of data and its representation of values by different and
   descriptive names. For example:
   <pre class="prettyprint ml">
   module Plane = struct
     type point = ...
     let dist x y = ...
   end;;
   </pre>
   The representation of values here bears the particular name
   of <code>point</code> to which is added a distance generating by
   itself a particular space that is to say, the <code>Plane</code>.
   <br/>
   <br/>
   </li>
   <li><i>Weak distinction.</i> The characteristics of the
   representation of values are eluded by giving it a formal name and
   the most neutral possible (classicly, <code>t</code>). For
   example:
   <pre class="prettyprint ml">
   module Complex = struct
     type t
     ...
   end;;
   </pre>
   In contrast to the "homogenous" naming technique, an attempt is
   made here to diminish the distinctions between the datatype and the
   representation of values altering the role of the latter. The full
   name of the type in effect becomes <code>Complex.t</code>.
   </li>
   </ul>
   </li>
   </ul> 
   The tactic of algebraic naming permits expression a distinction
   between a datatype and the containing signature : the instances of
   the signature can in themselves form a characteristic group. For
   example:
   <pre class="prettyprint ml">
   module type METRIC_SPACE = sig
     type point
     ...
   end;;

   module Plane : METRIC_SPACE = struct
     type point = ...
     ...
   end;;
   </pre>
   Here <code>Plane</code> is a particular instance of a metric space,
   that is to say <code>METRIC_SPACE</code>.
   <br/>
   <br/>
   The same tactic can be applied to complex numbers but it requires a
   generalization of the signature. It is sufficient in doing this to
   recognize that complex numbers are only one instance of a structure
   that makes it possible to "make calculations under favorable
   conditions". For example:
   <pre class="prettyprint ml">
   module type ARITH = sig
     type nb                       type extern_nb
     val make : extern_nb -> nb    val show : nb -> extern_nb
     val zero : nb                 val one : nb
     val add : nb -> nb -> nb      val sub : nb -> nb -> nb
     val mul : nb -> nb -> nb      val div :  nb -> nb -> nb
   end;;
   </pre>
   The type of complex numbers can then become an instance of that
   signature:
   <pre class="prettyprint ml">
   module Complex : ARITH = struct
     type nb = ...
     ...
   end;;
   </pre>
   </p>
   <p>
   Let us compare these naming tactics. The tactic of "homogenous"
   naming permits economic generality while making declarations
   explicit within a signature. For example:
   <pre class="prettyprint ml">
   val add : complex -> complex -> complex
   </pre>
   This tactic generates redundancies however since the name of the
   complete type is <code>Complex.complex</code>. On the other hand,
   it hinders the generalization of a signature since a particular
   name is associated with the representation of values. For example,
   a generalized signature such as <code>ARITH</code> must not display
   a name such as <code>complex</code>. In contrast, the "strong
   algebraic" naming tactic remedies the redundancies and does not
   interfere with the generalization of a signature. Additionally,
   this tactic favors compatibility between signatures when for
   example, the representation of values is systematically named
   "t". Nevertheless, this induces a loss of precision. For example,
   in the case of complex numbers, the function for addition is
   specified as :
   <pre class="prettyprint ml">
   val add : t -> t -> t
   </pre>
   This imprecision can become annoying when number modules interact
   with each other or when representation of values utilizes multiple
   distinct types. It also sometimes reduces the possibility of
   pooling types. Finally, the "weak algebraic" tactic proposes to
   make a more explicit distinction between names. This also engenders
   some imprecision but reduces the barriers to compatibility between
   signatures.
   </p>
   <p>
   No naming tactic is therefore perfect. As a compromise, the "weakly
   algebraic" tactic is used in practice. This for example, is applied
   to many types in the standard OCaml library. We will see further on
   that there exists a technique to rename the elements of a module in
   fairly good conditions.
   </p>

   <h5>Universal type parameters and abstract types</h5>
   <p>
   It is neccessary to be careful of the level of generiticity which
   is explained in a signature. Consider for example the case of a
   function <code>f</code> specified in a signature and whose
   type <code>T</code> makes use of type
   parameters <code>&alpha;</code>, <code>&beta;</code> etc. The
   implementation of <code>f</code> must be compatible
   with <code>T</code>, at least as generic as imposed
   by <code>T</code>. Experience shows that this evidence is not so
   easy to apprehend.
   </p>
   <p>
   Here for example is a signature which might seem to specify in a
   very general manner types for ordered sets:
   <pre class="prettyprint ml">
   module type ORDER_GEN = sig
     val less_or_equal : 'a -> 'a -> bool
   end;;
   </pre>
   The signature requires production of an implementation
   of <code>less_or_equal</code> that is completely generic. Any
   function whose implementation is more specific would not
   satisfy. Let us recall that only the predefined predicates are able
   to offer such generiticity. The signature that specifies ordered
   sets is therefore rather of the form:
   <pre class="prettyprint ml">
   module type ORDER = sig
     type t
     type extern_t
     val make : extern_t -> t
     val show : t -> extern_t
     val less_or_equal : t -> t -> bool
   end;;
   </pre>
   In this signature, the indicated implementation
   of <code>less_or_equal</code> is dependant on the instantiation of
   the abstract type <code>t</code>. The specification possesses a
   certain level of generiticity as in <code>ORDER_GEN</code> but only
   through the utilisation of the abstract type. The implementation
   here is not required to be totally generic and the
   function <code>less_or_equal</code> may exploit the characteristics
   of the concrete type <code>t</code>. Here is an example of ordered
   strings for the value of their interpretation in base 256 according
   to the ASCII code of their characters (for example, "ol"
   corresponds to the code \(cod () * 256^2 + cod (o) * 256^1 + cod
   (l) * 256^0\)). This implementation applies a memoization of the
   sum and illustrates a new case where hiding and specification are
   useful:
   <pre class="prettyprint ml">
   module String_ordered = struct
     type t = Str of string * Num.num option ref
     type extern_t = string

     let make s = Str (s, ref None)
     let show (S(s, _)) = s

     let ascii_value s =
       let value = ref (Num.Int 0) and len = (String.length s) - 1 in
       let basis = ref (Num.Int 1) in
       for i = len downto 0 do
         value := Num.add_num !value
               (Num.mult_num !basis (Num.Int (Char.code s.[i])));
         basis := Num.mult_num !basis (Num.Int 256)
       done;
       !value

     let less_or_equal s1 s2 =
       let extract_ascii_value (Str (s, c)) = match !c with
         | None -> let d = ascii_value s in c := Some d; d
         | Some d -> d
       in
       Num.le_num (extract_value s1) (extract_ascii_value s2)
   end;;
   </pre>
   There exist situations when the choice between type parameters and
   abstract types proves more delicate than the above especially when
   these two kinds of parameters combine. For example, consider the
   problem of specifying a datatype for a "production line". That is,
   processes that generate sequentially and on demand, random numbers,
   events of inputs/outputs, happiness of the day etc. Here is the
   first specification:
   <pre class="prettyprint ml">
   module type PRODUCTION_LINE_GEN = sig
     type 'a product_line
     val make : unit -> 'a product_line
     val read_fst : 'a product_line -> 'a
     ...
   end;;
   </pre>
   At first glance, nothing seems suspect in this signature that
   resembles those proposed for sequential containers. Nevertheless,
   it is observed that the constructor <code>make</code> must be
   generic even though it is rather to provide a production line of
   particular elements. Indeed, here is an example of a production
   line in the form of a stream that generates random binary sequences:
   <pre class="prettyprint ml">
   module Rand_bin = struct
     type 'a product_line = 'a stm
     let rec make () =
       Random.self_init ();
       stm_build (fun x -> (Random.int 2)) 0
     let read_fst s = stm_hd s
     ...
   end;;
   </pre>
   This module does not satisfy the
   signature <code>PRODUCTION_LINE_GEN</code> since its constructor is
   obviously not generic being of type:
   <pre class="prettyprint ml">
   val make : unit -> int stm
   </pre>
   The type is less general than specified. Nevertheless, as in the
   case of ordered types, we can replace the type variable with an
   abstract type:
   <pre class="prettyprint ml">
   module type PRODUCTION_LINE = sig
     type data
     type 'a product_line
     val make : unit -> data product_line
     val read_first : data product_line -> data
     ...
   end;;
   </pre>
   The <code>Rand_bin</code> module satisfies this signature:
   <pre class="prettyprint ml">
   module Rand_bin : PRODUCTION_LINE = struct
     type data = int
     type 'a product_line = 'a stm
     let rec make () =
       Random.self_init (); stm_build (fun x -> (Random.int 2)) 0
     let read_fst s = stm_hd s
     ...
   end;
   </pre>
   The signature <code>PRODUCTION_LINE</code> uses here an abstract
   type <code>&alpha; product_line</code> so as to be able to indicate
   a strict relationship between the proudction lines and the data
   they produce. Indeed, in this signature, the type is explicitly in
   the expression <code>data product_line</code>. Here is an
   alternative:
   <pre class="prettyprint ml">
   module type PRODUCTION_LINE' = sig
     type data
     type product_line
     val make : unit -> product_line
     val read_fst : product_line -> data
     ...
   end;;
   </pre>
   The link between <code>data</code> and <code>product_line</code> is
   more precise, and this gives it more latitude : the representation
   of data in the link to the product isn't necessarily the same as
   that seen from the outside. For example, here is a case where the
   definition of the type <code>product_line</code> permits modifiable
   data:
   <pre class="prettyprint ml">
   module Rand_bin : PRODUCTION_LINE' = sig
     type data = int
     type product_line = data ref stm
     ...
   end;;
   </pre>
   </p>
   <p>
   Thus, the elaboration of signatures gives the programmer choices to
   make between universal paramters and abstract types. These should
   in fact be considered as two kinds of parameters in the signatures:
   <br/>
   <br/>
   <b>Difference between type parameters in signatures: </b>
   <ul>
   <li><i>Universal type parameters</i> impose generic
   implementations. Their instantiation is performed automatically by
   the type system.
   <br/>
   <br/>
   </li>
   <li><i>Abstract types</i> do not impose generic
   implementations. Their instantiations are established explicitly
   case by case.
   </li>
   </ul>
   <br/> 
   <br/>
   This distinction makes it possible to specify the level of
   generiticity of programs in signatures. In this respect, the
   preceding examples the general technique following:
   <br/> 
   <br/>
   <b>Mastering the generiticity of a signature:</b> Suppose a
   universal type <code>&alpha;</code> in a signature imposes a
   generic implementation. This parameter is replaced or controlled by
   a new abstract type.
   <br/>
   <br/>
   We will talk again about this delicate point.
  </p>

   <h4>Module inclusion relationships</h4>

   <h5>The inclusion of modules in signatures</h5>
   <p>
   In OCaml, reuse of a module in a module is expressed directly by
   the inclusion of one module in the other. This operation is
   established by the construction syntax following:
   <br/>
   <br/>
   <pre class="prettyprint ml">
   include &lt;Module&gt;
   </pre>
   <br/>
   <br/>

   The elements of the module <code>&lt;Module&gt;</code> are then
   defined in their entirety in the including module. For example,
   consider the following module:
   <pre class="prettyprint ml">
   module Increm = struct
     let f x = x + 1
   end;;
   </pre>
   The module can be included in another:
   <pre class="prettyprint ml">
   module More_than_increm = struct
     include Increm
     let g x = f (x * 10)
   end;
   </pre>
   This is equivalent to the following module definition:
   <pre class="prettyprint ml">
   module More_than_increm = struct
     let f x = x + 1
     let g x = f (x * 10)
   end
   </pre>
   </p>
   <p>
   Signatures also can include others with the same construction:
   <br/>
   <br/>
   <pre class="prettyprint ml">
   include &lt;SIGNATURE&gt;
   </pre>
   <br/>
   <br/>
   As for modules, the elements of <code>&lt;SIGNATURE&gt;</code> are
   declared and defined as part of the signature that includes
   them. For example, consider the signature of the
   module <code>Increm</code> above:
   <pre class="prettyprint ml">
   module type S = sig
     val f : int -> int
   end;;
   </pre>
   The definition of the signature for the
   module <code>More_than_increm</code> can include the
   signatures <code>S</code>.
   <pre class="prettyprint ml">
   module MORE_THAN_S = sig
     include S
     val g : int -> int
   end;;
   </pre>
   This definition is equivalent to the signature:
   <pre class="prettyprint ml">
   module type MORE_THAN_S = sig
     val f : int -> int
     val g : int -> int
   end;;
   </pre>
   The modules defined previously can be typed against these
   signatures:
   <pre class="prettyprint ml">
   module M1 : S = Increm;;
   module M2 : MORE_THAN_S = More_than_increm;;
   </pre>
   <br/>
   <br/>
   <b>The interest in module inclusion : </b> Inclusion facilitates
   the resule of modules. Also, inclusion of modules can reflect the
   inclusion of signatures and in the same way, inclusions of
   signatures can be concretely realized by the inclusion of modules.
   <br/>
   <br/>
   On the other hand, it can be remarked that the version
   of <code>MORE_THAN_S</code> with inclusion expresses explicitly the
   link with the signature <code>S</code> which is not the case for
   the version without inclusion. In other words:
   <br/>
   <br/>
   <b>The interest in signature inclusion : </b> Inclusion facilitates
   resuse of signatures. Also, inclusion of signatures allows for the
   specification of links between reutilized modules.
   <br/>
   <br/>
   </p>

   <h5>Inclusion for inheritance</h5>
   <p>
   Inclusion offers a direct means to extend and specialize existing
   modules and signatures. For example, consder a new implementation
   of complex numbers:
   <pre class="prettyprint ml">
   module Complex = struct
     type complex = float * float
     let make (r, i) = (r, i)
     let add (r1, i1) (r2, i2) = make (r1 +. r2, i1 +. i2)
     let norm (r, i) = sqrt (r ** 2. + i ** 2.)
   end;
   </pre>
   The module can easily be extended by inclusion:
   <pre class="prettyprint ml">
   module Complex_ext = struct
     include Complex;
     let mul (r1, i1) (r2, i2) =
       (r1 *. r2 -. i1 *. i2, i1 *. r2 + i2 *. r1)
   end;;
   </pre>
   <br/>
   <br/>
   <b>Module inheritance is implemented by inclusion:</b> One includes
   globally a module in another module and then extends, specializes
   or adapts.  
   <br/>
   <br/>
   On the other hand, here is a possible signature of
   the <code>Complex</code> module:
   <pre class="prettyprint ml">
   module type COMPLEX = sig
    type complex
    val make : float * float -> complex
    val add : complex -> complex -> complex
    val norm : complex -> float
   end;;
   </pre>
   A signature for the module <code>Complex_ext</code> can be directly
   derived by inclusion:
   <pre class="prettyprint ml">
   module type COMPLEX_EXT = sig
     include COMPLEX
     val mul : complex -> complex -> comples
   end;;
   </pre>
   Observe that the signature <code>COMPLEX_EXT</code> is compatible
   with <code>COMPLEX</code>:
   <pre class="prettyprint ml">
   # module C1 : COMPLEX = Complex_ext ;;
   module C1 : COMPLEX

   # module C2 : COMPLEX_EXT = Complex _ext ;;
   module C2 : COMPLEX_EXT
   </pre>
   <br/>
   <br/>
   <b>The behavior of module inheritance by inclusion : </b> One
   includes a signature <code>S1</code> in another
   signature <code>S2</code> to extend, specialize or
   adapt. Additionally, <code>S2</code> is compatible
   with <code>S1</code> (assuming no reclarations).
   <br/>
   <br/>
   Evidently, in the context of information hiding, the extending
   module cannot change the access privilege of the modules it
   includes, it will use the constructors and accessors previously
   defined. So, for example, let us suppose there is a
   module <code>Complex</code> that satisfies the following signature:
   <pre class="prettyprint ml">
   module type COMPLEX_MASK = sig
     type complex
     val make : float * float -> complex
     val show : complex -> float * float
     ...
   end;;
   </pre>
   An extension can be written using the accessors <code>make</code>
   and <code>show</code>:
   <pre class="prettyprint ml">
   module Complex_ext = struct
     include Complex
     let mul z w =
      let (r1, i1) = show z and (r2, i2) = show w in
      make (r1 *. r2 -. i1 *. i2, i1 *.r2 +. i2 *. r1)
   end;;
   </pre>
   This example shows that we can begin to examine the question "the
   dimensions of extensibility of types" for the case of abstract
   types. In particular, inclusion makes it easy to extend functions
   associated with a type and in a module framework with rigourous
   information hiding. We will treat later the case of the extension
   of representation of values. For now, we comment that "functors"
   are able to make generic these extensions.
   </p>

   <h5>Inclusion for inheritance</h5>
   <p>
   Inclusion also allows us to adapt existing modules and signatures :
   one redefines, one renames, one sometimes transforms elements
   module elements as necessary to obtain the extension. For example,
   let us reconsider the signature <code>ARITH</code>:
   <pre class="prettyprint ml">
   module type ARITH = sig
     type nb                        type nb_extern
     val make : extern_nb -> nb     val show : nb -> nb_extern
     val zero : nb                  val one : nb
     val add : nb -> nb -> nb       val sub : nb -> nb -> nb
     val mul : nb -> nb -> nb       val div : nb -> nb -> nb
   end;;
   </pre>
   Certain modules of the OCaml standard library are not far off being
   instances of this signature. However, the modules make use of the
   naming tactic where the representation of values is denoted by
   the <code>t</code> (the "strong algebraic" tactic) and do not apply
   the same conventions with respect to information hiding. We can use
   inclusion to make it easy to remedy this situation. For example,
   consider the case of the module <code>Int64</code> of the standard
   library which implements a datatype associated with whole numbers
   modulo \(2^{64}\) (that is, numbers in the range \([-2^{63}, 2^{63}
   - 1]\)). Here is how to adapt it such that it satisfies
   the <code>ARITH</code> signature:
   <pre class="prettyprint ml">
   module Arith_Int64 : ARITH  type nb_extern = string = 
   struct
     include Int64
     type nb = Int64.t (*rename type*)
     type extern_nb = string
     let make = of_string (*alias*)
     let show = to_string
   end;;

   # Arith_Int64.make "1000000000000000000000";;
   - : Arith_Int64.nb = &lt;abstr&gt;
   </pre>
   Note that is quite possible to include modules and revise some of
   their definitions. Adaption by inclusion can also benefit
   redefinitions of values and functions. However, there is a limit to
   such redefinitions : if there are mutual uses between functions
   contained in the module, if if a redefinition is applied between
   one of them, there will be no automatic update of their
   relation. In other words, the redefinitions do not incorporate a
   "delayed link" mechanism. For example:
   <pre class="prettyprint ml">
   module M = struct
     let f x = x + 1000
     let g x = (f x) + 1
   end;

   module Modified_M = struct
     include M
     let f x = x
   end;;
   </pre>
   The redefinition of <code>f</code> does not affect the definition
   of <code>g</code>:
   <pre class="prettyprint ml">
   # Modified_M.f 0 ;;
   - : int = 0

   # Modified_m.g 0 ;;
   - : int = 1001
   </pre>
   In the module framework, the programmer is in charge of assuring
   the cohesion of elements from the point of view of any
   redefinition. On the other hand, redefinitions may induce errors
   when they are not delibrate. This situation is all the more likely
   when modules are large and inclusions numerous. Generally,
   inclusions imply a pooling of definitions which provides
   opportunities for incoherencies. The following section introduces
   another means of expressing importations of modules end signatures
   that is more constrained and structured.
   </p>

   <h4>Module containment relations</h4>

   <h5>Containment of modules</h5>

   <p>Modules may embed other modules. We call this containment of
   modules and <i>parent-module</i> the module which contains others
   and those contained modules <i>sub-modules</i> of the parent
   module. Recall the earlier example:
   <pre class="prettyprint ml">
   module Increm = struct
     let f x = x + 1
   end;;
   </pre>
   A new module emerges from a sub-module in the other:
   <pre class="prettyprint ml">
   module More_than_increm = struct
     module Sub = Increm
     let g x = Sub.f (x * 10)
   end;;
   </pre>
   Contrary to inclusion of modules, containment respects the
   partitioning of the modules. They do not put all the definitions at
   the same level and they therefore do not imply unqualified
   redefinitions.
   </p>

   <h5>Opening of modules</h5>

   <p>
   Containment of modules must be compared to another construction
   that acts equally within the framework of links between
   modules. Using contained modules implies indirections "pointer
   notation". Sometimes this constraint seems to excessively increase
   the verbosity of programs especially when module names are very
   explicit. So, the language provides the means to "open" a module so
   that the names of the elements are directly addressable. It
   suffices to make this happen with the following directive:
   <br/>
   <pre class="prettyprint ml">
   open &lt;Module&gt;
   </pre>
   <br/> The elements conainted in <code>&lt;Module&gt;</code> are
   then accessible at the level of the the occurence of
   the <code>open</code> directive. No indirections are required.
   </p>
   <p>For example, consider a new module <code>Increm</code> opened in
   another module.
   <pre class="prettyprint ml">
   module More_than_increm = struct
     open Increm
     let g x = f (x * 10)
   end;;
   </pre>
   This is equivalent to the module definition:
   <pre class="prettyprint ml">
   module More_than_increm = struct
     let g x = Increm.f (x * 10)
   end;;
   </pre>
   </p>
   <p>
   Contrary to inclusion and containment, opening of modules does not
   produce any new definitions : it operates only on the space of
   identifiers. However, suppose there is an <code>x</code> valid at
   the point of application of an open directive of a
   module <code>M</code>; if <code>x</code> is also the name of an
   element of <code>M</code>, the open implies an irreversible
   redefinition of <code>x</code>. Consequently, as for inclusion,
   opens may involve name complications delicate to organise.
   </p>
   <p>
   For example, the modules <code>List</code>, <code>Array</code>
   and <code>Stack</code> from the sandard library have in common a
   certain number of functions with the same names. In the module
   following, the opening of these three modules will define a
   function <code>last</code> that gives rise to a type error:
   <pre class="prettyprint ml">
   # module M = struct
       open List
       open Stack
       open Array
       let last lin = nth lin ((length lin) - 1)
     end;;
    Type error
   </pre>
   Indeed the function <code>nth</code> is provided by
   the <code>List</code> module, but the <code>length</code> function
   has come from the <code>Array</code> module to which is
   applied <code>last</code>. The suite of module opens is ordered
   differently than required for a correct version:
   <pre class="prettyprint ml">
   # module M = struct
       open Stack
       open Array
       open List
       let last lin = nth lin ((length lin) - 1)
     end;;
   </pre>
   <br/>
   <br/>
   <b>The technique of openings transformed into sub-modules:</b> Any
   opening of a sub-module <code>M</code> can be replaced by an
   explicit import of <code>M</code> as a sub-module.
   <br/>
   <br/>
   Note that there exists a derivative of this technique. If
   utilisation of a module can be restrained to a simple expression
   such as a function body, it is possible to consider a local module
   . For example:
   <pre class="prettyprint ml">
   module M = struct
     let last lin =
       let module L = List in
       L.nth lin ((L.length lin) - 1)
   end;;
   </pre>
   On the other hand, opening a module possesses another important
   inconvenience : they are not representable at the level of the
   specification. We have seen that this is the case for inclusions
   and will now discover it for nesting.
   </p>

   <h5>Embedding in signatures : abstract sub-modules</h5>


   <!-- ******************************************************* -->


   <h3>Generic modular programming : functors</h3>    

   <p>
   The preceding sections show why and how to decouple a program into
   seperate distinct components, how to partition components and how
   to specify them before implmentation. In particular, when we
   discussed the advisability of implementation hiding techniques, the
   main quality criteria being precision and shows, namely in the the
   situation of being able to modify and replace modules locally as
   related but autonomous elements. The subsitution principle is in
   effect the essential characteristic of organisation and module
   reuse. There remains at least one point to improve : the conditions
   that allow us to express and exploit this substitutivity. Generic
   programming allowing the full participation of modules.
   </p>
   <p>So, in these sections, first of all we introduce the notion of
   "functions of modules", that is, <i>functors</i>, which will be the
   principal tools of modular generiticity. We then present some
   conceptual models associated with their use. A thorough discussion
   will be provided about various types of signatures. Highlighting
   their features, we will find functors can be compiled
   independently, that they can posses more than one parameter, are
   typable by signatures of their own and they allow their arguments
   also to be functors. We will then discuss the advantages and
   inconveniences of generic modular programming based on
   functors. Finally, we introduce a graphical representation for
   functors and examples illustrating usage.
   </p>

   <h4>Functors</h4>

   <h5>The idea of "functions of modules"</h5>

   <p>
   We have seen that modules and signatures offer a simple means of
   adaption and extension. Recall the example based on the type of
   complex numbers with the following signature:
   <pre class="prettyprint ml">
   module type COMPLEX = sig
     type complex
     val make : float * float &rarr; complex
     val show : complex &rarr; float * float
     ...
   end;;
   </pre>
   So now supposing <code>Complex</code> is a module that satisfies
   the <code>COMPLEX</code> signature, an extension can easily be
   obtained by inclusion:
   <pre class="prettyprint ml">
   module Complex_ext = struct
     include Complex
     let mul z w =
       let (r1, i1) = show z and (r2, i2) = show w in
       make (r1 *. r2 -. i1 *.i2, i1 *. r2 +. i2 *. r1)
   end;;
   </pre>
   This extension is however specific to the
   module <code>Complex</code>. Yet it turns out it is structurally
   independent of the details of the implementation of the module :
   nothin in the body of the new function <code>mul</code> alludes to
   anything particularly specific to <code>Complex</code>. Consider
   the effect on a different implementation of <code>COMPLEX</code>,
   for example, <code>Complex_memo</code>. The extension follows:
   <pre class="prettyprint ml">
   module Complex_memo_ext = struct
     include Complex
     let mul z w =
       let (r1, i1) = show z and (r2, i2) = show w in
       make (r1 *. r2 -. i1 *.i2, i1 *. r2 +. i2 *. r1)
   end;;
   </pre>
   The substitution principle applies here, but is embodied by an
   explicit operation on the code : <code>Complex</code> is replaced
   by hand by the module <code>Complex_memo</code>. This situation is
   similarly in fact to not knowing the concept of function but only
   that of constants!
   </p>
   <p>
   So, very naturally, ML languages offer a construction related to
   that of functions that solves the problem:
   <pre class="prettyprint ml">
   module F (C : COMPLEX) = struct
     include C
     let mul z w =
       let (r1, i1) = show z and (r2, i2) = show w in
       make (r1 *. r2 -. i1 *.i2, i1 *. r2 +. i2 *. r1)
   end;;
   </pre>
   The operation <code>F</code> takes a module
   parameter <code>C</code> of type the
   signature <code>COMPLEX</code>. The application simply retunrs a
   module integration the argument transmitted as a parameter. So, for
   example, the two extensions of complex numbers discussed earlier
   can be obtained by direct applications of <code>F</code>:
   <pre class="prettyprint ml">
   # module Complex_ext = F (Complex);;

   # module Complex_memo_ext = F (Complex_memo);;
   </pre>
   </p>
   <p>
   This new kind of operation consititues a means to facilitate
   substituion of modules. It can express abstractions on modules
   through its parameters and therefore new forms of generalization
   and generiticity. We will develop and explain these ideas
   throughout the pages that follow.
   </p>

   <h5>Defining functors</h5>

   <p>
   A "function of modules", that is to say, a parameterized module, or
   more specifically a functor, permits the passing of modules as
   arguments to construct other modules on which they depend. The
   basic syntax of a functor in OCaml naturally resembles that of
   anonymous functions:
   <br/>
   <br/>
   <pre class="prettyprint ml">
   functor (&lt;Parameter&gt; : &lt;SIGNATURE&gt;) &rarr;
    struct
      type ...           exception ...
      let ...            module ...
      module type ...    open ...
      include ...        &lt;exp&gt;
      ...
    end
   </pre>
   <br/> <br/> In the above, it is indicated
   that <code>&lt;Parameter&gt;</code> necessarily
   satisfies <code>&lt;SIGNATURE&gt;</code>. As a functor computes a
   module, the body of the functor is enclosed the
   keywords <code>struct</code> and <code>end</code>. On the other
   hand, this construction does not itself define a value. We use a
   new module keyword to link to a name:
   <pre class="prettyprint ml">
   module &lt;Name&gt; = 
     functor (&lt;Parameter&gt; : &lt;SIGNATURE&gt;) &rarr;
      struct
        ...
      end
   </pre>
   Such a definition can be abbreviated as so:
   <br/>
   <br/>
   <pre class="prettyprint ml">
   module &lt;Name&gt; (&lt;Parameter&gt; : &lt;SIGNATURE&gt;) = struct
     ...
   end
   </pre>
   <br/> <br/> We obtain here a syntax similar to functions. The
   underlying rule of the definition of functors is given next:
   <br/>
   <br/>
   <b>Functor definition rule : </b> All the elements enclosed in
   the <code>struct-end</code> are compiled sequentially in the order
   they apppear. Each new binding may use the bindings that precede it
   and are strictly associated with the body of the functor. However,
   there are no evaluations. The overall result is bound to the
   identifier <code>&lt;Name&gt;</code>.  <br/> <br/> As for
   functions, evaluation of the body of the functor is effected on
   application and conforms to the rules of a simple module.
   </p>
   <p>Despite the similarities between functions and functors the
   following important difference should be noted:
   <br/>
   <br/>
   <b>The explicit typing of parameters is mandatory :</b> In
   constrast to functions, functors require explicit typing of their
   parameters.
   <br/>
   <br/> 
   In effect, the feature of type inference in ML languages does not
   extend to calculating the signatures of functor parameters (it is
   generally "undecidable").
   </p>

   <h5>Using functor parameters</h5>

   <p>
   The parameters of functors denote modules which are usually used in
   the body of the functor using indirection ("member-selection"
   notation). For example,
   <pre class="prettyprint ml">
   module type S = sig
    type t
    val f : t &rarr; t
   end;;

   module F (M : S) = struct
     type s = M.t  (*recover the type in [M]*)
     let pair x = (x, M.f x) (*apply the function [f] in [M]*)
   end;;
   </pre>
   The type <code>t</code> and the function <code>f</code> of the
   parameter <code>M</code> appear in the implementation of the body
   of the functor <code>F</code>. The parameters of a functor define a
   local environment but this time consisting of modules. The same
   rules of information hiding for simple values apply to the names of
   modules.
   </p>


   <h5>Functor application</h5>

   <p>
   The syntax of functor application is also similar to that of a
   function application, and the result must be bound to the name of a
   module:
   <br/>
   <br/>
   <pre class="prettyprint ml">
   module &lt;Name&gt; = &lt;Functor&gt; (&lt;Argument&gt);;
   </pre>
   <br/> <br/> where <code>&lt;Argument&gt</code> is a module
   statisifying the signature of the parameter
   of <code>&lt;Functor&gt;</code>. For example, here is an instance
   of the signature <code>S</code> of the preceding section:
   <pre class="prettyprint ml">
   module Increm = struct
     type t = int
     let f x = x + 1
   end;;
   </pre>
   It is then possible to apply the functor <code>F</code>:
   <pre class="prettyprint ml">
   # module M1 = F (Increm);;
   </pre>
   The use of the module <code>M1</code> is as usual:
   <pre class="prettyprint ml">
   # M1.pair 1;;
   - : Increm.t * Increm.t = (1, 2)

   # M1.pair 2;;
   - : Increm.t * Increm.t = (2, 3)
   </pre>

    Here are some precise illustrations of two points relating to the
    rule of definition and application of a functor:
    <ul>
    <li>
    <i>The evaluation of the elements of a functor takes place at the
    moment of application.</i>
    <br/>
    <br/>
    For example:
    <pre class="prettyprint ml">
    # module Div_zero (M : sig end) = struct
        print_endline "In division by zero"
        let x = 1 / 0
      end;;

    # module M1 = Div_zero (struct end);;
    In division by zero
    Exception : Division_by_zero
    </pre>
    <br/>
    <br/>
    </li>
    <li>
    <i>Each application of a functor produces a new distinct
    module.</i>
    <br/>
    <br/>
    In particular, if a functor produces modules with internal state,
    those states are distinct. For example:
    <pre class="prettyprint ml">
    module Count_state (M : sig end) = struct
      let count = ref 0
    end;;

    # module V1 = Count_state (struct end)
      module V2 = Count_state (struct end);;
    module V1 : sig val count : int ref end
    module V2 : sig val count : int ref end

    # incr V1.count;;
    - : int ref = { contents = 1}

    # V2.count ;;
    - : int ref = { contents = 0}
    </pre>
    </li>
    </ul>
   </p>

   <h5>Explicit typing of the results of functors</h5>

   <p>
   As functors are part of the operation of language types it is
   naturally possible to render explicitly the signature of their
   results. For this purpose, we use the same notation as for
   functions. Consider for example the following signature:
   <pre class="prettyprint ml">
   module type S_RESULT = sig
     type s
     val pair : s &rarr; s * s
   end;;
   </pre>
   We can then reconsider an earlier example and explicitly type the
   result fo the functor <code>F</code> in two different ways:
   <pre class="prettyprint ml">
   module F_explicit (M : S) : S_RESULT = struct
     type s = M.t
     let pair x = (x, M.f x)
   end;;

   module F_explicit (M : S) = (struct
     type s = M.t
     let pair x = (x, M.f x)
   end : S_RESULT);;
   </pre>
   Explicit typing induces information hiding of the elements
   contained in the body of the functor. The rules are the following
   and reflect directly those which apply to modules:
   <br/>
   <br/>
   <b>Rule (1) : the visibility of the result of a functor : </b> The
   result of a functor unless explicitly typed by a signature has
   public contents.
   <br/>
   <br/>
   <b>Rule (2) : the visibility of the result of a functor : </b> The
   result of a functor explicitly typed by a signature <code>S</code>
   has public contents limited to those defined in the definition
   of <code>S</code> (with the exception of abstract types).  
   <br/>
   <br/>
   We can verify the safe application of the
   functor <code>F_explicit</code> above:
   <pre class="prettyprint ml">
   module Increm = struct
     type t = int
     let f x = x + 1
   end;;

   # module M1 = F_explicit (Increm);;

   # M1.pair 1;;
             ^
   Error: This expression has type int but an expression was expected
         of type M1.s = F_explicit(Increm).s
   </pre>
   The abstract type <code>s</code> of <code>M1</code>
   (from <code>t</code> of <code>Increm</code>) has become private
   since the functor result is explicitly typed.
   </p>
   <p>
   </p>

   <hr/>
   <p>
     References:<br/>
     "Programmation fonctionnelle, g&#233;n&#233;rique et objet: une introduction avec le langage OCaml" -- Narbel P., 2005
   </p>
  </body>
</html>
