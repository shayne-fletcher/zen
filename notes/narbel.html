<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
          "http://www.w3.org/TR/html4/strict.dtd">
<html>
  <head>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
      extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js"],
      jax: ["input/TeX", "output/HTML-CSS"],
      tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      },
      "HTML-CSS": { availableFonts: ["TeX"] }
      });
    </script> 
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
    <title>Narbel</title>
  </head>
  <body>
    <h2>Generic programming via modules and functors</h2>

    <h3>Modular programming</h3>
    <p>
    The readability, development, finding of errors, testability,
    robustness and adaptability of a program depends mainly on the
    organization into its independent parts and hierarchies. Without
    the adoption of boundaries, the development of a program quickly
    proves difficult to manage and maintenance a burden. Additionally,
    a program often relies on parts that are more general than
    it. Distinuishing these parts permits reutilization of their use
    in other settings and aids in the realization of other
    programs. Structuring, hierarchization and partitioning are the
    essential ingredients of programs ambitious in size and life-time.
    </p>
    <p>
    The possibility of building environments protected from each other
    is already provided for in functional programming through the
    notion of closures. This sub-spacing favors indeed some of the
    properties mentioned above. Nevertheless, the functions are
    limited to values, the protection they impose uniform and not
    lending easily to certain adaptions or extensions. Similarly, type
    structures such as records are likely to generate sub-spaces of
    names used for encapsulation purposes. However, these subspaces
    are equally as limiting as function closures.
    </p>
    <p>
    It is natural therefore to offer a more general means of
    construction for encapsulation. We have already met and used this
    means in fact through OCaml libraries : modules. This new form of
    encapsulation will indeed:
    <ul>
      <li>
      Allow for the construction of sub-spaces of names that do not
      impose restrictions on the elements of the language : modules
      can contain values, the definition of types, exceptions, other
      modules, etc.
      </li>
      <li>
      Allow control of the visibility of each of the elements
      encapsulated.
      </li>
    </ul>
    </p>
    <p>
    Modules are certainly not an original construction of ML
    languages. They exist in most current programming
    languages. However, ML modules possess specifics on which the
    following sections will expand on fully : the type system includes
    them in their own right. Each module posses a unique type : it is
    an instance of this type and recognized as such by the type
    system. From this point of view, a module resembles a typed value
    such as an integer or a character string. The typing system can
    thus extend to the global properties of a program and intervene in
    the elaboration and validation of a software architecture.
    </p>

    <h4>Modules : A general encapsulator</h4>

    <h5>Defining modules</h5>
    <p>
    The syntax of a module in OCaml comes down to framing a series of
    definitions and expressions by the keywords <code>struct</code>
    and <code>end</code>. As earlier announced, there are few
    restrictions as to the nature of the entities that may be placed
    there:
    <pre class="prettyprint ml">
      struct
        type ...          exception ...
        let ...           module ...
        module type ...   open ...
        include ...       &lt;exp&gt;
        ...
      end
    </pre>
    The first three kinds of
    definitions, <code>type</code>, <code>exception</code>
    and <code>let</code> are familiar. The occurence
    of <code>&lt;exp&gt;</code> indicates a module can also contain
    any expression. We introduce the other key-words and extents in
    the following.
    </p>
    <p>
    The encapsulation mechanism above does not alone define a value,
    it is necessary to explicitly associate it with name. To do this
    one uses the <code>module</code> keyword and the chosen names must
    start with a capital letter:
    <pre class="prettyprint ml">
    module &lt;name&gt; = struct
      ...
    end
    </pre>
    </p>
    <p>
    <i>Rules of a module definition : All the elements enclosed by
    a <code>struct</code>-<code>end</code> are compiled and evaluated
    sequentially in the order they appear. Each new element can use
    the previously defined elements and is strictly associated with
    the module. The overall result is bound to the
    identifier <code>&lt;name&gt;</code></i>.
    </p>
    <p>
    For simple bindings, if the overall evaluation is interrupted due
    to the emergence of an exception due to the evaluation of an
    individual element, the module is not built.
    </p>
    <p>
    Here is the first example of a module:
    <pre class="prettyprint ml">
    module Math = struct

      let rec fact n =
        if n &lt;= 1 then 1 else n * fact (n - 1)

      let rec fib n =
        if n &lt;= 0 then 0
        else if n = 1 then 1
        else fib (n - 1) + fib (n - 2)

      let rec sum f n0 n =
        if n < n0 then 0
        else (f n) + (sum f n0 (n - 1))

    end
    </pre>
    So here we have assembled a collection of arithmetic functions
    into a module of name <code>Math</code>.
    </p>

    <h5>Accessing module elements</h5>
    <p>
    By default, the elements of a module are accessible from its
    exterior. As observed in using the standard libraries, the access
    to these items is through indirection using a "member selection
    notation": <i>&lt;Module&gt.&lt;element&gt</i>. So, with the
    module <code>Math</code> of the preceding section:
    <pre>
    # Math.fact 5;;
    - : int = 120

    # Math.fib 6;;
    - : int  = 8 

    # Math.sum (fun n &rarr; n) 0 4;;
    - : int = 10

    # Math.sum (fun n &rarr; Math.fact n) 1 4;;
    - : int = 33
    </pre>
    </p>

    <h5>The modular form of data-types</h5>
    <p>
    Modules used to organize sets of definitions of functions can also
    include definitions of types and thus can serve as a means of
    encapsulation of data-types. That is to say, it is possible then
    to collect in a module the definition of a type and the functions
    that are associated with that type.
    </p>
    <p>
    Here is an example based on complex numbers:
    <pre class="prettyprint ml">
    module Complex = struct

      type complex = {re : float; im : float}

      let make (r, i) = {re = r; im = i}
      let add z w = {re = z.re +. w.re; im = z.im +. w.im}
      let norm z = sqrt (z.re ** 2. +. z.im ** 2.)

    end
    </pre>
    The representation of values is achieved by the use of a record
    type <code>{re : float; im : float}</code>. All the elements of
    this module are public and can be used directly:
    <pre class="prettyprint ml">
    # let z1 = Complex.make (4., 3.);;
    val z1 : Complex.complex = {Complex.re = 4.; Complex.im = 3.}

    # Complex.add z1 z1;;
    - : Complex.complex = {Complex.re = 8.; Complex.im = 6.}

    # Complex.norm z1;;
    - : float = 5.

    # z1.Complex.re;;
    - : float = 4.
    </pre>
    Note that these complex numbers are instances of the
    data-type <code>complex</code>. These instances are dependent on
    the the functions contained in the module, that is to
    say, <code>add</code> and <code>norm</code>. The encapsulation of
    a data-type in a module is indeed often characterized by such a
    centralized organisation. By contrast, we can compare this case
    with that record types, that is here, each instance contains both
    values and functions. We will discuss this important point of
    comparison later.
    </p>
    <p>
    Here are some more examples of data-types in modular form. First,
    let us consider a type that represents points in a plane
    associated with the usual Euclidean distance.
    <pre class="prettyprint ml">
    module Plane = struct
      type point = P of float * float

      let make_point (x, y) = P (x, y)

      let dist (P (x1, y1), P (x2, y2)) =
        sqrt ((x1 -. x2) ** 2. +. (y1 -. y2.) ** 2.)
    end
    </pre>
    A difference of this example from the preceding is that here, the
    representation of values of <code>point</code> are as instances of
    a singlar sum type. The techniques of expressing types we already
    know apply equally well in the context of modules.
    </p>
    <p>
    Data structures (or containers) can also take a coherent form by
    means of modules. For example, here's how to gather the
    definitions associated with lists:
    <pre class="prettyprint ml">
    module L = struct
      type &alpha; lin = Empty | Cons of &alpha; * &alpha; lin

      let empty () = Empty

      let add x l = Cons (x, l)

      let rec mem x l = match l with
        | Empty &rarr; false
        | Cons (x, xs) &rarr; x = y || mem x xs

      let rec apend l1 l2 = match l1 with
        | Empty &rarr; l2
        | Cons (x, xs) &rarr; Cons (x, append xs l2)
    end;;

    # let l1 = L.add 3 (L.empty ())
    val l1 : int L.lin = L.Cons (3, L.Empty)

    # let l1 = L.add 4 l1;;
    val l1 : int L.lin= L.Cons (4, L.cons (3, L.Empty))

    # L.mem 42 l1;
    - : bool = false
    </pre>
    The type of the containers is naturally generic as the the
    representation of values of <code>&alpha; lin</code> is:
    <pre>
    # L.add 3.1415926 (L.Empty);;
    - : float L.lin = L.Cons (3.1415926, L.Empty)

    # L.add "colorisation des esprits" (L.empty ());;
    - : string L.lin = L.cons ("colorisation des esprits", L.Empty)
    </pre>
    In fact, most data types defined in the standard OCaml library are
    implemented using this technique.
    </p>

    <h5>Remarks on the rules of module definitions</h5>
    <p>
    It is useful to have a precise idea about the consequences of the
    rules of definitions associated with the construction of a
    module. These are some of the important points:
    <ul>
      <li>
      <i>The evaluation of elements in a module follow their
      individual evaluation rules</i>.
      <br/>
      <br/>
      Here is an example illustrating the case of functions:
      <pre class="prettyprint ml">
      # module M = struct
          let f () = 1 / 0
        end;;
      # M.f ();;
      Exception : Division_by_zero.
      </pre>
      It is only when <code>f</code> is applied that an exception is
      thrown. Constrast this with the case of the construction of a value:
      <pre class="prettyprint ml">
      # module M = struct
          let x = 1 / 0
        end;;
      Exception : Division_by_zero.
      # M.x ;;
      Unbound value M.x
      </pre>
      The evaluation of the body of a <code>let</code> occurs during
      the construction of the module. Similarly, simple expressions:
      <pre class="prettyprint ml">
      # module M = struct
          print_endline "Inside M"
          let f x = x + 1
        end;;
      Inside M
 
      #M.f;;
      - : int &rarr; int
      </pre>
      The printing of the character string is effected during the
      construction of <code>M</code>. In the case where such
      expressions are followed, it is neccessary to use
      seperators. One can make use of double semi-colons:
      <pre class="prettyprint ml">
      # module M = struct
          print_endline "in M" ;;
          print_endline "yes, in M";;
          let f x = x + 1
        end;;
      </pre>
      However, the tradition in OCaml requires rather that we stick.
      with <code>let</code> bindings. Evaluations that only occur
      during the construction of a module are really only useful in
      edge cases (the construction of a module generates a
      module). Therefore, the type of these expressions is
      necessarily <code>unit</code> and the following form is also
      possible:
      <pre class="prettyprint ml">
      # module M = struct
          let () = print_endline "in M"
          let () = print_endline "yes, M"
          let f x = x + 1
      </pre>
      What we've written here are artifical <code>let</code>
      constructions by way of pattern matching on a unique instances
      of type <code>unit</code>. Thus the form <code>let () =
      ...</code> in a module invariably indicates an expression that
      will be evaluated during the construction of the module.
      <br/>
      <br/>
      </li>
      <li>
      <i>Dependence on the placement of elements in a module</i>
      <br/>
      <br/> The evaluation of a module is sequential. A definition in
      a module may not utilize a definition that follows it:
      <pre class="prettyprint ml">
      # module M = struct
          let f x = (g x) + 1
          let g x = x + 2
        end;;
      Unbound value g
      </pre>
      In the case you wanted to override this rule, it is necessary to
      make use of a <code>let rec</code> construction and define
      mutally recursive functions:
      <pre class="prettyprint ml">
      # module M = struct
          let rec f x = (g x) + 1
          and g x = x + 2
        end;;
      </pre>
      <br/>
      <br/>
     </li>
     <li>
       <i>Internal module state</i>
       <br/>
       <br/>
       It is possible to define modifiable variables in a module. Such
       variables constitute internal state. Reconsider the earlier
       example of points in the plane. We can provide a way to measure
       the extent of their establishment through such internal state
       wich will be denoted here as <code>count</code>:
       <pre class="prettyprint ml">
         module Plane_count = struct
           type point = {number : int; coord : float * float}

           let count = ref 0 (*Initialization*)

           let make_point (x, y) =
             incr count; {number = !count; coord = (x, y)}

           let dist p1 p2 =
             let (x1, y1) = p1.coord and (x2, y2) = p2.coord in 
               sqrt ((x1 -. x2) ** 2. +. (y1 -. y2.) ** 2.)
         end;;
       </pre>
       For example:
       <pre class="prettyprint ml">
       # Plane_count.make (0., 0.);;
       - : Plane_count.point = {Plane_count.number = 1;
                                Plane_count.coord = (0., 0.)}
       # Plane_count.make (1., 1.);;
       - : Plane_count.point = {Plane_count.number = 2;
                                Plane_count.coord = (1., 1.)}
       </pre>
       <br/>
       <br/>
     </li>
     <li>
       <i>Multiple definitions and redefinitions of elements in a
       module</i> <br/> <br/> If an association is defined multiple
       times in a module, it is only the last definition that will be
       taken into account. The sequential evaluation of elements in a
       module imply behaviors consistent with similar evaluations in
       the global environment. For example:
       <pre class="prettyprint ml">
       module M = struct
         let number = 1
         let number = 2.1
         let number = "three"
       end;;

       # M.number;;
       - : string = "three"
       </pre>
     </li>
    </ul>
    </p>

    <h5>Local modules</h5>
    <p>
    In OCaml, modules can emerge in local environments defined by way
    of a new <code>let</code> construction:
    <pre class="prettyprint ml">
    let module &lt;name&gt; = struct ... end in &lt;exp&gt;
    </pre>
    where the name of the module is usable in the
    expression <code>&lt;exp&gt;</code>. One of the main interest of
    local modules is to remedy the limitations of environments defined
    by <code>let</code>-<code>in</code> that can not in fact, include
    certain entities. On the contrary, local modules are not subjected
    to these restrictions. They allow, among other things, to
    associate types or exceptions to an expression. For example, we
    observe that sum types can clarify code. As such, they can
    sometimes be considered as a localized and specific aid. Consider
    this example in polynomials of degree 2:
    <pre class="prettyprint ml">
    # let poly2 a b c =
        let module O = struct
          type order = Less | Equal | Greater
          let less_or_equal x y =
            if x < y then Less else
            if x = y then Equal 
            else Greater
           end in
           match (O.less_or_equal ...) with
             | O.Equal &rarr; ...
             | O.Greater &rarr; ...
             | O.Less &rarr; ...;;
     val poly2 : float &rarr; float &rarr; float &rarr; solution
    </pre>
    The type <code>order</code> resides privately and solely in the
    function <code>poly2</code>. We will see other uses of local
    modules.
    </p>

   <h4>Signatures : the type of modules</h4>

   <h5>Inferred signatures</h5>
   <p>
   The behavior of modules in OCaml is similar to that of values in
   many ways. In paricular, each module possesses a type that is
   integrated with and used by the type-system. The type of a module
   can be computed by inference from the module's definition. As
   stressed in the introduction, this is one of the specifics of ML
   languages. However, the somewhat different nature of these types
   justifies distinguishing them from others. The types of modules are
   called <i>signatures</i>.  <br/> <br/> <b>Property (1) of signatures</b> :
   A signature can be inferred from the definition of a module.  <br/>
   <br/> For example, recall the module corresponding to the
   implementation of a type for complex numbers. The resulting
   signature obtained by type inference follows:
   <pre class="prettyprint">
   module Complex :
     sig
       type complex = {re : float; im : float}
       val make : float * float &rarr; complex
       val add : complex &rarr; complex &rarr; complex
       val norm : complex &rarr; float
     end
   </pre>
   A signature is essentially a summary of all the elements of the
   module to which it corresponds.
   </p>

   <h5>Defining signatures</h5>
   <p>
   As is the case for types of values, it is possible to define
   signatures independently of modules. A signature then consists of a
   simple suite of definitions and declarations enclosed in the
   keywords <code>sig</code> and <code>end</code>:
   <pre class="prettyprint ml">
   sig
     val ...             type ...
     exception ...       module ...
     module type ...     open ...
     include ...         ...
   end
   </pre>
   Note that the identifiers must be delcared with the
   keyword <code>val</code> (rather than <code>let</code>). For
   example:
   <pre class="prettyprint ml">
   val x : char
   val f : int &rarr; float
   val g : &alpha; &rarr; int
   </pre>
   As for modules, it is neccessary to link a signature to a name
   using the keywords <code>module type</code>:
   <pre class="prettyprint ml">
   module type &lt;NAME&gt; = sig
       ...
   end
   </pre>
   There are no syntactic constraints regarding the names of of module
   types with respect to enforcing uppercase or lowercase
   characters. However, to distinguish the names of signatures from
   other identifiers, a convention adopted in the ML literature is to
   spell them entirely in capital letters. Here are some definitions
   of signatures corresponding to the modules presented in early
   sections. For example, here is the signature for <code>Math</code>:
   <pre class="prettyprint ml">
   module type MATH = sig
    val fact : int &rarr; int
    val fib : int &rarr; int
    val sum : (int &rarr; int) &rarr; int &rarr; int &rarr; int
   end
   </pre>
   And here are the signatures of the modules <code>Complex</code>
   and <code>Plane</code> respectively and, the module <code>L</code>
   associated with lists.
   <pre class="prettyprint ml">
   module type COMPLEX = sig
     type complex
     val make : float * float &rarr; complex
     val add : complex &rarr; complex &rarr; complex
     val norm : complex &rarr; float
   end;;

   module type METRIC_SPACE_2D = sig
     type point
     val make_point : float * float &rarr; point
     val dist : point &rarr; point &rarr; float
   end;;

   module type LINEAR_CONTAINER = sig
     type &alpha; lin
     val empty : unit &rarr; &alpha; lin
     val add : &alpha; &rarr; &alpha; lin &rarr; &alpha; lin
     val mem : &alpha; &rarr; &alpha; lin &rarr; bool
     val append : &alpha; lin &rarr; &alpha; lin &rarr; &alpha; lin
   end;;
   </pre>
   The examples illustrate the following important point:
   <br/>
   <br/>
   <b>The fundamental interest of signatures :</b> They express certain
   characteristics of modules without including any implmentation.
   <br/>
   <br/>
   </p>

   <h5>Abstract types</h5>
   <p>
   The signatures of the last section have show that it is possible to
   use the keyword <code>type</code> without necessarily associating
   it with an explicit definition. We saw there for example:
   <pre class="prettyprint ml">
     type complex
     type point
     type &alpha; lin
   </pre>
    That is, it can be limited to the names of types declared in
    signatures:
    <br/>
    <br/>
    <b>Definition:</b> In a signature, a simple declaration of a name
    of a type is called an abstract type.  <br/> <br/> This name is
    justified because these types allow for an abstraction of the
    existence of particular types. To be precise:
    <br/>
    <br/>
    <b>The interest of abstract types and the coherence of a
    signature:</b> The abstract types of a signature <code>S</code>
    declare the names of types which are usable for the types of other
    elements in <code>S</code>. They thus impose a global coherence to
    typing other elements of the signature <code>S</code>, and this
    without being dependent on the definitions of these types.<br/>
    <br/> <br/> Moreover, when the parameters are abstract types, this
    makes possible expressions of typing patterns. For example, in the
    signature <code>LINEAR_CONTAINER</code>, there were the following
    generic declarations:
    <pre class="prettyprint ml">
    type &alpha; lin
    val add : &alpha; &rarr; &alpha; lin &rarr; &alpha; lin
    val mem : &alpha; &rarr; &alpha; lin &rarr; bool
    </pre>
    So, for example, the type <code>&alpha; &rarr; &alpha; lin &rarr;
    &alpha; lin</code> describes a generic operation of adding an
    element of type <code>&alpha;</code> to an <code>&alpha;
    lin</code> containing other items of the same type. In the
    implementation, the typing consistency will be ensured.
   </p>

   <h5>Elements implemented in signatures</h5>
   <p>
   Even if the main part of a signature is constituted merely of
   simple declarations, some of the elements can be implemented. It is
   possible to define exceptions:
   <pre>
   module type S = sig
     exception No
     exception Out_of_bounds of float
     ...
   end
   </pre>
   On the other hand, types can also be defined in a signature. For
   example, the signature <code>COMPLEX</code> includes the definition
   of a record type:
   <pre class="prettyprint ml">
   module COMPLEX = sig
     type complex = {re : float; im : float}
     ...
   end
   </pre>
   Such types are called "concrete types" (or "manifest types")
   distinguishing them from abstract types.
   </p>

   <h5>Signatures for explicitly typing modules</h5>
   <p>
   Signature definitions only make sense if they can be linked to
   modules. As for simple values, it is possible to explicitly ascribe
   a signature to a module. The syntax is similar:
   <pre class="prettyprint">
     module &lt;NAME&gt; : &lt;SIGNATURE&gt; = struct
       ...
     end
   </pre>
   The first application of this is to add explicit typing information
   to the definition of a module. Type inference can put this into
   correspondence with its own calculation. We can therefore check by
   inference that a module corresponds to its signing. For example, if
   we use the module <code>L</code> associated with lists we can
   explicitly type it to the signature <code>LINEAR_CONTAINER</code>.
   <pre class="prettyprint ml">
   # module L : LINEAR_CONTAINER = struct
       type &alpha; lin = Empty | Cons of &alpha; * &alpha; lin
       let empty () = Empty
       let add x l = ...
       let rec mem x l = ...
       let rec append l1 l2 = ...
     end;;
   module L : LINEAR_CONTAINER
   </pre>
   Here we get a terse response from the type system indicating
   acceptance that <code>L</code> can be typed as
   a <code>LINEAR_CONTAINER</code>. In contrast, an invalid explicit
   typing not sanctioned by inference will be documented as a type
   error. For example, consider a situation where a module does not
   implement all the elements of the
   signature <code>LINEAR_CONTAINER</code>:
   <pre class="prettyprint ml">
   # module L : LINEAR_CONTAINER = struct
       type &alpha; lin = Empty | Cons of &alpha; * &alpha; lin
       let add x l = Cons (x, l)
     end;;
   The field &alpha;ppend' is required but not provided
   The field 'mem' is required but not provided
   The field 'empty' is required but not provided
   </pre>
   The main rule of explicit typing with signatures follows:
   <br/>
   <br/>
   <b>Rule of explicit typing by signature:</b> The explicit typing of
   a module <code>M</code> to a signature <code>S</code> is valid only
   if the elements defined and declared in <code>S</code> are
   implemented in <code>M</code> (with exactly the same names). The
   elements of <code>M</code> must be equal, consistent with or more
   general than those indicated in <code>S</code>.
   <br/>
   <br/>
   Here are some examples to help explain the rules:
   <ul>
   <li><i>Independence from the order of definitions.</i>
   <br/>
   <br/>
   The order of appearance of the elements of the module is not
   important as long as its type corresponds with the signature.
   <br/>
   <br/>
   </li>
   <li>
   <i>The effect of explicitly typing on individual elements.</i>
   <br/>
   <br/>
   Signing by explicit typing acts to explicitly type each individual
   element of the module. For example:
   <pre class="prettyprint ml">
   module type S = sig
     val fst : int * float &rarr; int
   end;;

   module M : S = struct
     let fst (x, y) = x
   end;;

   #M.fst ;;
   - : int * float &rarr; int
   </pre>
   Here the function <code>fst</code> given by the explicit typing to
   the signature <code>S</code> is equivalent to:
   <pre class="prettyprint ml">
     let fst ((x, y) : int * float) : int = x;;
   </pre>
   An occassional error is to implement an element of a module that is
   less general than its declaration. For example:
   <pre class="prettyprint ml">
   module type S = sig
     val f : &alpha; &rarr; &alpha;
   end;;

   module M : S = struct
     let f x = x + 1
   end;;
   </pre>
   The above is an error. This point will later be discussed in more
   detail.  
   <br/>
   <br/>
   </li>
   <li>
   <i>Parameteric abstract types</i>
   <br/>
   <br/>
   An implementation of an abstract type can make use of
   type variable parameters. For example:
   <pre class="prettyprint ml">
   module type S = sig
     type (&alpha;, &beta; &gamma;) t
   end;;

   module M : S = struct
     type (&alpha;, &beta; &gamma;) t = int
   end;;
   </pre>
   One can restrict the generiticity of a type paramter of an abstract
   type. The inverse is not possible:
   <pre class="prettyprint ml">
   # type t = &alpha; list;;
   Unbound type parameter &alpha;
   </pre>
   <br/>
   </li>
   <li>
   <i>Globale coherence of the type of a module</i>
   <br/>
   <br/>
   Using abstract types in a signature permits expressing the overall
   typing coherence between the elements of a signature. For example,
   reconsider the module <code>Plane</code>:
   <pre class="prettyprint ml">
   module Plane = struct
     type point = P of float * float

     let make_point (x, y) = P (x, y)

     let dist (P (x1, y1)) (P (x2, y2)) =
       sqrt ((x1 -. x2) ** 2. +. (y1 -. y2) ** 2.)
   end;;
   </pre>
   The inferred signature is:
   <pre class="prettyprint ml">
   module Plane : sig
     type point = P of float * float
     val make_point : float * float &rarr; point
     val dist : point &rarr; point &rarr; float
   end
   </pre>
   The use of the simple inductive type permits the use of the
   type <class>point</class> in the type of the
   functions <code>make</code> and <code>dist</code>. But here,
   another version of the module uses a type abbreviation:
   <pre class="prettyprint ml">
   module Plane = struct
     type point = float * float

     let make_point (x, y) = (x, y)

     let dist (x1, y1) (x2, y2) = 
       sqrt ((x1 -. x2) ** 2. +. (y1 -. y2) ** 2.)
   end;;
   </pre>
   The inferred signature follows:
   <pre class="prettyprint ml">
   module Plane : sig
     type point = float * float
     val make_point : &alpha; * &beta; &rarr; &alpha; * &beta;
     val dist : float * float &rarr; float * float &rarr; float
   end
   </pre>
   The type <code>point</code> here is a priori without manifest
   utility and the associated functions don't use it (the type
   inference possesses no evidence to connect them with the
   type <code>point</code>). Explicit typing with a signature remedies
   the situation. Indeed, reconsider signing with:
   <pre class="prettyprint ml">
   module type METRIC_SPACE_2D = sig
     type point
     val make_point : float * float &rarr; point
     val dist : point &rarr; point &rarr; float
   end;;
   </pre>
   Then,
   <pre class="prettyprint ml">
   # module Plane : METRIC_SPACE_2D = struct

       type point = float * float

       let make_point (x, y) = (x, y)

       let dist (x1, y1) (x2, y2) = 
         sqrt ((x1 -. x2) ** 2. +. (y1 -. y2) ** 2.)
     end;;
   module Plane : METRIC_SPACE_2D

   # Plane.make_point;;
   - : float * float &rarr; Plane.point

   # Plane.dist;;
   - : Plane.point * Plane.point &rarr; float
   </pre>
   The types of the functions here became specific. The explicit
   typing by signature has had a structuring effect on the collection
   of the types of the elements of the module.
   <br/>
   <br/>
   </li>
   <li>
   <i>Concrete types and exceptions</i> 
   <br/>
   <br/>
   If a signature <code>S</code> contains concrete types of
   exceptions, the modules that implment it must necessarily contain
   the same definitions. For example:
   <pre class="prettyprint ml">
   module type S = sig
     exception Bad of int
     type &alpha; inverse = Full | Empty of &alpha;
   end;;

   module M : S = struct
     exception Bad of int
     type &alpha; inverse = Full | Empty of &alpha;
   end;;
   </pre>
   </li>
   </ul>
   </p>

   <h5>The instantiation relationship between modules and signatures</h5>
   <p>
   A signature may be inferred by the type system for a particular
   module. On the other hand, a module may correspond with a signature
   by explicit typing. It is then said that the module
   implementation <i>satisfies</i> that signature. To stick to that
   though would be to forget an important and original characteristic
   of the module system:
   <br/>
   <br/>
   <b>Property (2) of signatures:</b> The same signature may be
   implemented by multiple distinct modules.
   <br/>
   <br/>
   To highlight the similarity of modules with simply typed values, we
   can extend the meaning of the word "instance".
   <br/>
   <br/>
   <b>Definition:</b> A module that implements (or satisfies) a
   signature, we say is an <i>instance</i>.  <br/> <br/> For example,
   consider a new signature that describes a two-dimensional space
   equipped with a distance metric:
   <pre class="prettyprint ml">
   module type METRIC_SPACE_2D = sig
     type point
     val make_point : float * float &rarr; point
     val dist : point &rarr; point &rarr; float
   end;;
   </pre>
   It is possible to instantiate it in many different ways:
   <pre class="prettyprint">
   module Plane : METRIC_SPACE_2D = struct
    type point = float * float
    let make_point (x, y) = ...
    let dist (x1, y1) (x2, y2) = ...
   end;;

   module Plane_count : METRIC_SPACE_2D = struct
     type point = {number : int; coord : float * float }
     let make_point (x, y) = ...
     let dist p1 p2 = ...
   end;;

   module Manhattan_plane : METRIC_SPACE_2D = struct
    type point = float * float
    let make_point (x, y) = (x, y)
    let dist (x1, y1) (x2, y2) = 
      abs_float (x1 -. x2) +. abs_float (y1 -. y2)
   end;;
   </pre>
   With this, these three spaces can coexist in the same progam:
   <pre class="prettyprint ml">
   # Plane.dist;;
   - : Plane.point &rarr; Plane.point &rarr; float

   # Plane_count.dist;;
   - : Plane_count.point &rarr; Plane_count.point &rarr; float

   # Manhattan_plane.dist;;
   - : Manhattan_plane.point &rarr; Manhattan_plane.point &rarr; float
   </pre>
   </p>
   <p>
   Note that the two properties highlighted above - inference and
   multiple instantiation - are absent from most other
   languages. Multiple instantiation not only increases the reuse of
   signatures, but we will also see that it turns out to be natural in
   defining "functions of mouldes" whose parameters are the types of
   signatures.
   </p>

   <h4>Techniques for writing signatures</h4>

   <h5>Signatures as a means of specification and interface</h5>

   <p>If there is a singularity of ML relative to other languages
   (modules are instances of signatures), their basic use is very
   usual. Indeed, explicit typing of modules showcases signatures as a
   means of interface specification:
   <ul>
   <li><i>Formal description.</i> The prior elaboration of signatures
    admits the design of programs without having to face the practical
    problems of implementation: we focus on the organization of
    sub-spaces of names, on the relations, the constraints to be
    specified there. It is only in the second phase that we undertake
    implementation. The implmementation of a program is then based on
    the collection of pre-existing signatures.
    <br/>
    <br/>
   </li>
   <li><i>Transmission of documentation.</i> Signatures also lend
    themselves as a means of transmission of an abridged form of the
    possibilities their bodies offer the potential user.
   </li>
   These links between signatures and modules thus induce a method of
   production of programs that is measured and thoughtful. This method
   applied during program development takes a certain thoroughness.
   </ul>
   </p>

   <h5>The limitations of signatures as specifications</h5>

   <p>The signatures of ML provide a limited means of
   specification. Signatures can only include properties whose
   verification can be realized within the reach of the type
   system. For example, reconsider the
   signature <code>METRIC_SPACE_2D</code>. The
   declaration <code>dist</code> there is deemed to specify a function
   of distance. The declaration describes binary function acting on
   the <code>point</code> type and computing a number of
   type <code>float</code>:
   <ul>
     <li><i>Weakness in the implementation.</i> A programmer can not
     rely on the system to check the character of the distance
     function an implementation of <code>dist</code> will have
     produced.  <br/> <br/>
     </li>
     <li><i>Weakness of use.</i> A user of an instance of the
     signature <code>METRIC_SPACE_2D</code> can not be sure of the
     character of the distance function provided by <code>dist</code>.
     </li>
   </ul>
   For example, the module following satisfies the signature
   of <code>METRIC_SPACE_2D</code> but it's function <code>dist</code>
   is not a distance:
   <pre class="prettyprint ml">
   module Buggy_plane : METRIC_SPACE_2D = struct
     type point = float * float
     let make_point (x, y) = (x, y)
     let dist (x1, y1) (x2, y2) = x1 +. y1 +. x2 +. y2
   end
   </pre>
   As part of a complete description of a metric space , the axioms of
   the definition of a distance would be included:
   \[
   \begin{eqnarray}
   \forall x,y \in point,&\;\;&0 \le dist (x, y) \le \infty \nonumber \\
   \forall x,y \in point,&\;\;& dist(x, y) = 0 \iff x = y \nonumber \\
   \forall x,y \in point,&\;\;& dist(x, y) = dist(y, x) \nonumber \\
   \forall x,y \in point,&\;\;& dist(x, z) \le  dist(x, y) + dist (y, z)
   \end{eqnarray}
   \]
   Only their verification on <code>dist</code> would ensure the
   character of the distance function. That verification is quite out
   of reach of the type system. Languages that include such
   possibilities of specification require production of mathematical
   evidence adapted case by case. In the language of OCaml, we resort
   to verification of specific implementations via assertions and
   tests.
   </p>

   <h5>Mitigation of the limitations of specification via signatures</h5>

   <p>
   The simpliest and most traditional method of mitigating the
   limitations consists of associating signatures with documentation
   in the form of comments. The constraints, the properties, the
   behaviors of elements may be made more or less formal and
   precise. For example:
   <pre class="prettyprint ml">
   module type METRIC_SPACE_2D = sig
     type point
     val make_point : float * float &rarr; point
     val dist : point &rarr; point &rarr; float
     (*Satisifies the axioms of a distance function, can raise
      [Invalid_argument] *) 
   end
   </pre>
   This tactic can be applied generally and systematically during the
   elaboration of signatures. It is obviously understood to be a
   compromise since the type system can exert no control over them.
   </p>
   <p>
   We wil later see however that sometimes OCaml offers more effective
   means by nesting signatures in other modules or the use of
   functions of modules. Also, technically, a specification can
   combine the type system. For example, in the
   signature <code>MATH</code> we have:
   <pre class="prettyprint ml">
   val sum : (int &rarr; int) &rarr; int &rarr; int
   </pre>
   In this declaration, while it defines the form of the function, we
   are guessing the first parameter represents the operation that
   defines the sum. On the other hand, the declaration fails to
   describe the remaining two parameters. The use of comments would
   remedy this lack of precision but OCaml provides an extension which
   offers a solution which integrates better with this kind of problem
   : labeled parameters. We can use this feature in the signature to
   clarify the role of these parameters. For example:
   <pre class="prettyprint ml">
   val sum : f : (int &rarr; int) &rarr; start : int &rarr; goal : int &rarr; int
   </pre>
   Then, modules that satisfy the signature will have these types
   labeled providing coherence. For example:
   <pre class="prettyprint ml">
   let rec sum ~f ~start ~goal =
     if goal < start then 0
     else (f goal) + sum ~f:f ~start:start ~goal:(goal - 1)
   </pre>
   Any gaps in the naming of the parameters will be sanctioned by a
   type error. The labeling of parameters then permits an enriched
   signature in terms of documentation and is verifiable by the type
   system during instantiation.
   </p>

   <h5>The generalization of signatures</h5>

   <p>
   The existence of abstract types in signatures permits a new
   technique of generalistation. For example, consider once again the
   signature <code>MATH</code>:
   <pre class="prettyprint ml">
   module type MATH = sig
    val fact : int &rarr; int
    val fib : int &rarr; int
    val sum : (int &rarr; int) &rarr; int &rarr; int &rarr; int
   end
   </pre>
   This signature restricts the declarations to numbers of the
   type <code>int</code>. The specification sets here a representation
   that leads to a particular precision in implementations. We can
   replace the occurences of <code>int</code> with an abstract type:
   <pre class="prettyprint ml">
   module type MATH_GEN = sig
    type t
    val fact : t &rarr; t
    val fib : t &rarr; t
    val sum : (t &rarr; t) &rarr; t &rarr; t &rarr; t
   end
   </pre>
   We have obtained a generalization of the
   signature <code>MATH</code> over the the type <code>int</code>.
   <br/>
   <br/>
   <b>Principle of generalization of a signature :</b> Replace the
   specific type in the signature with an abstract type.
   <br/>
   <br/>
   </p>

   <h5>Signatures and the functional or imperative style</h5>

   <p>
   A signature can induce a programming style. In particular, those
   operations with the result type <code>unit</code> indicate an
   imperative program. For example, here is a variation on the
   specification of the type of linear containers:
   <pre class="prettyprint ml">
   module type LINEAR_CONTAINER_IMP = sig
     type &alpha; lin
     val empty : unit &rarr; &alpha; lin
     val mem : &alpha; &rarr; &alpha; lin &rarr; bool
     val add : &alpha; &rarr; &alpha; lin &rarr; unit (*procedure*)
     val append : &alpha; lin &rarr; &alpha; lin &rarr; unit (*procedure*)
     val length : &alpha; lin; &rarr; int
     val nth : &alpha; lin &rarr; int &rarr; &alpha;
   end
   </pre>
   The functions <code>add</code> and <code>append</code> here have
   return type <code>unit</code> which imposes the requirement of an
   implmentation necessarily of imperative character.
   </p>
   <p>
   On the other hand, the items specified by a signature may overall
   lead one to adopt an imperative rather than a functional style. For
   example, conser a new version of the preceding signature:
   <pre class="prettyprint ml">
   module type LINEAR_CONTAINER = sig
     type &alpha; lin
     val empty : unit &rarr; &alpha; lin
     val mem : &alpha; &rarr; &alpha; lin &rarr; bool
     val add : &alpha; &rarr; &alpha; lin &rarr; &alpha; lin (*function*)
     val append : &alpha; lin &rarr; &alpha; lin &rarr; &alpha; lin (*function*)
     val length : &alpha; lin; &rarr; int
     val nth : &alpha; lin &rarr; int &rarr; &alpha;
   end
   </pre>
   Apriori this signatures specifies an implementation of functional
   character because the functions <code>add</code>
   and <code>append</code> compute containers rather than a unit
   value. Suppose that we have at our disposal such a representation,
   and suppose we wished to obtain a function that runs through the
   elements of <code>&alpha; lin</code> instances. Here as the only
   access function is <code>nth</code>, which accesses the $n$-th
   element of an instance, it might be tempting to go the way of
   imperative loops adapted to the management of indices. Thus, a
   signature that specifies a data structure have functional character
   that lends itself to recursive decomposition, should also specify
   directly generalized processing functions like iterators or folds.
   </p>

   <h4>Public and private modules</h4>

   <p>
   The mechanisms of encapsulation induce rules about the visibility
   of elements in a structure. An element that is <i>public</i> (or
   'exported') is usable from outside of the encapsulation. An element
   that is <i>private</i> (or 'hidden') is not. So for example, the
   local bindings of a function are private while the fields of a
   record are public. Modules offer a mechanism more nuanced where it
   is possible to explicitly render individual elements public or
   private. This control of visibility allows us to apply techniques
   of information hiding and precise control of the links between
   modules.
   </p>

   <h4>Public and private modules</h4>

   <h5>Public</h5>

   <p>
   First of all, we have already exercised the following rule of visibility:
   <br/>
   <br/>
   <b>Rule (1) of the visibility of modules: </b> The contents of a
   module without an explicit signature are public.  <br/> <br/> For
   example, recall the implementation of a datatype for lists:
  <pre class="prettyprint ml">
   module L = struct 
     type &alpha;lpha lin = Empty | Cons of &alpha; * &alpha; lin
     let empty () = Empty
     let add x l = Cons (x, l)
   end 
  </pre>
   Without explicit signing,
   the module exposes all its contents. The representation of such
   values, <code>&alpha; lin</code> is therefore usable for direct use:
   <pre class="prettyprint ml">
   # L.empty ();;
   - : &alpha; L.lin - L.Emtpy

   # let l1 = L.add 3 (L.empty ());;
   val l1 : int L.lin = L.Cons (3, L.Empty)
   </pre>
   </p>

   <h5>Private</h5>

   <p>
   During the presentation of the rules of explicit typing via
   signatures we did not highlight an important point : the explicit
   typing of a module <code>M</code> by a signature <code>S</code>
   remains valid if at least all of the elements of <code>S</code> are
   defined in <code>M</code>. The rule that follows is the natural
   complement of the behavior of explicit typing since the signature
   acts as interfaces between modules:
   <br/>
   <br/>
   <b>Rule (2) of the visibility of modules: </b> The elements of a
   module <code>M</code> typed explicitly with a
   signature <code>S</code> are public only if they appear
   in <code>S</code> (except for abstract types). All other elements
   in <code>M</code> are private.
   <br/>
   <br/>
   For example, reconsider the
   module <code>Plane_count</code>. This one possesses the following
   signature:
   <pre class="prettyprint ml">
   module type METRIC_SPACE_2D_COUNT = sig
     type point
     val count : int ref
     val make_point : float * float &rarr; point
     val dist : point &rarr; point &rarr; float
   end
   </pre>
   The internal state <code>count</code> appears in the signature. In
   the original rendering of <code>METRIC_SPACE_2D</code> this
   variable was absent:
   <pre class="prettyprint ml">
   module Plane_count : METRIC_SPACE_2D = struct
     type point = {number : int; coord : float * float}
     let count = ref 0 (*Initialization*)
     let make_point (x, y) = incr count; {number = !count; coord = (x, y)}
     let dist p1 p2 = ...
   end;;

   # Plane_count.make_point ;;
   - : float * float &rarr; Plane_count.point

   # Plane_count.count ;;
   Unbound value Plane_count.count
   </pre>
   It is not possible to acces the variable denoted
   by <code>count</code>. Notice that the
   module <code>Plane_count</code> can be considered an instantiation
   of both signatures <code>METRIC_SPACE_2D</code>
   and <code>METRIC_SPACE_2D_COUNT</code>.
   </p>
   <p>Explicit typing implies which properties are important and
   underlies the independence of signatures relative to modules:
   <br/>
   <br/>
   <b>Property (3) of signatures:</b> The same module may instantiate
   multiple distinct signatures.
   </p>

   <h5>Compatibility of signatures</h5>

   <p>
   By what has been said in the previous section, we can now specify a
   reinterpration of the rules of explict typing by signature.
   <br/>
   <br/>
   <b>Compatibility between signatures : </b>
   Suppose <code>M<sub>1</sub></code> is a module satisfying the
   signature <code>S<sub>1</sub></code>; also, <code>M<sub>1</sub></code>
   also satisfies <code>S<sub>2</sub></code>. Then if:
   <ol>
   <li><code>S<sub>1</sub></code> includes <code>S<sub>2</sub></code>
   in terms of its set of elements.</li>
   <li>The types of the elements of <code>S<sub>1</sub></code> are
   respectively, equal to, compatible with or more general than those
   of <code>S<sub>2</sub></code>.</li>
   <li>Certain concrete types in <code>S<sub>1</sub></code> are
   abstract in <code>S<sub>2</sub></code>.</li>
   </ol>
   In this case we will say, the signature <code>S<sub>1</sub></code>
   is compatible with the signature <code>S<sub>2</sub></code>
   and <code>M<sub>1</sub></code> is an instance of both.
   <br/>
   <br/>
   So, the example of the preceding section, the
   signature <code>METRIC_SPACE_2D_COUNT</code> is compatible
   with <code>METRIC_SPACE_2D</code>. Note this definition is in
   general accord with the general definition of the compatibility of
   types. It can also be described as <i>structural</i> : it depends
   only on the form of the signatures, it does not need to be made
   explicit by the programmer.
   </p>

   <p>
   The compatibility between signatures must be associated with
   another possibility of modules which brings them closer to the
   usual behavior of values : a module may be bound to an arbitrary
   number of distinct identifiers. It is indeed possible to construct
   new bindings of modules to existing modules. For example:
   <pre class="prettyprint ml">
   # module P = Plane_count;;
   </pre>
   Here the module <code>P</code> is made to be a reference to the
   same implementation of the module <code>Plane_count</code>. It is
   similar to the effect to that which governs the definition of new
   bindings by <code>let</code> : a new copy of the
   module <code>Plane_count</code> is not produced (in this imperative
   example, the internal counter of the <code>Plane_count</code>
   points will be shared).
   </p>

   The construction of such module links can obviously be accompanied
   by explicit typing and under the umbrella of the notion of
   compatibility:
   <pre class="prettyprint ml">
   # module P1 : METRIC_SPACE_2D = Plane_count;;
   # module P2 : METRIC_SPACE_2D_COUNT = Plane_count;;
   </pre>
   or, in an equivalent manner:
   <pre class="prettyprint ml">
   # module P1 = (Plane_count : METRIC_SPACE_2D);;
   # module P2 = (Plane_count : METRIC_SPACE_2D_COUNT);;
   </pre>
   The explicit typing here authorises multiple visibilities of the
   same module : the module <code>P<sub>2</sub></code> exports all the
   elements of the <code>Plane_count</code> module whereas the
   module <code>P<sub>1</sub></code> just those elements that appear
   in the signature <code>METRIC_SPACE_2D</code>. Such multiple views
   can make sense in many situations. For example:
   <ul>
   <li><i>Distinguishing between error search phases.</i>  Elements
   are made public to be deprived but on which an error search applies
   (I have no idea what this means either)</li>
   <li><i>Distinguishing between access levels.</i> More or less of
   complete access is granted to the users of a module.</li>
   </ul>
   Note that this explicit typing via signatures can be phrased in
   terms of the classical type-transformation term of an "up-cast", a
   term which tenotes transformation of the the type of an element in
   the sense of a compatibility relation. A restriction on the "window
   of visibility" of a module by becoming the instance of a more
   general signature. The reverse, that is a type-transformation of
   the form of a "down-cast" is not allowed. There are in fact no more
   traces of the initial shape of a module after an up-cast. For
   example, if we now reconsider the previous example:
   <pre class="prettyprint ml">
   # module P1 : METRIC_SPACE_2D = Plane_count;;
   # module P2 : METRIC_SPACE_2D_COUNT = P1 ;;
   Signature error
   </pre>
   It is not possible to retrieve the initial module by an <i>a
   posteriori</i> retyping to its complete signature.
   </p>

   <h5>Public exceptions</h5>

   <p>
   In the context of explicit typing, the exporting of exceptions
   necessarily passes through their definition in the signature. For
   example:
   <pre class="prettyprint ml">
   module type FACT = sig
     exception Neg
     val fact : int &rarr; int
     (*Raises [Neg] if the given argument is negative*)
   end;;

   module E : FACT = struct
     exception Neg
     let rec fact n = ...
   end;;
   </pre>
   Conforming to the rules of explicit typing by signatures, an
   instantiation of the signature <code>FACT</code> includes
   necessarily the exception <code>Neg</code>. This double definition
   is a mark of exporting an exception and makes it usuable outside
   the module:
   <pre class="prettyprint ml">
   # E.Neg ;;
   - : exn = E.Neg
   </pre>
   The interest in exporting them of course is to make possible their
   processing from outside the module. Their appearence in the
   signature gives more opportunity to specify the character of the
   functions likely to use them. Their commentary can thus help
   prepare for the treatment of errors. Note however, some exceptions
   need not be exported. They can sometimes be restricted to
   exploitation by the private implementation of the module. Recall
   also that their exists in OCaml a fairly large collection of
   predefined exceptions that are global.
   </p>

   <h5>Public types</h5>

   <p>
   With explicit typing by signatures, as for exceptions, to export
   types from a module requires their implementation in the
   signature. In other words, the types must be concrete and not
   abstract if they are to be exported. For example, consider complex
   numbers, but this time with a representation in the form of records
   which integrate both the real part, their imaginary part and their
   precalculated norm:
   <pre class="prettyprint ml">
   module type COMPLEX = sig
     type complex = {real : float; im : float; norm : float}
     val make : float * float &rarr; complex
     val add : complex &rarr; complex &rarr; complex
     val norm : complex &rarr; float
   end;;
   </pre>
    The definition of the type <code>complex</code> within the
    signature renders it public for any instantiation. In particular,
    the fields of the record are directly usable:
   <pre class="prettyprint ml">
   module Complex : COMPLEX = struct
     type complex = {real : float; im : float; norm : float}

     let make (r, i) = {re = r; im = i;
                        norm = sqrt (r ** 2. + i ** 2.)}
     let add z w = ...
     let norm z = z.norm
   end;;

   # let zq = Complex.make (4., 3.);;
   val z1 : Complex.comple = 
     {Complex.re = 4.; Complex.im = 3.; Complex.norm = 5}

   # z1.Complex.re;;
   - : float = 4.

   # z1.Complex.norm;;
   - : float = 5.
   </pre>
   However, the interest of exporting types is questionable. For
   example, one observes here an interaction between the
   field <code>norm</code> and the function <code>norm</code> and
   assumes an equivalence. The relationship between the declared norm
   and the calculated norm can nevertheless take a more sophisticted
   turn.
   </p>

   <h5>Private and abstract types</h5>

   <p>
   A final development is necessary regarding visibility and the
   explicit typing of modules. As stated in the "rule (2) of the
   visibility of modules", there is a particular case: when explicitly
   typing modules with signatures, an abstract type is not rendered
   public. The abstract character of such types is
   maintained. Modifying the previous example:
   <pre class="prettyprint ml">
   module type COMPLEX = sig
     type complex (*abstract*)
     val make : float * float &rarr; complex
     ...
   end;;
    
   module Complex : COMPLEX = struct (*explicit type*)
     type complex = {real : float; im : float; norm : float}

     let make (r, i) = {re = r; im = i;
                        norm = sqrt (r ** 2. + i ** 2.)}
     ...
   end;;

   # let z1 = Complex.make (4., 3.);;
   val z1 : Complex.complex = &lt;abstr&gt;

   # z1.Complex.re
   Unbound record field label
   </pre>
   The responses of the type inference hide here the representation of
   the type mentioning only that it is <code>&lt;abstr&gt;</code>. It
   is therefore impossible to access directly, even to display, the
   values associated with a complex number. Specific accessors are now
   indispensable. It is possible to extend the
   signature <code>COMPLEX</code> with a general accessor, here we'll
   name it <code>show</code> which returns a complex number in the
   form of a pair of <code>float</code>:
   <pre class="prettyprint ml">
   module type COMPLEX = sig
     type complex (*abstract*)
     val make : float * float &rarr; complex
     val show : complex &rarr; float * float
     ...
   end;;

   module Complex : COMPLEX = struct (*explicit type*)
     type complex = {real : float; im : float; norm : float}

     let make (r, i) = {re = r; im = i;
                        norm = sqrt (r ** 2. + i ** 2.)}

     let show z = (z.re, z.im)

     ...
   end;;
   </pre>
   The type <code>complex</code> is henceforth hidden, instantiable
   and exploitable:
   <pre class="prettyprint ml">
   # let z1 = Complex.make (4., 3.);;
   val z1 : Complex.complex = &lt;abstr&gt;

   # Complex.show z1;
   - : float * float = (4., 3.)
   </pre>
   </p>

   <p>
   Certain types of data lend themselves to the hiding of their
   representation better than others. For example, those
   data-structures that naturally provide accessors and constructors
   of empty structures or of particular sizes. Let us recall the
   following example:
   <pre class="prettyprint ml">
   module type LINEAR_CONTAINER = sig
     type &alpha; lin
     val empty : unit &rarr; &alpha; lin (*constructor*)
     val add : &alpha; &rarr; &alpha; lin &rarr; &alpha; lin
     val nth : &alpha; lin; &rarr; int &rarr; &alpha; (*accessor*)
   end;;

   module L : LINEAR_CONTAINER = struct
     type &alpha; lin = Empty | Cons of &alpha; * &alpha lin
     let empty () = Empty
     let add x l = ...
     let nth l n = ...
   end;

   # let l1 = L.add 111 (L.add 666 (L.empty ()));;
   val l1 : int L.lin = &lt;abstr&gt;

   # L.nth l1 1;;
   - : int = 666
   </pre>
   The universal type parameter <code>&alpha;</code> can be equally
   well instantiated with a hidden type as with a public type. In
   other words, the responsibility of msasking the values contained by
   the containers is left in the hands of the users. For example, it is
   possible to insert a hidden complex number in the container of
   type <code>&alpha; lin</code>:
   <pre class="prettyprint ml">
   # let l1 = L.add (Complex.make (4.0, 3.0)) (L.empty ());;
   val l1 : Complex.complex L.lin = &lt;abstr&gt;

   # L.nth l1 0;;
   - : Complex.complex = &lt;abstr&gt;
   </pre>
   Of course, the application of the <code>show</code> accessor is required if it is desired to obtain the explicit values:
   <pre class="prettyprint ml">
   # Complex.show (L.nth l1 0);;
   - : float * float = (4., 3.)
   </pre>
   We therefore have the possibility to implement controlled
   visibility of the elements which make up a module. In the case of
   the implementation of data types, this complete mastery of
   visibility permits us to define abstract data types where details
   of the representation are necessarily hidden (and therefore based
   on abstract types in the corresponding signatures).
   </p>

   <h4>Abstract data types</h4>

   <h5>The reasons for hiding and substitution</h5>
   <p>
   Visibility control of the elements of modules, in other words
   - <i>implementation hiding</i> - is an important tool for the
   production of modular programs of quality. Hiding in effect assures
   indepdence between modules. Without that independence, certain
   properties mentioned at the outset of the section are
   compromised. For example, implementation dissemination can make it
   difficult to make any subsequent changes and adapations and
   extensions tedious and delicate to carry out.
   </p>
   <p>
   On the other hand, hiding is based on signatures, that is, elements
   that describe the programm without fixing on or revealing an
   implementation (the specification). The signatures contain the
   abstractions, the interfaces, a screen over the particulars of a
   program. However the signatures indicate as well the organisation
   of the program composed as distinct modules. They represent by
   themselves the logical architecture.
   </p>
   <p>
   If the properties sought through modular programming have so far
   been expressed in a very general way, what has just been said has
   allowed us to establish a principal that more concretely
   characterize a good modular organisation:
   <br/>
   <br/>
   <b>The principle of modular substitutivity : </b> Let <b>S</b> be
   the set of signatures that specify a modular program <i>Prog</i>,
   and let <code>M</code> be a component of <i>Prog</i> that satisfies
   a signature <code>S</code> \(\in\) <b>S</b>. Then, any component
   that also satisfies <code>S</code> may be substituted
   for <code>M</code> without any other modifications of <i>Prog</i>.
   <br/>
   <br/>
   This principle expresses what is meant by "to be independent" in
   the case of a set of modular components. It gives rise to a similar
   virtue of the notion of referential transparency in functional
   programming, that is to say, a strict localization of the effects
   of an action on the program. Under the aegis of the "principle of
   substitutivity", a program can be first specified and its
   realization and development broken down component by component.
   </p>
   <p>
   In the following, we now illustrate some of the ideas of
   implementation of abstract data types and present precise
   techniques offed by OCaml to implement them. We shall then return
   to these general questions.
   </p>

   <h5>How to evolve datatypes</h5>

   <p>A representative situation for evolution in modifying programs
   consists of adaptions in the interest of performance improvments in
   time and space. Optimisation is often performed after an operation
   is revealed to be complex and tedious. It is therefore economic in
   the early phases of development of a program to make it easy to
   return thereafer and substitute more efficient code.
   </p>
   <p>
   In the context of abstract data types, these modifications lead
   generally to representations that are very far removed from those
   that seem natural at the outset. In effect, the implementations
   then carry technical information which contributes to the
   optimization of their associated functions. We have already seen
   several examples. For example, consider the case of the
   specification of a datatype for queues:
   <pre class="prettyprint ml">
   module type FIFO_CONTAINER = sig
     type &alpha; queue
     val empty : unit &rarr; &alpha; queue
     val add : &alpha; &rarr; &alpha; queue &rarr; &alpha; queue
     val fst : &alpha; queue &rarr; &alpha;
     val out : &alpha; queue &rarr; &alpha; queue
   end;;
   </pre>
   The signature could be directly implemented with a list and without
   too much regard to the effects of the persistent nature resulting
   from being of functional character:
   <pre class="prettyprint ml">
   module Q_list : FIFO_CONTAINER = struct
     type &alpha; queue = &alpha; list
     let empty () = []
     let add x q = q @ [x]
     let fst q = ...
     let out q = ...
   end;;
   </pre>
   The signature however, equally allows for an implementation
   optimized for queues:
   <pre class="prettyprint ml">
   module Q_burton : FIFO_CONTAINER = struct
     type &alpha; queue = Q of &alpha; list * &alpha; list
     let empty () = Q ([], [])
     let add x (Q (l1, l2)) = ...
     let fst q = ...
     let out q = ...
   end;;
   </pre>
   This change of representation is transparent to any user who is
   restricted to the signature <code>FIFO_CONTAINER</code> : the
   module <code>Q_burton</code> may be directly substituted
   for <code>Q_list</code> even though the representations are quite
   different.
   </p>
   <p>
   Here's another classic example for the structure of association
   tables. These tables may be initially specified in a minimal way:
   <pre class="prettyprint ml">
   module type ASSOC_TABLE = sig
     type (&alpha;, &beta;) assoc
     val empty : unit &rarr; (&alpha;, &beta;) assoc
     val get_pair : (&alpha;, &beta;) assoc &rarr; &alpha; * &beta;
     val assoc : (&alpha;, &beta;) assoc &rarr; &alpha; &rarr; &beta;
     val add : &alpha; &rarr; &beta; &rarr; (&alpha;, &beta;) assoc &rarr; (&alpha;, &beta;) assoc
     val sub : &alpha; &rarr; (&alpha;, &beta;) assoc &rarr; (&alpha;, &beta;) assoc
   end;;
   </pre>
   This signature is easily implemented as a list:
   <pre class="prettyprint ml">
   module Assoc_list : ASSOC_TABLE = struct
     type (&alpha;, &beta;) assoc = (&alpha; * &beta;) list

     let empty () = []

     let get_pair l = 
       try
         List.hd l 
       with
       | Failure "hd" &rarr; failwith "No pair"

      let assoc l key = List.assoc key l

      let add key data l =
        try (assoc l key; failwith "Already inserted")
        with | Not_found &rarr; (key, data) :: l
     
      let sub key l = ...
   end;;

   # let t1 = Assoc_list.add 1 &alpha;' (Assoc_list.empty ());;
   val t1 : (int, char) Assoc_list.assoc = &lt;abstr&gt;

   # let t1 = Assoc_list.add 2 &beta;' t1;;
   val t1 : (int, char) Assoc_list.assoc = &lt;abstr&gt;

   # Assoc_list.assoc t1 1;;
   - : char = &alpha;'
   </pre>
   When the elements of an association table are frequently accessed,
   it is normal to organise the association table in order that
   accessing elements is of logarithmic complexity. For this we can
   utilize the simple definition of binary search trees but of the
   balanced variety, for example, red-black trees:
   <pre class="prettyprint ml">
   module Assoc_rb_tree : ASSOC_TABLE = struct
     type color = R | B

     type (&alpha;, &beta;) assoc =
       | Empty
       | Node of color * (&alpha;, &beta;) * (&alpha;, &beta;) assoc * (&alpha;, &beta;) assoc

     let empty () = Empty
 
     let get_pair t = match t with
       | Empty &rarr; failwith "No pair"
       | Node (_, x, _, _) &rarr; x

     let rec assoc t key = match t with
       | Empty &rarr; raise Not_found
       | Node (_, (key', data), l, r) &rarr;
           if key = key' then data else
           if key < key' then assoc l key 
           else assoc r key

      let local_balance = ...
      let add key data t = ...
      let sub key t = ...
   end;;
   </pre>
   Again, the optimisation can be used transparently due to
   conformance to the <code>ASSOC_TABLE</code> signature:
   <pre class="prettyprint ml">
   # let t1 = Assoc_rb_tree.add 1 &alpha;' (Assoc_rb_tree.empty ());;
   val t1 : (int, char) Assoc_rb_tree.assoc = &lt;abstr&gt;

   # let t1 = Assoc_rb_tree.add 2 &beta;' t1;;
   val t1 : (int, char) Assoc_rb_tree.assoc = &lt;abstr&gt;

   # Assoc_rb_tree.assoc t1 1;;
   - : char = &alpha;'
   </pre>
   One obtains the same behavior as for the preceding implementation.
   </p>

   <h5>Optimizing datatypes by "memoization"</h5>

   <p>
   Here are other examples of abstract data types using a particular
   optimization technique. Recall the case of complex numbers with a
   representation that includes a pre-calculated norm. If this value
   is not used, this calculation becomes useless. One way to remedy
   this situation is to calculate it on first use (this is called
   "memoization"). Here is an implementation which qpplies this
   technique that equally well satisfies the
   signature <code>COMPLEX</code>:
   <pre class="prettyprint ml">
   module Complex_memo : COMPLEX = struct
     type complex = { re : float; im : float;
                      mutable norm : float option } (*memoization*)

     let make (r, i) = { re : r; im : i; norm = None}

     let show z = (z.re; z.im )

     let add z w = make (z.re +. w.re, z.im +. w.im)

     let norm z = match z.norm with
       | Some x &rarr; x
       | None &rarr; let m = sqrt (z.re ** 2. + z.im ** 2.) in
                 (z.norm <- Some m; m)
   end;;
   </pre>
   This optimization is transparent from the point of view of using
   complex numbers through the signature <code>COMPLEX</code>:
   <pre class="prettyprint ml">
   # let z1 = Complex_memo.make (3., 4.);;
   val z1 : Complex_memo.complex = &lt;abstr&gt;

   # let z2 = Complex_memo.add z1 z1;
   val z2 : Complex_memo.complex = &lt;abstr&gt;

   # Complex_memo.show z2;;
   - : float * float = (8., 6.)
   </pre>
   There are cases where memoization of all calculations proves to be
   unsuitable or too heavy. For example, successive searches into a
   data structure can not all be transformed into immediate
   access. The idea is rather to put in place "caches" which provide
   direct references only for the most recent searches. These caches
   act as a set of opportunities to take "shortcuts". A problem then
   arises when one modifies the data structure: elements that are
   deleted by are nevertheless referenced by a cache are not
   recoverable by the garbage collector; they remain referenced by
   their shortcuts but they may not be utilized as they no longer
   exist... A solution to this paradox is offered by the notion of
   a <i>weak</i> reference, that is a reference to an element the
   garbage collector is entitled to recover. As long as these element
   exist, these references make it possible to reach them; if these
   elements are to be destroyed, these references do not impede the
   garbage collector in harvesting them.
   </p>
   <p>
   The <code>Weak</code> module in the OCaml stanard library provides
   an implementation of a table of weak references. For example, we
   can integrate the technique of memoization by caches with an
   inmplementation of a table of associations : each will have an
   individual cache that will allow to reach directly the elements
   previously accessed. The association function will therefore give
   priority to the cache and then, in the case of failure on the table
   of associations. This operation will also be responsible for
   updating the cache. Here is an implementation based on binary trees
   that satisfies the signature <code>ASSOC_TABLE</code>:
   <pre class="prettyprint ml">
   module Assoc_tree : ASSOC_TABLE = struct
     let cache_size = 5 (*fixed cache size*)

     type (&alpha;, &beta;) bintree = 
       | Bin_empty
       | Bin_node of (&alpha; * &beta;) * (&alpha;, &beta;) bintree * (&alpha;, &beta;) bintree

     type (&alpha;, &beta;) assoc = { tree : (&alpha;, &beta;) bintree ;
                             cache : (&alpha; * &beta;) Weak.t ;
                             mutable index : int
                          }

      let empty () = { tree = Bin_empty; 
                       cache = Weak.create cache_size;  
                       index = 0}

      let get_pair { tree = t } = match t with
        | Bin_empty &rarr; failwith "No pair"  
        | Bin_node &rarr; (x, _, _) &rarr; x

      let assoc_direct table key =
        let rec aux t = match t with
          | Bin_empty &rarr; raise Not_found
          | Bin_node ((key'; data'), t1, t2) &rarr;
              if key = key' then data' else
              if key < key' then aux t1 else aux t2
        in aux table.tree

      let assoc table key =
        let res = ref None in
        let index = ref 0 in
        begin (*search the cache*)
          while (!index < cache_size) && (!res = None) do
            match Weak.get table.cache !index with
              | Some (key', data) &rarr;
                  if key = key' then res := Some data else incr index
              | None &rarr; incr index
          done ;
          match !res with
            | Some x &rarr; x
            | None &rarr;
                let data = assoc_direct table key in
                Weak.set table.cache table.index (Some (key, data));
                table.index <- (table.index + 1) mod cache_size;
                data
        end

       let add key data table = ...
       let sub key table = ...
   end;;
   </pre>
   Obviously, this implementation is much more complex than the others
   and only really justified for very large trees. However, the
   optimization is still transparent to the user. All these examples
   show that an improvement of a data type could include radical
   changes in the form of its instances. Exporting of the
   representation of these types would be very bad if they had to be
   modified after their dissemination into the code. This work could
   prove to be not only laborious but problematic. Indeed, the user
   might find herself in the necessity of managing the creation, the
   coherence and the processing in the module associated with the
   datatype. That said, implementation hiding is a technique not
   without difficulties and traps. We will develop some of them in the
   following. Let us first recall that the type
   variables <code>&alpha;</code>, <code>&beta;</code> etc are instantiable in
   masked types. On the other hand, only structural functions are
   capable of offering a universal generiticy, that is to say, a truly
   uniform treatment of their arguments whatever the representation.
   </p>

   <h5>Hiding and generating predefined predicates</h5>

   <p>
   The multiple implementations of the last few pages have established
   the framework of the "principle of module substituion". Optimized
   versions have replaced non-optimized versions transparently. This
   is only possible however if we take care to avoid transmitting
   implicitly someting concealed between the components in spite of
   their adherence to their respective signatures.
   </p>
   <p>
   There exists a case in OCaml which is particularly representative
   of this difficulty. For example, reconsider the complex number
   type <code>Complex_memo</code> which uses memoization for the
   norm. The representation of values of the type is the following:
   <pre class="prettyprint ml">
   type complex = {re : float; im : float; mutable norm : float option}
   </pre>
   Recall that the predefined equality operator '<code>=</code>' over
   records, compares each field. Under these conditions, the equality
   function is no long valid on such a lazy representation:
   <pre class="prettyprint ml">
   # let z1 = Complex_memo.make (1., 1.1)
     let z2 = Complex_memo.make (1., 1.1);;

   # z1 = z2;; 
   - : bool = true

   # Complex_memo.norm z1;
   - : float = 1.414213

   # z1 = z2;;
   - : bool = false
   </pre>
   The origin of this behavior may be even more difficult to discover
   when comparison predicates are used by other functions. For example:
   <pre class="prettyprint ml">
   # let z1 = Complex_memo.make (1., 1.)
     let z2 = Complex_memo.make (1., 1.)
     let l1 = [z1; z1; z1];;

   # List.mem z2 l1;;
   - : bool = trure

   # Complex_memo.norm z1;;

   #List.mem z2 l1;
   - : bool = false
   </pre>
   Implmentation of the function <code>List.mem</code> utilizes the
   default equality function.
   </p>
   <p>Thus, the contribution of these comparison predicates puts in
   peril the independence of modular components. The earlier example
   shows that moving from a trivial implementation of complex numbers
   to an implementation with memoisation induces noticeable
   differences in behavior.
   <br/>
   <br/>
   <b>Constraint (1) of substitutivity : </b> The principle of module
   substitutivity is not strictly applicable in OCaml when abstract
   types are used by functions that use comparison functions of their
   instances.  <br/> <br/> In particular, a signature for complex
   numbers must inclue an explicit specification of functions to
   compare them to work around the problems just discussed:
   <pre class="prettyprint ml">
   module type COMPLEX = sig
     type complex
     val make : float &rarr; float &rarr; complex
     val show : complex &rarr; float * float
     val eq : complex &rarr; complex &rarr; bool
     val less_than_eq : complex &rarr; complex &rarr; bool
     ...
   end;;
   </pre>
   </p>

   <h5>Hiding and imperative optimizations</h5>

   <p>
   We have seen examples using imperative features whilst ensuring
   partioning of this style: nothing was visible outside of the
   module. The values were simply associated with modifiable
   information that optimized their evaluation. The only noticeable
   effect in this case is an "evaluation sharing" which does not alter
   referential transparency. The preceding section illustrates the
   problem of comparing values by means of the default predicates but
   this difficulty was related only to an interaction between hiding
   and restrained generiticy of the predicates. It would be possible
   to envisage transformations of the implementation of a module
   integrating more fully the imperative style. For example, here is a
   signature specifying the type of sets:
   <pre class="prettyprint ml">
   module type SET = sig
     type &alpha; set
     val empty : unit &rarr; &alpha; set
     val mem : &alpha; &rarr; &alpha; set &rarr; bool
     val add : &alpha; &rarr; &alpha; set &rarr; &alpha; set
     val union : &alpha; set &rarr; &alpha; set &rarr; &alpha; set
     val inter : &alpha; set &rarr; &alpha; set &rarr; &alpha; set
   end;;
   </pre>
   It is possible first of all to utilize a functional representation
   of sets:
   <pre class="prettyprint ml">
   module Set_fun : SET = struct
     type &alpha; set = &alpha; &rarr; bool
     let empty () = fun y &rarr; false
     let mem x s = s x
     let add x s = if mem x s then s else fun y &rarr; s y || x = y
     let rec union s1 s2 = fun y &rarr; s1 y || s2 y
     let rec inter s1 s2 = fun y &rarr; s1 && s2 y
   end;;
   </pre>
   So,
   <pre class="prettyprint ml">
   # let s1 = Set_fun.add 1 (Set_fun.add 2 (Set_fun.empty ()));;
   val s1 : int Set_fun = &lt;abstr&gt;

   # Set_fun.mem 2 s1;;
   - : = true
   </pre>
   The purely functional style allows here a terse and not conductive
   to errors program. On the other hand, the complexities in time and
   space are high. Consequently, seceral possibilities of optimization
   might be contemplated. Association tables for example might be
   considered for exploiting an ordering of the elements of the set
   and thereby inducing a tree like structure. One could also
   contribute a hash table of imperative character such as to be found
   in the <code>Hashtable</code> module of the standard library. Note
   that tables are presented as association tables. In order to use
   them as simple tables, the usual tactic is to systematically
   associate keys with constants. The latter can then correspond to
   the elements of the set. Here is a new implementation that
   satisfies <code>SET</code>:
   <pre class="prettyprint ml">
   module Set_h : SET = struct
     type &alpha; set = (&alpha;, unit) Hashtbl.t

     let dummy = ()

     let empty () = Hashtbl.create 0

     let mem x h = Hashtbl.mem x

     let add x h1 =
       if mem x h1 then h1
       else let h = Hashtbl.copy h1 in (Hashtbl.add h x dummy; h)

     let union h1 h2 =
       let h = Hashtbl.copy h1 in
       Hashtbl.iter (fun x _ &rarr; ignore (add x h)) h2; h

     let inter h1 h2 =
       let h = empty () in
       Hashtbl.iter (fun x _ &rarr;
         if (Hashtbl.mem h1 x) && (Hashtbl.mem h2 x) then
           Hashtbl.add h x dummy) h1; h
   end;;
   </pre>
   Then, in the same manner as <code>Set_func</code> :
   <pre class="prettyprint ml">
   # let s1 = Set_h.add 1 (Set_h.add 2 (Set_h.empty ()));;
   val s1 : int Set_h = &lt;abstr&gt;

   # Set_h.mem 2 s1;;
   - : = true
   </pre>
   Due to the use of hash tables, accessing the elements of the set is
   fast (the function <code>mem</code> is guaranteed to return in
   constant time). However, it should be noted this implementation
   preserves the functional character of the specification of the
   operation <code>add</code>, that is,
   <pre class="prettyprint ml">
   val add : &alpha; &rarr; &alpha; set &rarr; &alpha; set
   </pre>
   Indeed, the implementation of <code>add</code>
   in <code>Set_h</code> causes the sets to be persistent : each
   insertion implies a complete copy of the hash table. We could of
   course override this property of <code>add</code> so as to
   camouflage it's imperative behavior :
   <pre class="prettyprint ml">
   # let add x h1 =
       if mem x h1 then h1
       else (Hashtbl.add h1 x dummy; h1)
   val add : &alpha; &rarr; &alpha; set &rarr; &alpha; set
   </pre>
   We refer here to the table <code>h1</code> after
   modification. However, doing so give rise to the problems of
   referential transparency no longer being verified in an expression
   making use of these sets and delicate errors may result.
   </p>
   <p>
   This exmaple illustrates the neccessity of reflecting clearly the
   intent of the style of the signature and to conform to it.
   <br/>
   <br/>
   <b>Constraint (2) of substitutivity : </b> The pricinciple of
   module substitutivity is not strictly applicable in a functional
   framework if imperative features are not strictly
   compartmentalized.
   <br/>
   <br/>
   In other words, the preservation of the substitution principle
   justfies what is illustrated in:
   <br/>
   <br/>
   <b>Indication of imperative features in the specificiation : </b>
   In signatures, those operations with imperative behavior appear as
   procedure declarations (results are of type <code>unit</code>).
   <br/> <br/> For example, if full use were to be made of a table of
   imperative style, the signature <code>SET</code> should reflect
   this:
   <pre class="prettyprint ml">
   module type SET = sig
     type &alpha; set
     val add : &alpha; &rarr; &alpha; set &rarr; unit
     ...
   end;;
   </pre>
   The function for adding an element to a set exhibits an imperative
   character.
   <pre class="prettyprint ml">
   # let add x h =
       if not (mem x h) then Hashtbl.add h x dummy;;
   val add : &alpha; &rarr; &alpha; set &rarr; unit
   </pre>
   This example shows again the difficulties of preventing propagation
   of the imperative style. If its application gives rise to
   behavioral changes which escape a specification, they will surprise
   and demand consequent work of a search for errors : an expected
   effect when the principle of substitutivity applies only in
   pretense. The strict partitioning of styles however here leads to a
   multiplication of signatures : the ones in a style purely
   functional, the others in the imperative style. Optmization via
   imperative constructs is not directly applicable. It is however
   possible to unify signatures by application of a generalization for
   the return types of functions. Indeed, in the framework of
   implementing abstract data types, these types characterize the
   style alone. For example,
   <pre class="prettyprint ml">
   module type SET_GEN = sig
     type &alpha; set
     type &alpha; result
     ...
     val add : &alpha; &rarr; &alpha; set &rarr; &alpha; result
     ...
   end;;
   </pre>
   The type <code>&alpha; result</code> can be instaniated either by
   the same type as <code>&alpha; set</code> indicating a functional
   implementation or, by by <code>unit</code> indicating an imperative
   one.
   </p>
   
   <h5>The need for individual hiding of abstract types</h5>

   <p>
   Our current knowledge of the control of type visibility is
   summarized in the following alternative when a
   signature <code>S</code> is used to explicitly type a
   module <code>M</code>:
   <ul>
   <li>A concrete type in <code>S</code> is public</li>
   <li>A type abstract in <code>S</code> is private to <code>M</code></li>
   </ul>
   These possibilities lack a little nuance. We might sometimes want
   to export an abstract type of <code>S</code> after its
   implmentation in <code>M</code>. But what are the situations that
   engener the need to derogate from type abstraction? Here is the
   representative case. When the represntation of values is to be
   hidden but there is a need to use its constructors as
   accessors. The constructors must then have arguments whose types
   are public and the accessors must also have results whose types are
   public. For example, the signature <code>COMPLEX</code> declares
   functions in the following form:
   <pre class="prettyprint ml">
   val make : float * float &rarr; complex
   val show : comple &rarr; float * float
   </pre>
   Here the respective types of the parameters and the result are
   based on the predefined type <code>float</code>. This constraint is
   probably acceptable for conventional use but it will prevent the
   implementation of certain implementations. Suppose we wished to
   obtain a type for "big complex numbers" from the library
   module <code>Num</code>, that is to say,
   <pre class="prettyprint ml">
   module Complex_num = struct
     type complex = C of Num.num * Num.num

     let make (str_r, str_i) = 
       C (Num.num_of_string str_r, Num.num_of_string str_i)

     let show (C (r, i)) =
       (Num.string_of_num r, Num.string_of_num i)

     let add (C (r1, i1)) (C (r2, i2)) =
       C (Num.( + ) r1 r2, Num.( + ) i1 i2)

     let norm (C (r, i)) =
       sqrt (Num.float_of_num 
         (Num.add_num (Num.square_num r) (Num.square_num i)))
   end;;
   </pre>
   These complex numbers possess real and imaginary parts that are
   abitrarily large and precise:
   <pre class="prettyprint ml">
   # let z1 = Complex_num.make ("3214321/764365", "8920146398/4291")
     let z2 = Complex_num.add z1 z1;;
   # Complex_num.show z2;
   - : string * string = ("3214321/764365", "8920146398/4291")
   </pre>
   It is observed that the types of the parameters of the constructor
   and the accessor of the module <code>Complex_num</code> have
   undergone a transformation. The exterior representation of large
   numbers from <code>Num</code> uses strings instead of floating
   numbers.
   <pre class="prettyprint ml">
   val make : string * string &rarr; complex
   val show : complex &rarr; string * string
   </pre>
   The module <code>Complex_num</code> does not satisfy the
   signature <code>COMPLEX</code>. We can nevertheless generalize will
   this signature with respect to the types of constructors of the
   accessors.
   <br/>
   <br/>
   <b>Technique of generalization of constructors/accessors for
   external types</b> : If <code>t</code> is the representation of
   values of a datatype, we associate a type <code>extern_t</code>
   which constitues the externally view of an instance of
   type <code>t</code>.  
   <br/>
   <br/>
   Thus, in <code>COMPLEX</code> we replace the type <code>float *
   float</code> with a new abstract type <code>extern_complex</code>:
   <pre class="prettyprint ml">
   module type COMPLEX_MASK = sig
     type complex
     type extern_complex
     val make : extern_complex &rarr; complex
     val show : complex &rarr; extern_complex
     val add : complex &rarr; complex &rarr; complex
     val norm : complex &rarr; float
   end;;
   </pre>
   The definition of the type <code>extern_complex</code> can then be
   added to <code>Complex_num</code>:
   <pre class="prettyprint ml">
   module Complex_num = struct
     type complex = C of Num.num * Num.num
     type extern_complex = string * string
     ...    
   end;;
   </pre>
   This implementation becomes compliant to the
   signature <code>COMPLEX_MASK</code>:
   <pre class="prettyprint ml">
   module Complex_num : COMPLEX_MASK = struct
    ...
   end;;
   </pre>
   However, the types <code>complex</code>
   and <code>extern_complex</code> are now both made private by this
   explict typing. The functions <code>make</code>
   and <code>show</code> have become unusable:
   <pre class="prettyprint ml">
   # let z1 = Complex_num.make ("3214321/764365", "8920146398/4291");;
   Type error
   </pre>
   This technique of generalization has augmented the possibilities of
   instantiation of the signature but has neccessarily requires to
   export certain abstract types after their implementation. This
   situation find itself in connection with the
   signature <code>SET_GEN</code> whose definitions of the generalized
   type <code>&alpha; result</code> will also have to be exported. In
   other words, we need a new rule of visibility of individual hiding
   of abstract types. The more careful control of the visibility of
   the types will be possible thanks to a new construction which will
   be described in the following.
   </p>

   <h5>Individual hiding and type constraints</h5>
   <p>
   Signatures can be supplemented by explicit type constraints. The
   constraints are capable of associating <i>a posteriori</i> with
   definitions of abstract types, and are expressed through the
   construction <code>with type</code>:
   <pre class="prettyprint ml">
   &lt;SIGNATURE&gt; with type &lt;type 1&gt; = &lt;expression of type 1&gt;
                     and type ...
                     and type &lt;type n&gt; = &lt;expression of type n&gt;
   </pre>
   where the <code>&lt;type i&gt;</code> denote types included
   in <code>&lt;SIGNATURE&gt;</code> and the <code>&lt;expression of
   type i&gt;</code> is a valid type definition in the environment at
   the moment of application of the type constraint. For example:
   <pre class="prettyprint ml">
   # module type S1 = sig
       type t
       val f : t &rarr; t
     end;;

   # module type S2 = (S1 with type t = int);;
   module type S2 = sig
     type t = int
     val f : t &rarr; t
   end
   </pre>
   Thanks to this constraint, the abstract type <code>t</code> is
   abstract in <code>S1</code> and made concrete in <code>S2</code>.
   <br/>
   <br/>
   <b>Making types concrete with the <code>with type</code>
   construction</b>: Type constraints can make concrete types of types
   that were not originally so. These types then become exportable.
   <br/> <br/> A signature can thus see some of its abstract types
   become concrete. This transformation resolves the problem posed by
   the signature <code>CONCRETE_MASK</code> of the preceding section:
   <pre class="prettyprint ml">
   module Complex_num : COMPLEX_MASK
      with type extern_complex = string * string =
   struct
     type complex = C of of Num.num * Num.num
     type extern_complex = string * string
     let make (str_r, str_i) = ...
     let show (C (r, i)) = ...
       ...
   end;;
   </pre>
   The constructor <code>make</code> becomes accessible from outside
   the module:
   <pre class="prettyprint ml">
   # let z1 = Complex_num.make ("3214321/764365", "8920146398/4291");;
   val z1 : Complex_num.complex = &lt;abstr&gt;
   </pre>
   </p>
   <p>
   Here are some remarks to help with usage of type constraints:
   <ul>
   <li><i>Neccessary duplication.</i> The syntax imposed by the
   construction <code>with type</code> sometimes seems somwhat
   fastidious since it requires a flagrant duplication between the
   type constraints and the definitions in the module. The
   implementation of the module must be consistent with the signature
   transformed by the addition of the type constraint. This
   duplication of code is the same as that which occurs in the
   relationship between signatures directly containing concrete types
   and their instantiations.
   <br/>
   <br/>
   </li>
   <li><i>Irreversibility of hiding. </i> A type which is hidden may not become revealed by the addition of a type constraint. For example,
   <pre class="prettyprint ml">
   # module type S1 = sig type t end;;
   # module M1 : S1 = struct type t = int end;;
   # module M2 : S1 with type t = int = struct type t = M.t end;;
   Type error
   </pre>
   The system cannot make the link here between <code>int</code>
   and <code>M.t</code>. Indeed, the name of a hidden type is
   definitiely associated with it's module : the name of
   the <code>int</code> type hidden in <code>M</code>
   is <code>M.t</code>. It will no longer be equivalent to "int". Type
   abstraction is directly reflected in OCaml by this syntactic
   difference between the names of types. 
   </li>
   </ul>
   </p>
   <p>
   Type constraints are the last ingredient needed to systematically
   implement abstract data type and more generally, modules whose
   implementations are systematically masked even in the case where it
   is necessary to export abstract types.
   <br/>
   <br/>
   <b>Modular programming with rigorous hiding</b>
   <ol>
   <li>No type definition is given in the signatures (no type
   definitively fixed as concrete)</li>
   <li>
   All modules are explicitly typed with a signature. <code>with
   type</code> constructions are applied on those types that need to be
   exported.
   </li>
   </ol>
   <br/> <br/> We will discuss again the interest in this modular
   programming style. Note that the first point above does not
   prohibit making use of global types like for example, the
   predefined types. The generalization of types in signatures is not
   an obligation, this is only a means of which we will still say a
   few words in the next section.
   </p>

   <h5>The conceptual generalization of signatures</h5>
   <p>
   Generalization renders signatures adaptable without having to
   redefine them, to rename them and thus to organize their
   variations. Additionally, the possibilities offered by type
   constraints make it possible to not fear the effects of the rules
   of visibility. If the examples of the preceding pages reveal
   essential techniques, it is important to remark that generalization
   can also extend conceptually the field of description of a
   signature. For example, consider a new signature of the notion of a
   bi-dimensional space with a distance:
   <pre class="prettyprint ml">
   module type METRIC_SPACE_2D = sig
     type point
     val make_point : float * float &rarr; point
     val dist : point &rarr; point &rarr; float
   end;;
   </pre>
   The number of dimensions of the space is fixed by the type of the
   constructor <code>make_point</code>. Applying the external type
   technique it is possible to work around this constraint and propose
   a more general specification of spaces:
   <pre class="prettyprint ml">
   module type METRIC_SPACE = sig
     type point
     type extern_point
     val make_point : extern_point &rarr; point
     val dist : point &rarr; point &rarr; float
   end;;
   </pre>
   And here first of all an instance adapted from one previously
   presented which could do all the business:
   <pre class="prettyprint ml">
   module Plane_count : METRIC_SPACE
     with type extern_point = float * float = 
   struct
     type point = { number : int; coord : float * float }
     type extern_point = float * float
     let count = ref 0
     let make_point (x, y) = ...
     let dist (x1, y1) (x2, y2) = ...
   end;;
   </pre>
   But, it is equally possible to define spaces with different
   dimensions. For example, a space of dimension \(1\):
   <pre class="prettyprint ml">
   module Line : METRIC_SPACE
     with type extern_point = float =
   struct
     type point = float
     type extern_point = float
     let make_point x = x
     let dist x1 x2 = abs_float (x1 -. x2)
   end;;
   </pre>
   It is also possible to envisage instantiations of the
   signature <code>METRIC_SPACE</code> with a dramatically different
   nature. For example, recognition and compression of alphanumeric
   character strings are based generally on quantitative comparisons
   and their representations as binary numbers. The functions of
   distance can then be put into contribution in order to structure
   the set of recognized characters and the characters to be
   recognized. The simplest of these functions is to count the number
   of pixels different from the respective representations. Here is a
   possible implementation of this novel space also
   satisfying <code>METRIC_SPACE</code>:
   <pre class="prettyprint ml">
   module Bit_map : METRIC_SPACE
     with type extern_point = int array array =
   struct
     type point = Bitmap of int array array
     type extern_point = int array array

     let make_point b = Bitmap b

     let dist (Bitmap b1) (Bitmap b2) =
       let len_x = Array.length b1 in
       let len_y = Array.length b1.(0)  in
       let diff_count = ref 0 in
       if len_x = Array.length b2 &&
          len_y = Array.lgength b2.(0)
       then
         for i = 0 to len_x -1 do
           for j = 0 to len_y - 1 do
             if b1.(i).(j) <> b2.(i).(j) then incr diff_count
           done
         done
       else failwith "Bitmap sizes different"
       float (!diff_count)
   end;;
   </pre>
   </p>

   <h5>Tactics for naming abstract data types</h5>
   <p>
   The implementation of abstract data types by modular means is
   dependent on the relationships mainted by three elements:
   <ol>
   <li>The signature of the datatype</li>
   <li>The type of the data itself</li>
   <li>The representation of values included in the datatype</li>
   </ol>
   These three elements must of course bear names and their choice is
   not so innocent of that. The names participate in the quality of
   the abstraction and they predispose more or less to
   compatibility. One point in particular distinguishes many "tactics
   of naming" (which we have already observed in previous examples):
   <ul>
   <li><i>Homogenous naming tactics.</i> The distinctions between the
   three elements above are reduced by names which are as similar as
   possible. For example:
   <pre class="prettyprint ml">
   module type COMPLEX = sig
     type complex
     val add : complex &rarr; complex &rarr; complex
     ...
   end;;

   module Complex : COMPLEX = struct
     type complex = ...
     ...
   end;;
   </pre>
   This homogeneity of naming expresses here that there is only one
   element that counts : the type of complex numbers.
   <br/>
   <br/>
   </li>
   <li><i>Algebraic naming tactics.</i> The distinctions between the
   three elements are emphasized by giving them distinct names. The
   "algebraic" character of the type of data are also made apparent :
   a type of data is endeed a set of values structured by associated
   operations.
   <br/>
   <br/>
   <ul>
   <li><i>Strong distinction.</i> We assert the difference between the
   type of data and its representation of values by different and
   descriptive names. For example:
   <pre class="prettyprint ml">
   module Plane = struct
     type point = ...
     let dist x y = ...
   end;;
   </pre>
   The representation of values here bears the particular name
   of <code>point</code> to which is added a distance generating by
   itself a particular space that is to say, the <code>Plane</code>.
   <br/>
   <br/>
   </li>
   <li><i>Weak distinction.</i> The characteristics of the
   representation of values are eluded by giving it a formal name and
   the most neutral possible (classicly, <code>t</code>). For
   example:
   <pre class="prettyprint ml">
   module Complex = struct
     type t
     ...
   end;;
   </pre>
   In contrast to the "homogenous" naming technique, an attempt is
   made here to diminish the distinctions between the datatype and the
   representation of values altering the role of the latter. The full
   name of the type in effect becomes <code>Complex.t</code>.
   </li>
   </ul>
   </li>
   </ul> 
   The tactic of algebraic naming permits expression a distinction
   between a datatype and the containing signature : the instances of
   the signature can in themselves form a characteristic group. For
   example:
   <pre class="prettyprint ml">
   module type METRIC_SPACE = sig
     type point
     ...
   end;;

   module Plane : METRIC_SPACE = struct
     type point = ...
     ...
   end;;
   </pre>
   Here <code>Plane</code> is a particular instance of a metric space,
   that is to say <code>METRIC_SPACE</code>.
   <br/>
   <br/>
   The same tactic can be applied to complex numbers but it requires a
   generalization of the signature. It is sufficient in doing this to
   recognize that complex numbers are only one instance of a structure
   that makes it possible to "make calculations under favorable
   conditions". For example:
   <pre class="prettyprint ml">
   module type ARITH = sig
     type nb                       type extern_nb
     val make : extern_nb &rarr; nb    val show : nb &rarr; extern_nb
     val zero : nb                 val one : nb
     val add : nb &rarr; nb &rarr; nb      val sub : nb &rarr; nb &rarr; nb
     val mul : nb &rarr; nb &rarr; nb      val div :  nb &rarr; nb &rarr; nb
   end;;
   </pre>
   The type of complex numbers can then become an instance of that
   signature:
   <pre class="prettyprint ml">
   module Complex : ARITH = struct
     type nb = ...
     ...
   end;;
   </pre>
   </p>
   <p>
   Let us compare these naming tactics. The tactic of "homogenous"
   naming permits economic generality while making declarations
   explicit within a signature. For example:
   <pre class="prettyprint ml">
   val add : complex &rarr; complex &rarr; complex
   </pre>
   This tactic generates redundancies however since the name of the
   complete type is <code>Complex.complex</code>. On the other hand,
   it hinders the generalization of a signature since a particular
   name is associated with the representation of values. For example,
   a generalized signature such as <code>ARITH</code> must not display
   a name such as <code>complex</code>. In contrast, the "strong
   algebraic" naming tactic remedies the redundancies and does not
   interfere with the generalization of a signature. Additionally,
   this tactic favors compatibility between signatures when for
   example, the representation of values is systematically named
   "t". Nevertheless, this induces a loss of precision. For example,
   in the case of complex numbers, the function for addition is
   specified as :
   <pre class="prettyprint ml">
   val add : t &rarr; t &rarr; t
   </pre>
   This imprecision can become annoying when number modules interact
   with each other or when representation of values utilizes multiple
   distinct types. It also sometimes reduces the possibility of
   pooling types. Finally, the "weak algebraic" tactic proposes to
   make a more explicit distinction between names. This also engenders
   some imprecision but reduces the barriers to compatibility between
   signatures.
   </p>
   <p>
   No naming tactic is therefore perfect. As a compromise, the "weakly
   algebraic" tactic is used in practice. This for example, is applied
   to many types in the standard OCaml library. We will see further on
   that there exists a technique to rename the elements of a module in
   fairly good conditions.
   </p>

   <h5>Universal type parameters and abstract types</h5>
   <p>
   It is neccessary to be careful of the level of generiticity which
   is explained in a signature. Consider for example the case of a
   function <code>f</code> specified in a signature and whose
   type <code>T</code> makes use of type
   parameters <code>&alpha;</code>, <code>&beta;</code> etc. The
   implementation of <code>f</code> must be compatible
   with <code>T</code>, at least as generic as imposed
   by <code>T</code>. Experience shows that this evidence is not so
   easy to apprehend.
   </p>
   <p>
   Here for example is a signature which might seem to specify in a
   very general manner types for ordered sets:
   <pre class="prettyprint ml">
   module type ORDER_GEN = sig
     val less_or_equal : &alpha; &rarr; &alpha; &rarr; bool
   end;;
   </pre>
   The signature requires production of an implementation
   of <code>less_or_equal</code> that is completely generic. Any
   function whose implementation is more specific would not
   satisfy. Let us recall that only the predefined predicates are able
   to offer such generiticity. The signature that specifies ordered
   sets is therefore rather of the form:
   <pre class="prettyprint ml">
   module type ORDER = sig
     type t
     type extern_t
     val make : extern_t &rarr; t
     val show : t &rarr; extern_t
     val less_or_equal : t &rarr; t &rarr; bool
   end;;
   </pre>
   In this signature, the indicated implementation
   of <code>less_or_equal</code> is dependant on the instantiation of
   the abstract type <code>t</code>. The specification possesses a
   certain level of generiticity as in <code>ORDER_GEN</code> but only
   through the utilisation of the abstract type. The implementation
   here is not required to be totally generic and the
   function <code>less_or_equal</code> may exploit the characteristics
   of the concrete type <code>t</code>. Here is an example of ordered
   strings for the value of their interpretation in base 256 according
   to the ASCII code of their characters (for example, "ol"
   corresponds to the code \(cod () * 256^2 + cod (o) * 256^1 + cod
   (l) * 256^0\)). This implementation applies a memoization of the
   sum and illustrates a new case where hiding and specification are
   useful:
   <pre class="prettyprint ml">
   module String_ordered = struct
     type t = Str of string * Num.num option ref
     type extern_t = string

     let make s = Str (s, ref None)
     let show (S(s, _)) = s

     let ascii_value s =
       let value = ref (Num.Int 0) and len = (String.length s) - 1 in
       let basis = ref (Num.Int 1) in
       for i = len downto 0 do
         value := Num.add_num !value
               (Num.mult_num !basis (Num.Int (Char.code s.[i])));
         basis := Num.mult_num !basis (Num.Int 256)
       done;
       !value

     let less_or_equal s1 s2 =
       let extract_ascii_value (Str (s, c)) = match !c with
         | None &rarr; let d = ascii_value s in c := Some d; d
         | Some d &rarr; d
       in
       Num.le_num (extract_value s1) (extract_ascii_value s2)
   end;;
   </pre>
   There exist situations when the choice between type parameters and
   abstract types proves more delicate than the above especially when
   these two kinds of parameters combine. For example, consider the
   problem of specifying a datatype for a "production line". That is,
   processes that generate sequentially and on demand, random numbers,
   events of inputs/outputs, happiness of the day etc. Here is the
   first specification:
   <pre class="prettyprint ml">
   module type PRODUCTION_LINE_GEN = sig
     type &alpha; product_line
     val make : unit &rarr; &alpha; product_line
     val read_fst : &alpha; product_line &rarr; &alpha;
     ...
   end;;
   </pre>
   At first glance, nothing seems suspect in this signature that
   resembles those proposed for sequential containers. Nevertheless,
   it is observed that the constructor <code>make</code> must be
   generic even though it is rather to provide a production line of
   particular elements. Indeed, here is an example of a production
   line in the form of a stream that generates random binary sequences:
   <pre class="prettyprint ml">
   module Rand_bin = struct
     type &alpha; product_line = &alpha; stm
     let rec make () =
       Random.self_init ();
       stm_build (fun x &rarr; (Random.int 2)) 0
     let read_fst s = stm_hd s
     ...
   end;;
   </pre>
   This module does not satisfy the
   signature <code>PRODUCTION_LINE_GEN</code> since its constructor is
   obviously not generic being of type:
   <pre class="prettyprint ml">
   val make : unit &rarr; int stm
   </pre>
   The type is less general than specified. Nevertheless, as in the
   case of ordered types, we can replace the type variable with an
   abstract type:
   <pre class="prettyprint ml">
   module type PRODUCTION_LINE = sig
     type data
     type &alpha; product_line
     val make : unit &rarr; data product_line
     val read_first : data product_line &rarr; data
     ...
   end;;
   </pre>
   The <code>Rand_bin</code> module satisfies this signature:
   <pre class="prettyprint ml">
   module Rand_bin : PRODUCTION_LINE = struct
     type data = int
     type &alpha; product_line = &alpha; stm
     let rec make () =
       Random.self_init (); stm_build (fun x &rarr; (Random.int 2)) 0
     let read_fst s = stm_hd s
     ...
   end;
   </pre>
   The signature <code>PRODUCTION_LINE</code> uses here an abstract
   type <code>&alpha; product_line</code> so as to be able to indicate
   a strict relationship between the proudction lines and the data
   they produce. Indeed, in this signature, the type is explicitly in
   the expression <code>data product_line</code>. Here is an
   alternative:
   <pre class="prettyprint ml">
   module type PRODUCTION_LINE' = sig
     type data
     type product_line
     val make : unit &rarr; product_line
     val read_fst : product_line &rarr; data
     ...
   end;;
   </pre>
   The link between <code>data</code> and <code>product_line</code> is
   more precise, and this gives it more latitude : the representation
   of data in the link to the product isn't necessarily the same as
   that seen from the outside. For example, here is a case where the
   definition of the type <code>product_line</code> permits modifiable
   data:
   <pre class="prettyprint ml">
   module Rand_bin : PRODUCTION_LINE' = sig
     type data = int
     type product_line = data ref stm
     ...
   end;;
   </pre>
   </p>
   <p>
   Thus, the elaboration of signatures gives the programmer choices to
   make between universal paramters and abstract types. These should
   in fact be considered as two kinds of parameters in the signatures:
   <br/>
   <br/>
   <b>Difference between type parameters in signatures: </b>
   <ul>
   <li><i>Universal type parameters</i> impose generic
   implementations. Their instantiation is performed automatically by
   the type system.
   <br/>
   <br/>
   </li>
   <li><i>Abstract types</i> do not impose generic
   implementations. Their instantiations are established explicitly
   case by case.
   </li>
   </ul>
   <br/> 
   <br/>
   This distinction makes it possible to specify the level of
   generiticity of programs in signatures. In this respect, the
   preceding examples the general technique following:
   <br/> 
   <br/>
   <b>Mastering the generiticity of a signature:</b> Suppose a
   universal type <code>&alpha;</code> in a signature imposes a
   generic implementation. This parameter is replaced or controlled by
   a new abstract type.
   <br/>
   <br/>
   We will talk again about this delicate point.
  </p>

   <h4>Module inclusion relationships</h4>

   <h5>The inclusion of modules in signatures</h5>
   <p>
   In OCaml, reuse of a module in a module is expressed directly by
   the inclusion of one module in the other. This operation is
   established by the construction syntax following:
   <br/>
   <br/>
   <pre class="prettyprint ml">
   include &lt;Module&gt;
   </pre>
   <br/>
   <br/>

   The elements of the module <code>&lt;Module&gt;</code> are then
   defined in their entirety in the including module. For example,
   consider the following module:
   <pre class="prettyprint ml">
   module Increm = struct
     let f x = x + 1
   end;;
   </pre>
   The module can be included in another:
   <pre class="prettyprint ml">
   module More_than_increm = struct
     include Increm
     let g x = f (x * 10)
   end;
   </pre>
   This is equivalent to the following module definition:
   <pre class="prettyprint ml">
   module More_than_increm = struct
     let f x = x + 1
     let g x = f (x * 10)
   end
   </pre>
   </p>
   <p>
   Signatures also can include others with the same construction:
   <br/>
   <br/>
   <pre class="prettyprint ml">
   include &lt;SIGNATURE&gt;
   </pre>
   <br/>
   <br/>
   As for modules, the elements of <code>&lt;SIGNATURE&gt;</code> are
   declared and defined as part of the signature that includes
   them. For example, consider the signature of the
   module <code>Increm</code> above:
   <pre class="prettyprint ml">
   module type S = sig
     val f : int &rarr; int
   end;;
   </pre>
   The definition of the signature for the
   module <code>More_than_increm</code> can include the
   signatures <code>S</code>.
   <pre class="prettyprint ml">
   module MORE_THAN_S = sig
     include S
     val g : int &rarr; int
   end;;
   </pre>
   This definition is equivalent to the signature:
   <pre class="prettyprint ml">
   module type MORE_THAN_S = sig
     val f : int &rarr; int
     val g : int &rarr; int
   end;;
   </pre>
   The modules defined previously can be typed against these
   signatures:
   <pre class="prettyprint ml">
   module M1 : S = Increm;;
   module M2 : MORE_THAN_S = More_than_increm;;
   </pre>
   <br/>
   <br/>
   <b>The interest in module inclusion : </b> Inclusion facilitates
   the resule of modules. Also, inclusion of modules can reflect the
   inclusion of signatures and in the same way, inclusions of
   signatures can be concretely realized by the inclusion of modules.
   <br/>
   <br/>
   On the other hand, it can be remarked that the version
   of <code>MORE_THAN_S</code> with inclusion expresses explicitly the
   link with the signature <code>S</code> which is not the case for
   the version without inclusion. In other words:
   <br/>
   <br/>
   <b>The interest in signature inclusion : </b> Inclusion facilitates
   resuse of signatures. Also, inclusion of signatures allows for the
   specification of links between reutilized modules.
   <br/>
   <br/>
   </p>

   <h5>Inclusion for inheritance</h5>
   <p>
   Inclusion offers a direct means to extend and specialize existing
   modules and signatures. For example, consder a new implementation
   of complex numbers:
   <pre class="prettyprint ml">
   module Complex = struct
     type complex = float * float
     let make (r, i) = (r, i)
     let add (r1, i1) (r2, i2) = make (r1 +. r2, i1 +. i2)
     let norm (r, i) = sqrt (r ** 2. + i ** 2.)
   end;
   </pre>
   The module can easily be extended by inclusion:
   <pre class="prettyprint ml">
   module Complex_ext = struct
     include Complex;
     let mul (r1, i1) (r2, i2) =
       (r1 *. r2 -. i1 *. i2, i1 *. r2 + i2 *. r1)
   end;;
   </pre>
   <br/>
   <br/>
   <b>Module inheritance is implemented by inclusion:</b> One includes
   globally a module in another module and then extends, specializes
   or adapts.  
   <br/>
   <br/>
   On the other hand, here is a possible signature of
   the <code>Complex</code> module:
   <pre class="prettyprint ml">
   module type COMPLEX = sig
    type complex
    val make : float * float &rarr; complex
    val add : complex &rarr; complex &rarr; complex
    val norm : complex &rarr; float
   end;;
   </pre>
   A signature for the module <code>Complex_ext</code> can be directly
   derived by inclusion:
   <pre class="prettyprint ml">
   module type COMPLEX_EXT = sig
     include COMPLEX
     val mul : complex &rarr; complex &rarr; comples
   end;;
   </pre>
   Observe that the signature <code>COMPLEX_EXT</code> is compatible
   with <code>COMPLEX</code>:
   <pre class="prettyprint ml">
   # module C1 : COMPLEX = Complex_ext ;;
   module C1 : COMPLEX

   # module C2 : COMPLEX_EXT = Complex _ext ;;
   module C2 : COMPLEX_EXT
   </pre>
   <br/>
   <br/>
   <b>The behavior of module inheritance by inclusion : </b> One
   includes a signature <code>S1</code> in another
   signature <code>S2</code> to extend, specialize or
   adapt. Additionally, <code>S2</code> is compatible
   with <code>S1</code> (assuming no reclarations).
   <br/>
   <br/>
   Evidently, in the context of information hiding, the extending
   module cannot change the access privilege of the modules it
   includes, it will use the constructors and accessors previously
   defined. So, for example, let us suppose there is a
   module <code>Complex</code> that satisfies the following signature:
   <pre class="prettyprint ml">
   module type COMPLEX_MASK = sig
     type complex
     val make : float * float &rarr; complex
     val show : complex &rarr; float * float
     ...
   end;;
   </pre>
   An extension can be written using the accessors <code>make</code>
   and <code>show</code>:
   <pre class="prettyprint ml">
   module Complex_ext = struct
     include Complex
     let mul z w =
      let (r1, i1) = show z and (r2, i2) = show w in
      make (r1 *. r2 -. i1 *. i2, i1 *.r2 +. i2 *. r1)
   end;;
   </pre>
   This example shows that we can begin to examine the question "the
   dimensions of extensibility of types" for the case of abstract
   types. In particular, inclusion makes it easy to extend functions
   associated with a type and in a module framework with rigourous
   information hiding. We will treat later the case of the extension
   of representation of values. For now, we comment that "functors"
   are able to make generic these extensions.
   </p>

   <h5>Inclusion for inheritance</h5>
   <p>
   Inclusion also allows us to adapt existing modules and signatures :
   one redefines, one renames, one sometimes transforms elements
   module elements as necessary to obtain the extension. For example,
   let us reconsider the signature <code>ARITH</code>:
   <pre class="prettyprint ml">
   module type ARITH = sig
     type nb                        type nb_extern
     val make : extern_nb &rarr; nb     val show : nb &rarr; nb_extern
     val zero : nb                  val one : nb
     val add : nb &rarr; nb &rarr; nb       val sub : nb &rarr; nb &rarr; nb
     val mul : nb &rarr; nb &rarr; nb       val div : nb &rarr; nb &rarr; nb
   end;;
   </pre>
   Certain modules of the OCaml standard library are not far off being
   instances of this signature. However, the modules make use of the
   naming tactic where the representation of values is denoted by
   the <code>t</code> (the "strong algebraic" tactic) and do not apply
   the same conventions with respect to information hiding. We can use
   inclusion to make it easy to remedy this situation. For example,
   consider the case of the module <code>Int64</code> of the standard
   library which implements a datatype associated with whole numbers
   modulo \(2^{64}\) (that is, numbers in the range \([-2^{63}, 2^{63}
   - 1]\)). Here is how to adapt it such that it satisfies
   the <code>ARITH</code> signature:
   <pre class="prettyprint ml">
   module Arith_Int64 : ARITH  type nb_extern = string = 
   struct
     include Int64
     type nb = Int64.t (*rename type*)
     type extern_nb = string
     let make = of_string (*alias*)
     let show = to_string
   end;;

   # Arith_Int64.make "1000000000000000000000";;
   - : Arith_Int64.nb = &lt;abstr&gt;
   </pre>
   Note that is quite possible to include modules and revise some of
   their definitions. Adaption by inclusion can also benefit
   redefinitions of values and functions. However, there is a limit to
   such redefinitions : if there are mutual uses between functions
   contained in the module, if if a redefinition is applied between
   one of them, there will be no automatic update of their
   relation. In other words, the redefinitions do not incorporate a
   "delayed link" mechanism. For example:
   <pre class="prettyprint ml">
   module M = struct
     let f x = x + 1000
     let g x = (f x) + 1
   end;

   module Modified_M = struct
     include M
     let f x = x
   end;;
   </pre>
   The redefinition of <code>f</code> does not affect the definition
   of <code>g</code>:
   <pre class="prettyprint ml">
   # Modified_M.f 0 ;;
   - : int = 0

   # Modified_m.g 0 ;;
   - : int = 1001
   </pre>
   In the module framework, the programmer is in charge of assuring
   the cohesion of elements from the point of view of any
   redefinition. On the other hand, redefinitions may induce errors
   when they are not delibrate. This situation is all the more likely
   when modules are large and inclusions numerous. Generally,
   inclusions imply a pooling of definitions which provides
   opportunities for incoherencies. The following section introduces
   another means of expressing importations of modules end signatures
   that is more constrained and structured.
   </p>

   <h4>Module containment relations</h4>

   <h5>Containment of modules</h5>

   <p>Modules may embed other modules. We call this containment of
   modules and <i>parent-module</i> the module which contains others
   and those contained modules <i>sub-modules</i> of the parent
   module. Recall the earlier example:
   <pre class="prettyprint ml">
   module Increm = struct
     let f x = x + 1
   end;;
   </pre>
   A new module emerges from a sub-module in the other:
   <pre class="prettyprint ml">
   module More_than_increm = struct
     module Sub = Increm
     let g x = Sub.f (x * 10)
   end;;
   </pre>
   Contrary to inclusion of modules, containment respects the
   partitioning of the modules. They do not put all the definitions at
   the same level and they therefore do not imply unqualified
   redefinitions.
   </p>

   <h5>Opening of modules</h5>

   <p>
   Containment of modules must be compared to another construction
   that acts equally within the framework of links between
   modules. Using contained modules implies indirections "pointer
   notation". Sometimes this constraint seems to excessively increase
   the verbosity of programs especially when module names are very
   explicit. So, the language provides the means to "open" a module so
   that the names of the elements are directly addressable. It
   suffices to make this happen with the following directive:
   <br/>
   <pre class="prettyprint ml">
   open &lt;Module&gt;
   </pre>
   <br/> The elements conainted in <code>&lt;Module&gt;</code> are
   then accessible at the level of the the occurence of
   the <code>open</code> directive. No indirections are required.
   </p>
   <p>For example, consider a new module <code>Increm</code> opened in
   another module.
   <pre class="prettyprint ml">
   module More_than_increm = struct
     open Increm
     let g x = f (x * 10)
   end;;
   </pre>
   This is equivalent to the module definition:
   <pre class="prettyprint ml">
   module More_than_increm = struct
     let g x = Increm.f (x * 10)
   end;;
   </pre>
   </p>
   <p>
   Contrary to inclusion and containment, opening of modules does not
   produce any new definitions : it operates only on the space of
   identifiers. However, suppose there is an <code>x</code> valid at
   the point of application of an open directive of a
   module <code>M</code>; if <code>x</code> is also the name of an
   element of <code>M</code>, the open implies an irreversible
   redefinition of <code>x</code>. Consequently, as for inclusion,
   opens may involve name complications delicate to organise.
   </p>
   <p>
   For example, the modules <code>List</code>, <code>Array</code>
   and <code>Stack</code> from the sandard library have in common a
   certain number of functions with the same names. In the module
   following, the opening of these three modules will define a
   function <code>last</code> that gives rise to a type error:
   <pre class="prettyprint ml">
   # module M = struct
       open List
       open Stack
       open Array
       let last lin = nth lin ((length lin) - 1)
     end;;
    Type error
   </pre>
   Indeed the function <code>nth</code> is provided by
   the <code>List</code> module, but the <code>length</code> function
   has come from the <code>Array</code> module to which is
   applied <code>last</code>. The suite of module opens is ordered
   differently than required for a correct version:
   <pre class="prettyprint ml">
   # module M = struct
       open Stack
       open Array
       open List
       let last lin = nth lin ((length lin) - 1)
     end;;
   </pre>
   <br/>
   <br/>
   <b>The technique of openings transformed into sub-modules:</b> Any
   opening of a sub-module <code>M</code> can be replaced by an
   explicit import of <code>M</code> as a sub-module.
   <br/>
   <br/>
   Note that there exists a derivative of this technique. If
   utilisation of a module can be restrained to a simple expression
   such as a function body, it is possible to consider a local module
   . For example:
   <pre class="prettyprint ml">
   module M = struct
     let last lin =
       let module L = List in
       L.nth lin ((L.length lin) - 1)
   end;;
   </pre>
   On the other hand, opening a module possesses another important
   inconvenience : they are not representable at the level of the
   specification. We have seen that this is the case for inclusions
   and will now discover it for nesting.
   </p>

   <h5>Embedding in signatures : abstract sub-modules</h5>
   <p>
   Signatures also lend themselves to the embedding of modules. A
   signature can declare modules by the aid of the following
   construction:
   <pre class="prettyprint ml">
   module type ... = sig
     ...
     module &lt;Name&gt; : &lt;SIGNATURE&gt;
     ...
   end
   </pre>
   The notation is similar to the declaration of values in a signature
   e.g. <code>val &lt;name&gt; : &lt;type&gt;</code>. For example,
   here is a signature for the module <code>More_than_increm</code>:
   <pre class="prettyprint ml">
   module type S = sig
     val f : int &rarr; int
   end;;

   module type MORE_THAN_S = sig
     module Sub : S
     val g : int &rarr; int
   end;;
   </pre>
   These declarations of sub-modules in signatures are reminiscent of
   abstract types. We will therefore name them here in accordance of
   this recollection:
   <br/>
   <br/>
   <b>Definition : </b> In a signature, a simple type declaration of
   the name of a sub-module is called an abstract sub-module.
   <br/>
   <br/>
   </p>

   <h5>The link between signatures and abstract sub-modules</h5>
   <p>
   As in the case of the inclusion of signatures, an abstract
   sub-module permits the declaration of a link between modules at the
   level of a specification. The embedding also makes possible
   description of the particular relationships between elements of the
   sub-module and parent module. Consider this example derived from
   one preceding:
   <pre class="prettyprint ml">
   module type S = sig
     type t
     val f : t &rarr; t
   end

   module type MORE_THAN_S = sig
     module Sub : S
     val g : Sub.t &rarr; Sub.t
   end
   </pre>
   Here, the links between the instances of <code>S</code> and those
   of <code>MORE_THAN_S</code> concretely express the way types are
   used : the function <code>g</code> is based on a type provided
   by <code>Sub</code>. We have therefore increased the precision of
   the signature <code>MORE_THAN_S</code> such that thte
   function <code></code> must be linked to an abstract type described
   by <code>S</code>. Therefore a function <code>g</code> can always
   be based on a function <code>f</code> associated with its type
   by <code>S</code>. Generalizing:
   <br/>
   <br/>
   <p>Interest in abstract sub-modules : </p> Abstract sub-modules of
   a signature <code>S</code> declare the names of modules whose
   elements are usuable for the types of other elements
   in <code>S</code>. They also specify links of reutilization between
   modules, and this without being dependent on the particulars of
   implementations of modules.
   <br/>
   <br/>
   We also talk sometimes of <i>abstraction composition</i>. Here is
   an example less formal than the preceding:
   <pre class="prettyprint ml">
   module type SET = sig
     type &alpha; set
     val empty : unit &rarr; &alpha; set
     val mem : &alpha; &rarr; &alpha; set &rarr; bool
     val add : &alpha; &rarr; &alpha; set &rarr; unit
     ...
   end;
   </pre>
   One proposed implementation, the module <code>Set_H</code> -- makes
   use of a hash table from the standard library. Suppose suche hash
   tables are specified by means of the
   signature <code>HASH_TABLE</code>. It is then possible to give
   oneself a new signature which imposes on the representation of sets
   that they be an implementation of <code>HASH_TABLE</code>:
   <pre class="prettyprint ml">
   module type SET_HASH = sig
     module H : HASH_TABLE
     type &alpha; set = &alpha; H.t
     val empty : unit &rarr; &alpha; set
     val mem : &alpha; &rarr; &alpha; set &rarr; bool
     val add : &alpha; &rarr; &alpha; set &rarr; unit
     ...
   end;;
   </pre>
   This constraint in the specficiation indicates that any
   implementation of <code>SET_HASH</code> benefits a priori the
   properties of hash tables. In particular, access to the elements of
   a set will have constant complexity. On the other hand, variations
   of the instantiation of the type <code>&alpha; set</code>'s masking
   conventions will be delegated to the sub-modules <code>H</code>.
   </p>
   <p>
   This example illustrates how use of abstract sub-modules may remedy
   some of the limitations we spoke of earlier of signatures : thanks
   to them, it is possible to integrate greater precision into a
   specification. On the other hand, note the
   signature <code>SET_HASH</code> is compatible with the
   signature <code>SET</code> : any module that
   satisfies <code>SET_HASH</code> equally well
   satisfies <code>SET</code>. As in the case of signature inclusion,
   we specified here very naturally, compatible specializations.
   </p>
   <p>
   Here is an abstract of the technique we have presented:
   <br/>
   <br/>
   <b>Technique of specication of a signature by abstract sub-modules
   : </b> Any module <code>M</code> with signature <code>S</code>
   using modules <code>M1</code>, <code>M2</code>,
   ..., <code>Mn</code> may induce a specialized
   signature <code>S_PLUS</code>:
   <ol>
   <li>In <code>S_PLUS</code> we declare <code>M2</code>,
   ..., <code>Mn</code> as abstract sub-modules.</li>
   <li>The elements of <code>S_PLUS</code> rely on the elements of the
   signatures of the abstract sub-modules.</li>
   </ol>
    The signature <code>S_PLUS</code> is rendered compatible
   with <code>S</code>.
   <br/>
   <br/>
   This technqiue permits also, systematic expression of the links
   between modules at the level of signatures. The advantages of this
   follow:
   <br/>
   <br/>
   <b>The advantages of specialization of signatures :</b>
   <ol>
   <li>Help refining type inference, enriched analysis of the module
   components, to give information to the programmer.</li>
   <li>Aid to the programmer in understanding the logical architecture
   since the relevant signatures are already part of the interactions
   between components.</li>
   </ol>
   <br/>
   <br/>
   </p>

   <h5>Abstract sub-modules and inclusion constraints</h5>
   <p>
   The specialization of signatures facilitates the possibilty of
   directly constraining an inclusion by the following syntax:
   <pre class="prettyprint ml">
   include &lt;SIGNATURE&gt; with type &lt;type 1&gt; = &lt;expression of type 1&gt;
                             and type ...
                             and type&lt;type n&gt; = &lt;expression of type n&gt;
   </pre>
   Recalling the example of the preceding section, suppose a general
   signature <code>SET</code> with a pre-existing specialization. It
   is possible to obtain that specialization directly with an
   inclusion constraint:
   <pre class="prettyprint ml">
   module type SET_HASH = sig
     module H : HASH_TABLE
     include SET with type &alpha; set = &alpha; H.t
   end;
   </pre>
   The type constraint here is particular : it deals only with
   abstract types. Indeed, the type constraints of the preceding pages
   always used a term on the right denoting a type duly defined. While
   being abstract, the type <code>&alpha; H.t</code> is nevertheless part
   of the environment; it may also therefore contribute to the
   definition of a type.
   <br/>
   <br/>
   <b>Definition : </b> When a type constraint consists entirely of
   abstract types, these types are called <code>sharing types</code>.
   <br/>
   <br/>
   We have seen other occurences of this notion.
   </p>

   <h5>Hiding the types of sub-modules</h5>
   <p>
   The existence of module embedding neccessitates a clarification of
   the effect of explicit typing by signature. The rule follows:
   <br/>
   <br/>
   <p><b>Rule (3) of visibility of a module (precision) : </b> The
   effects of a valid explicit typing of <code>M</code> apply
   individually to the sub-modules of <code>M</code>.  
   <br/>
   <br/> 
   In consequence, suppose a module <code>M1</code> contained in a
   module <code>M2</code> : while the type of <code>M2</code> is
   explicit and valid, the implementation of the abstract types
   of <code>M1</code> are hidden. For example:
   <pre class="prettyprint ml">
   module type S1 = sig
     type t
     val cst : t
   end;;

   module type S2 = sig
     module Sub : S1
     val f : Sub.t &rarr; Sub.t
   end;;

   module M1 = struct
     type t = int
     let cst = 3
   end;;

   module M2 : S2 = struct (*explicitly typed*)
     module Sub = M1
     let f x = Sub.cst + x
   end;;
   </pre>
   The explicit typing of <code>M2</code> by <code>S2</code> implies
   it is the parent of a sub-module <code>Sub</code> - and
   so <code>M1</code> - is also subject to the rule of hiding:
   <pre class="prettyprint ml">
   # M2.Sub.cst;;
   - : M2.Sub.t = &lt;abstr&gt;

   # M2.f 1;;
   Type error
   </pre>
   The type of the constant contained in <code>Sub</code> is hidden
   even though it would come from the module <code>M1</code> which
   exported its initial definition.
   </p>
   <p>
   So, individualized masking is sometimes established on elements of
   sub-modules by using the construction <code>with type</code>. For
   example:
   <pre class="prettyprint ml">
   module M2 : S2 = 
     with type Sub.t = int = struct
     module Sub = M1
     val f x = Sub.cst + x
   end;;

   # M2.f 1;;
   - : M2.Sub.t = 4
   </pre>
   </p>
   <p>
   In the case of sub-modules possessing multiple types, and for
   additional clarity, the exists an equivalent
   construction <code>with module</code>:
   <pre class="prettyprint ml">
   &lt;SIGNATURE&gt; with module &lt;module 1&gt; = &lt;expression of module 1&gt;
                     and module ...
                     module &lt;module n&gt; = &lt;expression of module n&gt;
   </pre>
   where the <code>&lt;module i&gt;</code> denotes a sub-module within
   the signature <code>&lt;SIGNATURE&gt;</code> and
   the <code>&lt;expression of module i&gt;</code> are the valid
   definitions of modules in the environment at the moment of
   application of the type constraint. This construction iss in fact
   only an abbreviation of the set of constraints <code>with
   type</code> associated with all of the types appearing in
   the <code>&lt;expression of module i&gt;</code>. So, the following
   version of module <code>M2</code> is equivalent to the earlier one:
   <pre class="prettyprint ml">
   module M2 : S2 = 
     with module Sub = M1 =
   struct
    module Sub = M1
    let f x = Sub.cst + x
   end;;
   </pre>
   The masking with a structuring in sub-modules therefore requires a
   certain rigor under pain of lots of unnessary type
   errors. Recalling the example where explicit typing of a module by
   a signature may be rendered unuable if there has been no masking
   preperation, that is to say, if the constructors and accessors have
   not been forseen. In fact, a systematic approach to masking
   simplifies the reasoning. Thus, here is a precise statement
   concerning modular programming with "rigorous masking":.
   <br/>
   <br/>
   <b>Modular programming with rigorous masking (precision): </b> Any
   module is explicitly typed by a signature. The
   construction <code>with module</code> are applied to the
   sub-modules whose export is necessary.  <br/> <br/> As masking is
   irreversible, a construction <code>with module</code> on hidden
   types will only have influence on its public elements. By applying
   a rigorous masking, it is sufficient to ask at the level of each
   module whether its types or its sub-modules must be exported or
   not. The complexit of embeddings will not affect the complexity of
   the decisions to be taken concerning exports.
   </p>

   <h5>Flattening the nesting of modules</h5>
   <p>
   Despite their simplicity, the preceding examples illustrate again a
   phenomon which may become inconvenient when module embeddings are
   numerous. For example, the complete name of the type <code>t</code>
   in the module <code>M2</code>, that is to
   say, <code>M2.Sub.t</code>, reflects the complete embedding
   structure of the modules. In order to mitigate this effect, one
   redefines certain elements of abstract sub-modules to the level of
   the signature. It is then possible to "flatten" the level of
   embedding in a manner visible from the exterior of the module. For
   example:
   <pre class="prettyprint ml">
   module type S1 = sig
     type t
     val f : t &rarr; t
   end;;

   module type S2 = sig
     module Sub : S1
     type t = Sub.t
     val g : t &rarr; t
   end;;
   </pre>
   Here, the type <code>t</code> of <code>Sub</code> is replaced at
   the level of the signature <code>S2</code>. That signature includes
   from there on, the type as part of its entirity.
   </p>
   <p>
   This technique permits therefore establishing a partial inclusion
   of another module. It is crucial for making an intuitively
   structured structuring of sub-modules.
   </p>

   <h5>Modular aggregation of data-types</h5>
   <p>
   The use of sub-modules gives us leave to consider datatypes whose
   representation of values depend directrly on other datatypes. We
   have in fact already applied this idea: the
   signature <code>SET_HASH</code> indicates that the representation
   of set values be based on hash tables. Here is another example in
   the same vein. Let us propose a generalized version of an event
   loop capable of processing a set of graphic computations. This set
   will be structure in terms of association tables which we specify
   by means of the signature <code>ASSOC_TABLE</code>. The precise
   specification of the the datatype adapted to graphics interactions
   is thus the following:
   <pre class="prettyprint ml">
   module type GRAPHIC_ENVIRONMENT = sig
     module T : ASSOC_TABLE
     type action = int &rarr; int &rarr; unit (*fixed for simplicity*)
     type behaviors = (char, action) T.assoc
     val empty : unit &rarr; behaviors
     val add : char &rarr; action &rarr; behaviors &rarr; behaviors
     val interaction_with_mouse : behaviors &rarr; unit
   end;;
   </pre>
   The form of the datatype is classic except for the fact that the
   representation of the values of <code>behaviors</code> is a type
   directly dependent on the abstract sub-module <code>T</code>. A
   requirement on implementations is thus clearly expressed in this
   signature: graphics environments are necessarily association
   tables. To instantiate a <code>GRAPHIC_ENVIRONMENT</code>, one
   may reutilize and combine an implementation of events (given in an
   earlier chapter in the book this has been copied from) the the
   implementation <code>Assoc_tree</code> of association tables based
   on red-black trees:
   <pre class="prettyprint ml">
   module G_env : GRAPHIC_ENVIRONMENT = struct
     module T = Assoc_rbtree
     module G = Graphics (*an internal renaming*)
     type action = int &rarr; int &rarr; unit
     type behaviors = (char, action) T.assoc

     let empty () = T.empty ()

     let add key action l = T.add key action l

     let interaction_with_mouse l =
       let action_state = ref (snd (T.get_pair l)) in
       while true do
         let s = G.wait_next_event [Button_down; Key_pressed] in
         if s.button then ! action_state s.mouse_x s.mouse_y
         else if s.keypressed then
         try
           action_staett := T.assoc l s.key
         with
           | Not_found &rarr; ()
       done
   end;;
   </pre>
   It is then possible to create specific graphics interaction loops:
   <pre class="prettyprint ml">
   # let g1 = G_env.empty ();;
   val g1 : G_env.behaviors = &lt;abstr&gt;

   # let g1 = G_env.add 
             'l' (fun x y &rarr;
                    if x < 30 && y < 30 then failwith "Exit"
                    else if current_point () = (-1, -1)
                    them moveto x xy else lineto x y)
              g1;;
   val g1 : G_env.behaviors = &lt;abstr&gt;

   # let interaction_loop_1 () = G_env.interaction_with_mouse g1;;
   val interaction_loop_1 : unit &rarr; unit
   </pre>
   The relation between the graphics environments and association
   tables here illustrates a particular point: the management of the
   specific type of <code>ASSOC_TABLE</code> is completely in the
   charge of the type described for <code>G_env</code>. No use of
   module <code>Assoc_rbtree</code> is required from the outside : the
   module <code>G_env</code> alone creates and manipulates the
   association table. As such, the explicit typing of the
   module <code>G_env</code> need not constrain the association table
   type provided by <code>T</code>.
   </p>
   <p>
   The relation between the two datatypes may be characterised by the
   following:
   <br/>
   <br/>
   <b>Definition :</b> Suppose that<code>M_sub</code>
   and <code>M</code> describe abstract datatypes and
   that <code>M_sub</code> is a sub-module in <code>M</code>. We
   say <code>M</code> is an <i>aggregation module</i> if it manages
   completely the instances of type provided by <code>M_sub</code>.
   <br/>
   <br/>
   </p>

   <h5>Modular associations of datatypes</h5>
   <p>
   The notion of module aggregation that we have just described has of
   course a less binding version:
   <br/>
   <br/>
   <b>Definition :</b> Suppose that <code>M_sub</code>
   and <code>M</code> describe abstract datatypes and
   that <code>M_sub</code> is a sub-module of <code>M</code>. We say
   that <code>M</code> is an <i>association module</i> if the
   management of the instances of the type provided
   by <code>M_sub</code> are not completely under the charge
   of <code>M</code>.
   <br/>
   <br/>
   Another way of saying this, the exploitation of the
   module <code>M_sub</code> remains explicit (at least in part) for
   use of module <code>M</code>. For example, reconsider first of all
   a version of the signature <code>COMPLEX</code>:
   <pre class="prettyprint ml">
   module type COMPLEX = sig
     type complex
     type extern_complex
     val make : extern_complex &rarr; complex
     val show : complex &rarr; extern_complex
     val zero : complex  val one : complex
     val add : complex &rarr; complex &rarr; complex
     val mul : complex &rarr; complex &rarr; complex
     val norm : complex &rarr; float
   end;;
   </pre>
   Here, a specialization which succinctly describes a type associate
   with functions of complex numbers:
   <pre class="prettyprint ml">
   module type COMPLEX_FUN = sig
     module C : COMPLEX
     type fun_t
     type extern_fun_t
     val make : extern_fun_t &rarr; fun_t
     val apply : fun_t &rarr; C.complex &rarr; C.complex
     val apply : fun_t &rarr; C.Complex &rarr; C.complex
     val iterate : fun_t &rarr; int &rarr; C.complex &rarr; C.complex
   end;;
   </pre>
   Apart from nesting an implementation of <code>COMPLEX</code>, the
   signature specifies a priori any function which would be likely to
   create or manage complex numbers for themselves. Consequently,
   these will necessarily come from the instance of the
   sub-module <code>C</code>. Another way of saying this is the use
   and the management of complex number is not transparent to the the
   use of the the functions of a module that
   satisfies <code>COMPLEX_FUN</code>: we are indeed in one case of a
   module association. For example, here first of all an implemenation
   based on a simple instance of <code>COMPLEX</code>:
   <pre class="prettyprint ml">
   module Complex_F1 : COMPLEX
     with type extern_complex = float * float = 
   struct
     type complex = float * float
     type extern_complex = complex
     let make (r, i) = (r, i)
     let show (r, i) = (r, i)
     let zero = (0., 0.)
     let one = (1., 0.)
     ...
   end;;

   module CFuns : COMPLEX_FUN
     with type extern_fun_t = Complex_F1.complex &rarr; Complex_F1.complex
     with module C = Complex_F1 =
   struct
     module C = Complex_F1
     type fun_t = Fun of (C.complex &rarr; C.complex)
     type extern_fun_t = Complex_F1.complex &rarr; Complex_F1.complex

     let make f = Fun f
     let apply (Fun f) z = fz
     let rec iterate (fun f) n z =
       if n < 1 then z else iterate (Fun f) (n - 1) (f z)
   end;;
   </pre>
   The use of the module <code>C</code> can be carried out through the
   use of the module <code>CFuns</code>:
   <pre class="prettyprint ml">
   # let z1 = Complex_F1.make (2., 0.);;
   val z1 : Complex_F1.complex = &lt;abstr&gt;

   # let sqr = CFuns.make (fun z &rarr; Complex_F1.mul z z);;
   val z2 : CFuns.fun_t = &lt;abstr&gt;

   # Complex_F1.show (CFuns.apply sqr z1);;
   - : Complex_F1.extern_complex = (4., 0.)
   </pre>
   The utilisation may equivalently be carried from a
   sub-module <code>C</code> of <code>CFuns</code>:
   <pre class="prettyprint ml">
   # let z1 = CFuns.C.make (2., 0.);;
   val z1 : CFuns.C.complex = &lt;abstr&gt;

   # CFuns.C.show z1;;
   - : CFuns.C.extern_complex = (2., 0.)
   </pre>
   However, the user is still in the situation of having to create and
   manage the complex numbers. On the other hand, the type
   constraint <code>with module C = Complex_F1 ...</code> necessarily
   associates with <code>CFuns</code>. Indeed, the distinction between
   module aggregation and association is characterized by the module
   headers during the application of rigorous masking:
   <br/>
   <br/>
   <b>Criterion for the use of type constraints :</b> A module
   aggregation does not require a type constraint <code>with
   module</code> with regards to sub-module embedding. In contrast, a
   module association generally requires one.  <br/> <br/> Here is
   another implementation of <code>COMPLEX_FUN</code> which
   illustrates how the signature may be instantiated differently under
   the same module association conditions. The functions on complex
   numbers can be specialized to polynomials. We will represent them
   here by list of pairs (cofficient/powers of the indeterminate). So,
   for example $p(z) = (1 + i)z^{3} + (2 + i)z + (3 + i)$ is
   represented as:
   <pre class="prettyprint ml">
     p = [((1., 1.), 3); ((2., 1.), 1); ((3., 1.), 0)]
   </pre>
   <pre class="prettyprint ml">
   module CPolynom : COMPLEX_FUN
     with type extern_fun_t = (Complex_F1.complex * int) list
     with module C = Complex_F1 =
   struct
     module C = Complex_F1
     type fun_t = Fun of (C.complex &rarr; C.complex)
     type extern_fun_t = (C.complex * int) list

     let apply (Fun f) z = f z
 
     let rec iterator (Fun f) n z =
       if n < 1 then z else iterator (Fun f) (n - 1) (f z)

     let power z0 n =
       iterate (Fun (fun z &rarr; C.mul z z0)) n C.one

     let make coeflist =
       Fun (fun z &rarr; (List.fold_right
                       (fun (x, y) &rarr; C.add v (C.mul x (power z y)))
                       coeflist C.zero))
   end;;
   </pre>
   So, for example:
   <pre class="prettyprint ml">
   # let z1 = Complex_F1.make (2., 0.);;
   val z1 : Complex_F1.complex = &lt;abstr&gt;

   # let p1 = CPolynom.make [(z1, 2)];;
   val p1 : CPolynom.fun_t = &lt;abstr&gt;

   # Complex_F1.show (CPolynom.apply p1 z1);;
   - : Complex_F1.extern_complex = (8., 0.)
   </pre>
   </p>

   <h5>A complete example : "apple-men"</h5>
   <p>
   An abstract datatype may involve more several types in its
   representation of values. For example, an "apple-man" set (a kind
   of Mandlebrot set) associates a function $f(z_{1}, z_{2})$ of
   complex numbers and consists of all values $c$ such that the
   iterations $f(c, 0)$ do not diverge to infinity. In more precise
   terms, this set is defined as: \[ \{c \in \mathbb{C}\;|\;\lim_{n
   \to \infty}\|f^{n}(c, 0)\| \ne \infty\} \] To implement a program
   that permits the study of these "apple-men" sets makes natural use
   of theree datatypes : complex numbers, their functions and their
   sets. By reconsidering the signature <code>COMPLEX_FUN</code> and
   the signature <code>SET</code>, a minimal signature which specifies
   a type for "apple-men" sets follows (we utilise here lableled
   parameters for precision of the constructor):
   <pre class="prettyprint ml">
   module type APPLE_MEN = sig
     module CF : COMPLEX_FUN
     module S : SET
     type complex = CF.C.complex
     type complex_fun = CF.fun_t
     type set_elements
     type apple_man = set_elements S.set
     val make : f_c : (complex &rarr; complex_fun) &rarr;
                      diverg_ball : float &rarr;
                      max_iter : int &rarr; int
                      size : int &rarr;
                      start : float &rarr;
                      apple_man
   end;;
   </pre>
   The principle type <code>apple_man</code> described here is an
   "apple-man" set according to the definition depending on the
   signature <code>SET</code>. The constructor <code>make</code> takes
   a function parameter <code>f_c</code>$= f (c, .)$, and the
   divergencewill be established experimantally by observing the
   values after <code>max_iter</code> iterations of <code>f_c
   (0)</code>: if a value obtained exceeds <code>diverg_ball</code>,
   then the function is assumed to have diverged. The
   parameters <code>size</code> and <code>start</code> will make it
   possible to define the discretisation of the complex plane where
   the analysis will take place, that is to say a grid of points of
   the size of the square <code>[-start,
   start]</code>$\times$<code>[-start, start]</code>. Given this
   specification, we can thus for example, reuse the polynomials
   of <code>CPolynom</code> and the sets of <code>Set_H</code> in an
   imperative version. Then, an implementation of the
   signature <code>APPLE_MEN</code> made possible is provided in the
   following:
   <pre class="prettyprint ml">
   module A : APPLE_MEN 
     with type set_elements = int * int
     and module CF = CPolynom
     and module S = Set_H =
   struct
     module CF = CPolynom
     module S = Set_H
     type complex = CF.C.complex
     type complex_fun = CF.fun_t
     type set_elements = int * int
     type apple_man = set_elements S.set
 
     let make ~f_c ~diverge_ball ~max_iter ~size ~start =
       let rec diverg f z n =
         let z' = CF.apply f z in
         if CF.C.norm z > diverge_ball then true else
         if n >= max_iter then false
         else diverg f z' (n + 1) in
       let start2 = (start *. 2.) /. (float size) in
       let origin =  CF.C.zero in
       let set = S.empty () in
       let arr = Array.make size 0. in
       for i = 0 to size - 1 do
         arr.(i) <- -.start +. ((float i) *. start2) done;
       done;
       for i = 0 to size - 1 do
         for j = 0 to size - 1 do
           let z = (CF.C.make (arr.(i), arr.(j))) in
           let f = f_c z in
           if not (diverg f origin 0) then S.add (i, j) set
         done
       done;
       set
   end;;
   </pre>
   In the header of the module, the two constraints <code>with module
   = ...</code> indicate each module association from the point of
   view of <code>CF</code> and <code>S</code>. The
   constraint <code>with type set_elements = ...</code> of the
   principal abstract type of the "apple-man"
   sets <code>set_elements</code> are represented externally as
   coordinate indicies of the whole (implicitly derived from a regular
   discretization of a square domain of the plane).
   </p>
   <p>
   Here for example, the expression which constructs one "apple-man"
   of $f(c, z) = z^{4} + z^{2} + c$ for a grid $300 \times 300$ of the
   domain <code>[-1.5, 1.5]</code>$\times$<code>[-1.5, 1.5]</code>:
   <pre class="prettyprint ml">
   # let bonze = 
       A.make ~f_c:(fun c &rarr; CPolynom.make [(Complex_F1.one, 4);
                                            (Complex_F1.one, 2);
                                            (c, 0)])
              ~diverg_ball:100.00 ~max_iter:10 ~size:300 ~start:1.5;;
   val bonze : A.apple_man = &lt;abstr&gt;
   </pre>
   </p>

   <h4>Masking of types in question</h4>

   <h5>The choice to mask</h5>
   <p>
     In OCaml, the attraction of exporting types is great. Their
     instances are directly visible and accessible, the constructors
     and sum types and their field accessors of records are
     available. Instances of these types may benefit from pattern
     recognition and filtering at any point in the program. Moreover,
     no difficulties of masking need to be overcome and no type
     constraints are required in the signatures.
   </p>
   <p>
   However, the definitions of types constitute entirely a choice of
   implementation. Made public, they are likely to be diffused
   throughout the program, breaking the partitioning between
   components and by the same token, most of the expected qualities of
   a modular architecture. After the preceding examples, we can in
   fact express how the masking remedies this and summarize the
   discussion with full knowledge of the facts:
   <br/>
   <br/>
   <b>Advantages of masking :</b> Masking stops the dissemination of
   implementation choices. Refactoring, extensions and testing are
   facilitated, circumscribed and localized. The "principle of module
   substitutivity" may apply in these conditions.
   <br/>
   <br/>
   Masking is also part of a good general programming practice:
   <br/>
   <br/>
   <b>Masking and programming :</b> A program with rigorous masking
   requires a global and fine use of signatures. It is the reflection
   of a precise work of analysis of the partitions between components,
   their links and the types they contribute. On the other hand, in
   OCaml this work can be partially verified by the type system.
   <br/> <br/> We have shown here how to obtain a rigorous masking
   while preserving the possibilities of specifying and realizeing a
   network of relations between the modular components. Of course, its
   implementation includes requirements that are not neglible:
   <br/>
   <br/>
   <b>Inconveniences of masking :</b> Masking imposed written burdens
   (such as for example, the use of accessors, constructors, make-up
   types, type constraints), and is not without impact on the speed of
   execution of a program (in particular, data access passes through
   at least one indirection).  <br/> <br/> These disadvantages explain
   why it is not so easy to systematically subscribe to the rules of
   rigorous masking.  As for the "dense typing style" or the
   functional/imperative choice to apply, it depends on the
   situation. For example, the elaboration of an optimized program or
   prototype may sometimes be satisfied with an approximate
   masking. On the other hand, when the reuse of code and subsequent
   modifications are certain, the effort required by a rigorous
   masking will take on its full meeting.
   </p>
   <p>
   The example of "apple-man" sets was therefore a representative
   implementation of what could be said. External modules are reused
   there without imposing any choice of implementation. Certain
   important characteristics (as the representation of complex
   numbers, their functions and sets) are thus directly modifiable in
   a localized way. Also, the set of signatures contributes rich
   information and offers a global vision which includes the
   description of the links beteen the different component
   modules. Finally, the program is itself reusable since it is
   essentially a specific form of a datatype associated with
   sets. Obviously, it is more complicated and probably slower than
   realization using different notions and direct melees.
   </p>
   <p>
   In this respect, if the argument for program speed seems often
   decisive for renouncing the quality of a modular structure,
   accelerating a program can often be achieved by other means. The
   indirect effects due to partitioning induce in effect a latency
   which is in general very marginal compared to the principal
   calculation. On the other hand, the partitionings may be poorly
   position or dependant on poor functionalities. For example, a type
   associated with images will need not limit access to their
   individual points, but instea provide accessors to their lines,
   their columns and sub-images. This type may also benefit from
   iterators or generalized functions of composition which will
   naturally limit the need for external access. The quality of a
   partition is sometimes in question and not the intrinsic notion of
   partitioning.
   </p>
   <p>
   In the same suit, we will clarify some technical points about
   masking and its integration into OCaml programs.
   </p>

   <h5>Module records</h5>

   <p>
   Masking seems to be inhibiting when applied to short
   modules. Reconsider the example of the specification of ordered
   sets with masking:
   <pre class="prettyprint ml">
   module type ORDER_MASK = sig
     type t
     type extern_t
     val make : extern_t &rarr; t
     val show : t &rarr; extern_t
     val less_or_equal : t &rarr; t &rarr; bool
   end;;
   </pre>
   This signature is rather intimidating when compared against another
   that does not prepare for masking:
   <pre class="prettyprint ml">
   module type ORDER = sig
     type t
     val less_or_equal : t &rarr; t &rarr; bool
   end;;
   </pre>
   However, a module which satisfies this signature necessarily
   implies that it's type <code>t</code> be public : no way is
   possible to manage the proceedings if it is masked. The form of the
   signature can therefore be considered as a construction of types
   that lies between the specification of abstract types and the
   definition of types of records. In fact, it contains elements with
   distinct names, does not impose or authorize masking and its
   instances are adapated to the modular framework. We will call these
   instances of <i>module records</i>.
   </p>
   <p>
   These constructions obviously have simplifying virtues, they allow
   us to express a datatype without worrying about its
   abstraction. For example, in the framework of modules where only
   basic types and predefined functions are used, masking may be
   superfluous and "module records" well adapted. They consist only of
   a modular formatting of elements defined at the global level. Here
   for example, an instance of the signature <code>ORDER</code>:
   <pre class="prettyprint ml">
   module Int_ordered = struct
     type t = int
     let less_or_equal = ( <= )
   end
   </pre>
   Apart from the general disadvantages of non-masking, here are more
   specific counterparts of such a type construction:
   <ul>
   <li><i>Difficulties when explicitly typing</i> A signature
   like <code>ORDER</code> which is not predisposed to masking may not
   be used for explicit typing with type constraints. We will see on
   the other hand that certain types cannot appear in a type
   constraint.</li>
   <li><i>Of the asssociated implementation</i> The construction
   and the managament of the coherence of instances of
   type <code>t</code> must necessarily be setup outside the modules
   that satisfy <code>ORDER</code>. However if the structure of these
   instances become complex, these operations can't take place outside
   the module, under penalty of being considered private functions if
   a typing by <code>ORDER</code> intervenes.
   </li>
   </ul>
   For example, here is an implementation of the
   signature <code>ORDER</code> for sets of characters where the order
   relation is inclusion (that is to say, $A \le B$ if $A \subseteq
   B$) implemented with the aid of a hash table:
   <pre class="prettyprint ml">
   module Char_set_ordered = struct
     type t = Set of (char, unit) Hashtbl.t

     let less_or_equal (Set h1) (Set h2) =
       let flag = ref true in
       (
          try
            Hashtbl.iter ( fun x y &rarr;
                             if not (Hashtbl.mem h2 x) then
                               raise Not_found ) h1
          with
           | Not_found &rarr; flag := false; );
       !flag
   end;;
   </pre>
   The only way to exploit this implementation consists of
   constructing sets outside of the module as predefined hash tables
   taking into account their specific storage contract (only the keys
   represent the elements). The non-masking of the implementation here
   is seriously defaulted.
   </p>
   <p>
   That said, we will show how such an approximate partioning tactic
   sometimes leads to minimal consequences, and even, on rare
   occasions justfied use of "module-recordings".
   </p>

   <h5>Masking <i>a posteriori</i></h5>
   <p>
   Approximate masking is not irreversible. It is possible to apply
   techniques we already know.
   <br/>
   <br/>
   <b>Masking <i>a posteriori</i> by inclusion:</b> A module may be by
   inclusion to integrate type abstractions, constructors and
   accessors. A data-type can thus become abstract <i>a
   posteriori</i>.
   <br/>
   <br/>
   If we resume the example of the preceding section, we can first
   obtain a signature derived from <code>ORDER</code> which prepares
   for masking the representation of values.
   <pre class="prettyprint ml">
   module type ORDER_MASK = sig
     include ORDER
     type extern_t
     val make : extern_t &rarr; t
     val show : t &rarr; extern_t
   end;;

   module Char_set_ordered_mask : ORDER_MASK
     with type extern_t = char list =
   struct
     include Char_set_ordered

     type extern_t = char list

     let make s =
       let h = Hashtbl.create (List.length s) in
       List.iter (fun x &rarr; Hashtbl.add h x ()) s;;
       Set h

     let show (Set h) =
       let l = ref [] in
       Hashtbl.iter (fun x y &rarr; l := x :: !l) h;
       !l
   end;;
   </pre>
   Not only is the representation of values masked, but usage is made
   easier as the user does not have to manage hash tables:
   <pre class="prettyprint ml">
   # let s1 = Char_set_ordered_mask.make ['a']
     let s2 = Char_set_ordered_mask.make ['a'; 'c'];;
   val s1 : Char_set_ordered_mask.t = &lt;abstr&gt;
   val s2 : Char_set_ordered_mask.t = &lt;abstr&gt;

   # Char_set_ordered_mask.less_or_equal s1 s2;;
   - : bool = true
   </pre>
   In conformance with what has already been noted, the extended
   signature is compatible with the intial version : the module
   satisfies not only <code>ORDER_MASK</code> but
   also <code>ORDER</code>.
   </p>

   <h5>Masking and module associations</h5>
   <p>
   We must now speak of a case where masking does not necessarily need
   to be imposed: that of certain specifications of module
   associations between data-types. In fact, in such a relationship,
   it sometimes happens that a data type does not create or access
   instances of the type it uses. For example, reconsider the
   specification of the type of functions of complex numbers:
   <pre class="prettyprint ml">
   module type COMPLEX = sig 
     type complex
     type extern_complex
     val make : extern_complex &rarr; complex
     val show : complex &rarr; extern_complex
     ...
   end;;

   module type COMPLEX_FUN = sig
     module C : COMPLEX
     type fun_t
     ...
   end;;
   </pre>
   In its simplicity, the signature <code>COMPLEX_FUN</code> does not
   describe <i>a priori</i> any function likely to create or
   manipulate only complex numbers. Also, for example, the
   functions <code>make</code> and <code>show</code> were not utilized
   in the implementations of <code>CFuns</code>
   and <code>CPolynom</code>. In other words, the implementation
   of <code>COMPLEX_FUN</code> does not depend on a particular masking
   convention. The modular association specification could therefore
   have been simplified by using a signature that does not prepare for
   masking, that is to say a signature of "module recordings":
   <pre class="prettyprint ml">
   module type COMPLEX_NOMASK = sig
     type complex
     ...
   end;;

   module type COMPLEX_FUN = sig
     module C : COMPLEX_NOMASK
     type fun_t
     ...
   end;;
   </pre>
   It will be noted moreover that <code>COMPLEX</code> can be assumed
   compatible with <code>COMPLEX_NOMASK</code>. As a consequence, an
   instance of <code>COMPLEX</code> could also be used in the context
   of this simplification.
   <br/>
   <br/>
   <b>Masking and module associations:</b> Consider the
   specification <code>S</code> of a modular association
   between <code>M</code> and a module it
   imports <code>M_sub</code>. Then, <code>S</code> may not impose
   masking on <code>M_sub</code> when the instances originating
   from <code>M_sub</code> are not likey to be created or accessed
   in <code>M</code>.
   <br/>
   <br/>
   </p>
   <p>
   Thus, even in the case which of the requirement of rigorous
   masking, it may be advantageous to have at our disposal both
   versions of a specification : that which prepares for rigorous
   masking and that which does not. We shall see other examples of
   module association relationships.
   </p>

   <h5>The limitations of type constraints</h5>
   <p>
   <br/>
   <br/>
   <b>Limitations of the use of type constraints:</b> Constraints of
   the form <code>with type</code> may not include inductive types or
   records.
   <br/>
   <br/>
   For example, the following module header will be sanctioned as an
   error:
   <pre class="prettyprint ml">
   module Complex : COMPLEX 
     with type extern_complex = C of Num.num * Num.num = 
   struct
     ...
   end;;
   </pre>
   An inductive type or a record type may not therefore be made
   concrete <i>a posteriori</i>, and lend themselves to the
   individualized masking of abstract types. There exist some
   possibilities to remedy this siutation:
   <ul>
   <li><i>Global types</i>. Inductive and record types may also be
   defined at the global level. That solution is certainly in conflict
   with the idea of masking but is sometimes justified in the rare
   cases where the types are deliberately considered as constants of
   an implementation. These constants are then often gathered into a
   particular module that exports all it contains (in a kind of
   extension of the module <code>Pervasives</code>)
   </li>
   <li><i>Semi-global types</i>. Modules can contain modules and their
   signatures. In other words, for embedding, a module is able to play
   the role of a "package". Inductive and record types that we want to
   be able to share among several are then defined outside of these
   but in one package. We will develop this idea further.
   </li>
   <li><i>Polymorphic variants</i>. In contrast to classic inductive
   types, polymorphic variant types are able to be rendered public by
   the contstruction <code>with type</code>. For example:
   <pre class="prettyprint ml">
   module Complex_num : COMPLEX_MASK
     with type extern_complex = [`Complex of string * string] =
   struct
     type extern_complex = [`Complex of string * string]
     type complex = C of Num.num * Num.num

     let make (`Complex (str_r, str_i)) =
       C (Num.num_of_string str_r, Num.num_of_string str_i)

     let show (C (r, i)) =
       `Complex (Num.string_of_num r, Nu.string_of_num i)

     ...
   end;;
   </pre>
   Since then, the constructor of a polymorphic variant is directly usable:
   <pre class="prettyprint ml">
   # let z1 = Complex_num.make  (`Complex ("3424543643232147643", "2432014/4291"));;
   - : Complex_num.complex = &lt;abstr&gt;

   # Complex_num.show z1;;
   - : Complex_num.extern_complex =
                                 `Complex ("3424543643232147643", "2432014/4291")
   </pre>
   Let us recall however that the typing abilities with this type
   variety will be less then with classical inductive types.
   </li>
   </ul>
   </p>

   <h5>The extension of the representation of values</h5>
   <p>
   We have previously seen how extension of the processing of a
   data-type was made relatively easy by the use of module
   inclusions. Consider now extensions of the representation of values
   of a data-type. In fact, in the case of abstract data types, the
   problem is simply in contradiction to masking : the representation
   of data is private by definition, it cannot <i>a priori</i> be
   extended. Consider however the particular situation in which each
   element of the representation of values posseses it's own
   constructor and accessor. In this case, techniques for extending
   the types of records and inductive types are applicable. For
   example, suppose that we have at our disposal a
   module <code>M</code> of a signature <code>S</code> which contains
   a type <code>t</code> which we wish to extend. Here is a general
   module possible for its extension:
   <pre class="prettyprint ml">
   module type S_ext = sig
     include S
     ... (*declarations of new operations*)
   end;;

   module M_ext : S_ext = sig
     module M_old S = M
     type t = ... (*definition extending [t]*)
     ... (*implementation of operations adapted for [t]*)
     ... (*implementation of new operations*)
   end;;
   </pre>
   Note here the implementation shows a module embedding even though
   the signature utilizes an inclusion. In fact, remember that types
   can not be multiply defined in the same module, it is necessary to
   prevent it : the type <code>t</code> of <code>M_ext</code> will be
   defined by explicit adaptions of the
   sub-module <code>M_old</code>. Furthermore, the functions inherited
   from <code>M</code> will also have to be explicitly adapted to the
   extented <code>t</code>. Here is a concrete illustration of this
   model: 
   <pre class="prettyprint ml">
   module type VALUE = sig
     type value
     val make_int : int &rarr; value
     val make_float : float &rarr; value
     val int_of_value : value &rarr; int
     ...
   end;;

   module Value : VALUE = struct
     type value = Int of int | Float of float
     let make_int i = Int i
     let make_float f = Float f

     let int_of_value v = match v with
       | Int i &rarr; i
       | Float f &rarr; int_of_float f
     ...
   end;;
   </pre>
   Now, here is an extension for the representation of rational
   fractions:
   <pre class="prettyprint ml">
   module type VALUE_EXT = sig
     include VALUE
     val make_ratio : int &rarr; int &rarr; value
   end;;

   module Value_ext : VALUE_EXT = sig
     module Val = Value
     type value = V of Val.value | Ratio of int * int
     let make_int i = V (Val.make_int i)
     let make_float f = V (Val.make_float f)
     let make_ratio a b = Ratio (a, b)

     let int_of_value v = match v with
       | V v &rarr; Val.int_of_value v
       | Ratio (a, b) &rarr; a / b
     ...
   end;;

   # let v1 = Val_ext.make_int 4;;
   val v1 : Value_ext.value = &lt;abstr&gt;

   # let v2 = Val_ext.int_of_value v1;;
   - : int = 4

   # let v2 = Value_ext.make_ratio 11 2;;
   val v2 : Value_ext.value = &lt;abstr&gt;

   # Value_ext.int_of_value v2;;
   - : int = 5
   </pre>
   It is therefore possible sometimes to benefit from code resuse when
   extending a representation of values that are masked. In the case
   of incudtive types as above, the technique correspons to external
   adaption of an abstract data type whose role is related to
   emulation - an overload. Note that the use of polymorphic variants
   may somewhat simplify this extension.
   </p>

   <h4>Modules in files and separate compilation</h4>

   We have established how modules allow us to structure programs into
   distinct components. Nevertheless, as these components become
   numerous, it is neccessary to store them, transmit them and to
   compile them in an organized way. For this purpose, a classic
   technique consists of producing the modules and their compilations
   in the form of external files of the host system. Module components
   can then be assembled according to the means of this system through
   tree branches of directories, archives and version management
   tools. The OCaml language provides two mechanisms which make it
   possible to utlize external files:
   <ol>
   <li>Direct interaction of source files into the top-level by
   recopying and recompiling them.</li>
   <li>Separate compilation of source files and their integration
   either into other compiled files or the top-level.</li>
   </ol>
   We now introduce these mechanisms in the following pages.

   <h5>Loading of modules into the top-level</h5>
   <p>
   The top-level offers a simple means for importing external files
   via the command:
   <pre class="prettyprint ml">
   #use "&lt;nom.ml&gt;"
   </pre>
   where "&lt;nom.ml&gt;" is a character string which designate the
   complete name of a file in the file-system. All the lines contained
   in this file are then copied and compiled in the top-level in the
   order in which they appear. For example, consider the
   file <code>distance.ml</code> consisting of the following
   definitions:
   <pre class="prettyprint ml">
   module type DISTANCE = sig
     val dist_to_zero : float &rarr; float &rarr; float
   end;;

   module Distance : DISTANCE = struct
     let sqr x = x ** 2.
     let dist_to_zero x y = sqrt (sqr x +. sqr y)
   end;;
   </pre>
   Given this:
   <pre class="prettyprint ml">
   # #use "distance.ml" ;;
   # Distance.dist_to_zero 1. 2. ;;
   - : float = 2.23606797749979   
   </pre>
   As in the top-level, the order of loading files must be subordinate
   to the order resulting from the dependencies between the
   definitions they contain. For example, here is a
   file <code>geometric_forms.ml</code> which utilize the definitions
   of <code>distance.ml</code>:
   <pre class="prettyprint ml">
   module type GEOMETRIC_FORMS = sig
     val disk : float -> float -> float -> bool
   end;;

   module Geometric_forms : GEOMETRIC_FORMS = struct
     let disk radius x y =
       Distance.dist_to_zero x y &lt; radius
   end;;
   </pre>
   In the top-level, the loading of <code>distance.ml</code> must
   therefore precede that of <code>geometric_forms.ml</code>:
   <pre class="prettyprint.ml">
   # #use "distance.ml";;
   # #use "geometric_forms.ml";;
   
   # Geometric_forms.disk 1.0 0.7 0.4;;
   - : bool = true
   </pre>
   </p>
   <p>
   Note that <code>#use</code> commands can also take place in external
   files and thus constitute "load files" capable of reflecting the
   overall structuring of the avialable module components.
   </p>
   <p>
   This mechanism of integrating files directly into the top-level is
   a simple one which lends itself well to medium sized
   programs. However, it presents a major disadvantage when the size
   of the program is important : the files are recompiled each time a
   <code>#use</code> is evaluated and for each top-level session.
   </p>

   <h5>Separate compilation of modules</h5>
   <p>
   There exists an alternative to the preceding method : the
   compilation of external files more specifically, the separate
   compilation of modules. We say, "unit of compilation" for the pair
   of files formed by the following:
   <ul>

   <li>An <i>implementation file</i> which is capable of containing
   everything that can be contained in a module. The name of the file
   is given the suffix "<code>.ml</code>"
   </li>
   <li>An <i>interface file</i> which consists of the declarations
   associated with the definitions of the implementation file. The
   name of the file is the sanme as the implementation file but given
   the extension "<code>.mli</code>"</li>
   </ul>
   For example, if the two files are respectively
   named <code>name.ml</code> and <code>name.mli</code> (the first
   letter may equally be captilized, e.g. <code>Name.ml</code>
   and <code>Name.mli</code>), the unit of compilation associated is
   equivalent to the following module definition:
   <pre class="prettyprint ml">
   module Name : sig (*contents of name.mli*) end
     = struct (*contents of name.ml*) end;;
   </pre> 
   Unit of compilation are compilable external to the top-level and
   also separably. To so so one used the exteranl
   commands <code>ocamlc</code> or <code>ocamlopt</code>. During this
   compilation "object files" will be produced - the mark of separate
   compilation - and will bear the following names:
   <ul>
   <li>The result of compiling an implmentation
   file <code>name.ml</code> will have the name <code>name.cmo</code>
   (byte-code) or <code>name.cmx</code> (native).</li>
   <li>The result of compiling an interface file <code>name.mli</code>
   will invariably have the name <code>name.cmi</code>.</li>
   </ul>
   Note that if there is no interface file <code>.mli</code>, it will
   be automatically generated by type inference. This will correspond
   to the complete signature of the implementation file which amounts
   to exporting everything it contains.
   </p>
   <p>
   Here is the example of the preceding section adapted for
   conformance to the definition of a unit of compilation. Consider
   the file <code>distance.mli</code> following:
   <pre class="prettyprint ml">
   val dist_to_zero : float -> float -> float
   </pre>
   The file <code>distance.ml</code> then contains a possible
   implementation of this implicit signature:
   <pre class="prettyprint ml">
   let sqr x = x ** 2.
   let dist_to_zero x y = sqrt (sqr x +. sqr y)
   </pre>
   These two files form a unit of compilation equivalent to the
   definition of the following module:
   <pre class="prettyprint ml">
   module Distance : sig
     val dist_to_zero : float -> float -> float
   end = struct
     let sqr x = x ** 2.
     let dist_to_zero x y = sqrt (sqr x +. sqr y)
   end;;
   </pre>
   The compilation of the interface file must be carried out before
   the compilation of the implementation file. For example, in the
   case of generating byte-code from the files:
   <pre>
   $ ocamlc distance.mli
   $ ocamlc distance.ml
   </pre>
   The commands result in the generation of the
   files <code>distance.cmi</code> and <code>distance.cmo</code>. Note
   that the <code>ocamlc</code> and <code>ocamlopt</code> commands
   accept more than one argument : they can be files with extensions
   "<code>.mli</code>" and "<code>.ml</code>" or files
   "<code>.cmi</code>", "<code>.cmo</code>" (respectiveley
   "<code>.cmx</code>") alread compiled. We may therefore write:
   <pre>
   $ ocamlc distance.mli distance.ml
   </pre>
   </p>
   <p>
   Let us now continue the adaption of the example of the preceding in
   composing the following files:
   <pre class="prettyprint.ml">
   (*File : geometric_forms.mli*)
   val disk : radius:float &rarr; float &rarr; float &rarr; bool

   (*File : geometric_forms.ml*)
   let disk ~radius x y = Distance.dist_to_zero x y < radius
   </pre>
   The compilation of this new unit must integrate information taht
   makes it possible to establish links with the
   unit <code>distance</code>. As in the top-level an element used in
   a unit must have been defined in an earlier unit. The arguments of
   a compilation command reflect therefore this order. For example,
   if <code>distance.ml</code> has not already yet been compiled:
   <pre>
   $ ocamlc distance.mli distance.ml geometric_forms.mli geometric_forms.ml
   </pre>
   But also - and this is one of the interests of separate compilation
   -, if <code>distance.ml</code> has already been compiled, the
   object file may be included directly:
   <pre>
   $ ocamlc distance.cmo geometric_forms.mli geometric_forms.ml
   </pre>
   </p>
   <p>
   Another advantage of separate compilation consists of the ability
   to organize by means of tools external to the lanague (for
   example <code>make</code>). These tools take into consideration the
   links between the different units and allow selective
   recompiliation that depend on what modifications that have been
   carried out. Further, units of compilation can be grouped into
   libraries. This compilation can be effected with the option
   "<code>-a</code>" (the extension of the object file of a library is
   "<code>.cma</code>"). By default, the name of the library is
   "<code>library.cma</code>" but by means of the "<code>-o</code>"
   option, you can choose any name desired. For example,
   <pre>
   $ ocamlc -o metrics.cma -a \
       distance.cmo geometric_forms.mli geometric_forms.ml
   </pre>
   This command will create a library "<code>metrics.cma</code>" which
   assembles the modules <code>Distance</code>
   and <code>Geometric_form</code>.
   </p>
   <p>Thus, compilation units completely remedy the shortcomings of
   direct loads via the command <code>#use</code>.
   </p>

   <h5>Precompiled modules and the top-level</h5>
   <p>
   Units compiled to byte-code can be integrated into the
   top-level. The following command will be used for this purpose
   (instead of <code>#use</code> which only applies to files that have
   not been compiled):
   <pre class="prettyprint ml">
   #load "&lt;name&gt;.cmo"
   </pre>
   where "&lt;name&gt;.com" is a string designating the compile name
   of a file in the file-system. The consequences of this command are
   similar to <code>#use</code> : if the file <code>name.cmo</code>
   exists it is loaded intot he top-level in the form of a module
   named <code>Name</code> (without having to compile it). Consider a
   new example of the preceding section:
   <pre class="prettyprint ml">
   # #load "distance.cmo";;
   # #load "geometric_forms.cmo";;

   # Geometric_forms.disk 1.0 0.7 0.4;;
   - : bool = true
   </pre>
   It should be noted that this load can be established from the
   launch of the top-level. Just call <code>ocaml</code> with the
   corresponding "<code>.cmo</code>" files. For example:
   <pre>
   $ ocaml distance.cmo geometric_forms.cmo
   </pre>
   There also exists a command <code>ocamlmktop</code> which provides
   for building a top-level which contains the compiled units
   automatically.
   </p>
   <p>
   These new possibilities induce a general technique for development:
   <br/>
   <br/>
   <b>Program development by extension of the top-level : </b> Any
   implemented module can be compiled and definitively integrated into
   the top-level interaction loop. It becomes more and more
   specialized, evolving in concert with the program which is being
   developed.
   <br/>
   <br/>
   This technique offers a new form of "incremental programming" which
   applies at the modular level and complements the one we have
   illustrated at the functional level. The evolution of the top-level
   becomes an integral part of global development.
   </p>
   <p>
   For example, it is easy to provide the set of elements provided by
   default in the top-level. Consider a
   file <code>ocaml_plus.ml</code> including the generic constructors
   of lists which are not part of the module <code>List</code>, and a
   definition of binary tree type:
   <pre class="prettyprint ml">
   let rec list_build f n x =
     if n &lt;= 0 then []
     else x :: (list_build f (n - 1) (f x));;

   let list_interv n len =
     list_build (fun x -> x + 1) len n;;

   type &alpha; bintree =
     | Bin_empty
     | Bin_node of &alpha; * &alpha; bintree * &alpha; bintree;;
   </pre>
   The following commands generate a top-level which contains these
   definitions:
   <pre>
   $ ocamlc ocaml_plus.ml
   $ ocaml ocaml_plus.cmo
   </pre>
   <pre class="prettyprint ml">
   # open Ocaml_plus ;;

                  Objective Caml

   # list_build ;;
   - : (&alpha; &rarr; &alpha;) &rarr; int &rarr; &alpha; &rarr; &alpha; list

   # Bin_empty ;;
   - : &alpha; Ocaml_plus.bintree = Bin_empty
   </pre>
   </p>

   <h5>Precompiled modules and side-effects</h5>
   <p>
   We have passed over silently in the course of the preceding
   discussion that compilation by <code>ocamlc</code>
   or <code>ocamlopt</code> generates not only object files
   corresponding to each compilation unit, but also an executable. By
   default, the name of that executable is <code>a.out</code> and it
   may be renamed by the option <code>-o</code>. Evidently, its
   execution can have consequences only by interposed side effect. For
   example, reconsider the file <code>fact.ml</code> following:
   <pre class="prettyprint ml">
   let rec fact n =
     if n &lt;=1 then 1 else n * fact (n - 1)
   let () = print_int (fact 3)
   let () = print_newline ()
   </pre>
   Then:
   <pre>
   $ ocamlc -o fact fact.ml
   $ fact
   6
   </pre>
   How do we reconcile this observation with what we have just
   introduced about separate compilation? First of all, the above file
   alone constitutes a compilation unit (we are in a case where the
   interface file <code>fact.mli</code> is automatically
   generated). That compilation unit then describes a module
   named <code>Fact</code> which exports all of it's contents. That is
   to say:
   <pre class="prettyprint ml">
   module Fact = struct
     let rec fact n =
       if n &lt;=1 then 1 else n * fact (n - 1)
     let () = print_int (fact 3)
     let () = print_newline ()
   end;;
   </pre>
   Recall the rules associated with the construction of a module :
   evaluation of the elements are in the order in which they occur. A
   module is in fact only a particular space of definitions and
   nothing prevents the evaluation/execution of expressions. The
   executable produced by separate compilation of a
   unit <code>M</code> corresponds to the series of
   evaluations/executions associated with the construction
   of <code>M</code>. The <code>fact</code> command above thus
   effectively summarizes to the calls of the two <code>Fact</code>
   display programs.
   </p>

   <h5>The technqiue of parent modules : packages</h5>
   <p>
   During the development of a modular program, there are several
   general techniuqes for using the compilation units. The simplest is
   the following:
   <br/>
   <br/>
   <b>Modular programming (C language style) :</b> Each module is
   associated with a unit of compilation of its own. The external file
   structure is then similar to the structure of modules in the
   program.
   <br/>
   <br/>
   The application of this technique implies the relationalship
   between the "<code>.mli</code>" and "<code>.ml</code>" files is
   very similar to the relationship between header files
   "<code>.h</code>" and implementation files "<code>.c</code>" in the
   C programming language. However, this technique demand also
   renouncing certain important possibilities offered by the module
   language system:
   <ul>
   <li><i>Anonymous signatures.</i> Interface files
   "<code>.mli</code>" do not name the signatures they describe. These
   signatures can therefore have no other role than to explicitly type
   their corresponding implementation file. Thus for example, all
   techniques related to inclusions and abstract sub-modules become
   unusable since they depend in part on the names of
   signatures. Similarly, constraints of the form <code>with
   type</code> no longer find a place in programes and hence a masking
   of the abstract types is no longer conceivable. We will see
   moreover that "functors" also require the use of named signatures.
   </li>
   <li><i>Uniqueness of the implmementation.</i> The univocal link
   between the interface "<code>.mli</code>" and implementation
   "<code>.ml</code>" files imposes <i>a priori</i> that each
   signature may have only one implementation in a program. Yet, one
   of the pecularities of the ML module system is to not only consider
   signatures as interfaces but also as types that can be instantiated
   in multiple ways.</li>
   </ul>
   That said, the technique of modular programming "C style" is not at
   all a fatality in OCaml because modules may contain other
   modules. Consequently, compilation units may themselves contain
   signatures and modules thus forming packages. For example, consider
   the implementation file <code>metric_space_unit.ml</code> following:
   <pre class="prettyprint ml">
   module type METRIC_SPACE = sig
     type point
     type extern_point
     val make_point : extern_point -> point
     val dist : point -> point -> float
   end;;

   module Line : METRIC_SPACE
       with type extern_point = float =
   struct
     type point = Point of float
     type extern_point = float
     let make_point x = Point x
     let dist (Point x) (Point y) = abs_float (x -. y)
   end;;
   </pre>
   In the framework of compilation units, the file can be considered
   equivalent to the following module:
   <pre class="prettyprint.ml">
   module Metric_space_unit = struct
     module type METRIC_SPACE = ...
     module Line : METRIC_SPACE with type extern_point = float = ...
   end
   </pre>
   A corresponding interface file <code>metric_space_unit.mli</code>
   could be:
   <pre class="prettyprint ml">
   module type METRIC_SPACE = sig
     type point
     type extern_point
     val make_point : extern_point -> point
     val dist : point -> point -> float
   end;;

   module Line : METRIC_SPACE with type extern_point = float
   </pre>
   Then, this compilation unit compiles like the others:
   <pre>
   $ ocamlc metric_space_unit.mli metric_space_unit.ml
   </pre>
   It's use further shows that masking of type has been applied as
   expected:
   <pre class="prettyprint ml">
   # #load "metric_space_unit.cmo" ;;

   # let p1 = Metric_space_unit.Line.make_point 4.3 ;;
   val p1 : Metric_space_unit.Line.point = &lt;abstr&gt;

   # Metric_space_unit.Line.dist p1 p1 ;;
   - : float = 0.
   </pre>
   </p>
   <p>
   An immediate advantage of this structuring into packages is to
   restore the possibilities of signatures. For example, in the other
   unit, we may integrate an implementation of plane which equally
   satisfies the signature <code>METRIC_SPACE</code> as the
   module <code>Line</code>. Here indeed is a new implementation
   file <code>metric_space_plane_unitl.ml</code>:
   <pre class="prettyprint ml">
   module M = Metric_space_unit

   module Plane : M.METRIC_SPACE
     with type extern_point = float * float = struct
     type point = ...
     ...
   end;;
   </pre>
   Compilation can be directly obtained:
   <pre>
   $ ocamlc metric_space_unit.cmo metric_space_plane_unit.ml
   </pre>
   </p>
   <p>
   This structuring of packages imples a new supplemental level of
   embedding and thus some heaviness in the form of names. As above,
   one can employ aliases in order to alleviate that or even consider
   the idea of using the <code>open</code> directive. In this
   framework, openings are less likely to result in inapproriate
   redefinitions and to weaken the global software architecture.
   </p>
   <p>
   So, in considering compilation units as a base for the idea of
   packages, it is possible to give an alternative technique for
   modular programming in the C style. In order to clearly identify
   the files, one could always suffix the names with
   "<code>_unit</code>" and their general form would consist of three
   parts:
  <br/>
  <br/>
  <b>General form of packages:</b> ("<code>.ml</code>" parent
   modules)
   <pre>
   module MI_1 = M1_unit
   ... (*aliases for imports*)
   module MI_k = Mk_unit
   </pre>
   <pre>
   module type S1 = ...
   ... (*signatures*)
   module type Sm = ...
   </pre>
   <pre>
   module M1 = ...
   ... (*modules*)
   module Mn
   </pre>
   We will replace here the expressions <code>module MI_i =
   Mi_uinit</code> with the expressions <code>open Mi_unit</code> in
   the case where one would be satisfied with simple openings of the
   packages <code>Mi_unit</code>.
   <br/>
   <br/>
   <b>Modular programming with packages:</b> The nominated modules and
   signatures are contained in packages that constitute
   implemementation "<code>.ml</code>" files. The structuring of
   external files induces then a new supplementary level of
   description connected to the structure of modules in the program.
   <br/>
   <br/>
   Implementation masking becomes once again fully controlable and the
   techniques of inclusion of modules and abstract sub-modules are
   again available. It should also be noted that one of the
   consequences of this structuring is to make the need for specific
   interface "<code>.mli</code>" files rather rare (remember these
   files are generated automatically if they are not provided). It is
   not very common to hide signatures and modules. Interface files can
   be useful when defining "locally global" elements taht are only
   shared by the components of the same package.
   </p>
   <p>
   It should be noted that in the case of explicit interface files,
   the above technique induces duplication of signatures between the
   "<code>.ml</code>" and "<code>.mli</code>" files. On the other
   hand, the notion of interface files is equally related to the
   possibility of describing and transmitting a programe without
   implementation. Package structuring can then be refined :
   <br/>
   <br/>
   <b>Modular programming with packages (precision) : </b> Packages
   can be separated into two species : those that contain only
   signatures and those that contain only modules. We thus obtain
   packages of specification and packages of implementation.
   <br/>
   <br/>

   Adapting the preceding example gives a new form of
   organisation. Firstly, here is the file that contains the
   signature (<code>metric_space_spec.ml</code>):
   <pre class="prettyprint ml">
   module type METRIC_SPACE = sig
     type point
     ...
   end;;
   </pre>
   Next, the implementation is provided in another file
   (<code>metric_space_impl.ml</code>):
   <pre class="prettyprint ml">
   module S = Metric_space_spec

   module Line : S.METRIC_SPACE
     with type extern_point = float =
   struct
     ...
   end;;
   </pre>
   Compilation of the ensemble is then obtained with the command:
   <pre>
   $ ocamlc metric_space_spec.ml metric_space_impl.ml
   </pre>
   In order to distinguish between them, specification packages and
   implementation packages can systematically employ suffixes as in
   the example, that is, respectively "<code>_spec.ml</code>" and
   "<code>_impl.ml</code>".
   </p>

   <!-- ******************************************************* -->

   <h3>Generic modular programming : functors</h3>    

   <p>
   The preceding sections show why and how to decouple a program into
   seperate distinct components, how to partition components and how
   to specify them before implmentation. In particular, when we
   discussed the advisability of implementation hiding techniques, the
   main quality criteria being precision and shows, namely in the the
   situation of being able to modify and replace modules locally as
   related but autonomous elements. The subsitution principle is in
   effect the essential characteristic of organisation and module
   reuse. There remains at least one point to improve : the conditions
   that allow us to express and exploit this substitutivity. Generic
   programming allowing the full participation of modules.
   </p>
   <p>So, in these sections, first of all we introduce the notion of
   "functions of modules", that is, <i>functors</i>, which will be the
   principal tools of modular generiticity. We then present some
   conceptual models associated with their use. A thorough discussion
   will be provided about various types of signatures. Highlighting
   their features, we will find functors can be compiled
   independently, that they can posses more than one parameter, are
   typable by signatures of their own and they allow their arguments
   also to be functors. We will then discuss the advantages and
   inconveniences of generic modular programming based on
   functors. Finally, we introduce a graphical representation for
   functors and examples illustrating usage.
   </p>
    
   <h4>Functors</h4>

   <h5>The idea of "functions of modules"</h5>

   <p>
   We have seen that modules and signatures offer a simple means of
   adaption and extension. Recall the example based on the type of
   complex numbers with the following signature:
   <pre class="prettyprint ml">
   module type COMPLEX = sig
     type complex
     val make : float * float &rarr; complex
     val show : complex &rarr; float * float
     ...
   end;;
   </pre>
   So now supposing <code>Complex</code> is a module that satisfies
   the <code>COMPLEX</code> signature, an extension can easily be
   obtained by inclusion:
   <pre class="prettyprint ml">
   module Complex_ext = struct
     include Complex
     let mul z w =
       let (r1, i1) = show z and (r2, i2) = show w in
       make (r1 *. r2 -. i1 *.i2, i1 *. r2 +. i2 *. r1)
   end;;
   </pre>
   This extension is however specific to the
   module <code>Complex</code>. Yet it turns out it is structurally
   independent of the details of the implementation of the module :
   nothing in the body of the new function <code>mul</code> alludes to
   anything particularly specific to <code>Complex</code>. Consider
   the effect on a different implementation of <code>COMPLEX</code>,
   for example, <code>Complex_memo</code>. The extension follows:
   <pre class="prettyprint ml">
   module Complex_memo_ext = struct
     include Complex
     let mul z w =
       let (r1, i1) = show z and (r2, i2) = show w in
       make (r1 *. r2 -. i1 *.i2, i1 *. r2 +. i2 *. r1)
   end;;
   </pre>
   The substitution principle applies here, but is embodied by an
   explicit operation on the code : <code>Complex</code> is replaced
   by hand by the module <code>Complex_memo</code>. This situation is
   similarl in fact to not knowing the concept of function but only
   that of constants!
   </p>
   <p>
   So, very naturally, ML languages offer a construction related to
   that of functions that solves the problem:
   <pre class="prettyprint ml">
   module F (C : COMPLEX) = struct
     include C
     let mul z w =
       let (r1, i1) = show z and (r2, i2) = show w in
       make (r1 *. r2 -. i1 *.i2, i1 *. r2 +. i2 *. r1)
   end;;
   </pre>
   The operation <code>F</code> takes a module
   parameter <code>C</code> of type the
   signature <code>COMPLEX</code>. The application simply retunrs a
   module integration the argument transmitted as a parameter. So, for
   example, the two extensions of complex numbers discussed earlier
   can be obtained by direct applications of <code>F</code>:
   <pre class="prettyprint ml">
   # module Complex_ext = F (Complex);;

   # module Complex_memo_ext = F (Complex_memo);;
   </pre>
   </p>
   <p>
   This new kind of operation consititues a means to facilitate
   substituion of modules. It can express abstractions on modules
   through its parameters and therefore new forms of generalization
   and generiticity. We will develop and explain these ideas
   throughout the pages that follow.
   </p>

   <h5>Defining functors</h5>

   <p>
   A "function of modules", that is to say, a parameterized module, or
   more specifically a functor, permits the passing of modules as
   arguments to construct other modules on which they depend. The
   basic syntax of a functor in OCaml naturally resembles that of
   anonymous functions:
   <br/>
   <br/>
   <pre class="prettyprint ml">
   functor (&lt;Parameter&gt; : &lt;SIGNATURE&gt;) &rarr;
    struct
      type ...           exception ...
      let ...            module ...
      module type ...    open ...
      include ...        &lt;exp&gt;
      ...
    end
   </pre>
   <br/> <br/> In the above, it is indicated
   that <code>&lt;Parameter&gt;</code> necessarily
   satisfies <code>&lt;SIGNATURE&gt;</code>. As a functor computes a
   module, the body of the functor is enclosed the
   keywords <code>struct</code> and <code>end</code>. On the other
   hand, this construction does not itself define a value. We use a
   new module keyword to link to a name:
   <pre class="prettyprint ml">
   module &lt;Name&gt; = 
     functor (&lt;Parameter&gt; : &lt;SIGNATURE&gt;) &rarr;
      struct
        ...
      end
   </pre>
   Such a definition can be abbreviated as so:
   <br/>
   <br/>
   <pre class="prettyprint ml">
   module &lt;Name&gt; (&lt;Parameter&gt; : &lt;SIGNATURE&gt;) = struct
     ...
   end
   </pre>
   <br/> <br/> We obtain here a syntax similar to functions. The
   underlying rule of the definition of functors is given next:
   <br/>
   <br/>
   <b>Functor definition rule : </b> All the elements enclosed in
   the <code>struct-end</code> are compiled sequentially in the order
   they apppear. Each new binding may use the bindings that precede it
   and are strictly associated with the body of the functor. However,
   there are no evaluations. The overall result is bound to the
   identifier <code>&lt;Name&gt;</code>.  <br/> <br/> As for
   functions, evaluation of the body of the functor is effected on
   application and conforms to the rules of a simple module.
   </p>
   <p>Despite the similarities between functions and functors the
   following important difference should be noted:
   <br/>
   <br/>
   <b>The explicit typing of parameters is mandatory :</b> In
   constrast to functions, functors require explicit typing of their
   parameters.
   <br/>
   <br/> 
   In effect, the feature of type inference in ML languages does not
   extend to calculating the signatures of functor parameters (it is
   generally "undecidable").
   </p>

   <h5>Using functor parameters</h5>

   <p>
   The parameters of functors denote modules which are usually used in
   the body of the functor using indirection ("member-selection"
   notation). For example,
   <pre class="prettyprint ml">
   module type S = sig
    type t
    val f : t &rarr; t
   end;;

   module F (M : S) = struct
     type s = M.t  (*recover the type in [M]*)
     let pair x = (x, M.f x) (*apply the function [f] in [M]*)
   end;;
   </pre>
   The type <code>t</code> and the function <code>f</code> of the
   parameter <code>M</code> appear in the implementation of the body
   of the functor <code>F</code>. The parameters of a functor define a
   local environment but this time consisting of modules. The same
   rules of information hiding for simple values apply to the names of
   modules.
   </p>


   <h5>Functor application</h5>

   <p>
   The syntax of functor application is also similar to that of a
   function application, and the result must be bound to the name of a
   module:
   <br/>
   <br/>
   <pre class="prettyprint ml">
   module &lt;Name&gt; = &lt;Functor&gt; (&lt;Argument&gt);;
   </pre>
   <br/> <br/> where <code>&lt;Argument&gt</code> is a module
   statisifying the signature of the parameter
   of <code>&lt;Functor&gt;</code>. For example, here is an instance
   of the signature <code>S</code> of the preceding section:
   <pre class="prettyprint ml">
   module Increm = struct
     type t = int
     let f x = x + 1
   end;;
   </pre>
   It is then possible to apply the functor <code>F</code>:
   <pre class="prettyprint ml">
   # module M1 = F (Increm);;
   </pre>
   The use of the module <code>M1</code> is as usual:
   <pre class="prettyprint ml">
   # M1.pair 1;;
   - : Increm.t * Increm.t = (1, 2)

   # M1.pair 2;;
   - : Increm.t * Increm.t = (2, 3)
   </pre>

    Here are some precise illustrations of two points relating to the
    rule of definition and application of a functor:
    <ul>
    <li>
    <i>The evaluation of the elements of a functor takes place at the
    moment of application.</i>
    <br/>
    <br/>
    For example:
    <pre class="prettyprint ml">
    # module Div_zero (M : sig end) = struct
        print_endline "In division by zero"
        let x = 1 / 0
      end;;

    # module M1 = Div_zero (struct end);;
    In division by zero
    Exception : Division_by_zero
    </pre>
    <br/>
    <br/>
    </li>
    <li>
    <i>Each application of a functor produces a new distinct
    module.</i>
    <br/>
    <br/>
    In particular, if a functor produces modules with internal state,
    those states are distinct. For example:
    <pre class="prettyprint ml">
    module Count_state (M : sig end) = struct
      let count = ref 0
    end;;

    # module V1 = Count_state (struct end)
      module V2 = Count_state (struct end);;
    module V1 : sig val count : int ref end
    module V2 : sig val count : int ref end

    # incr V1.count;;
    - : int ref = { contents = 1}

    # V2.count ;;
    - : int ref = { contents = 0}
    </pre>
    </li>
    </ul>
   </p>

   <h5>Explicit typing of the results of functors</h5>

   <p>
   As functors are part of the operation of language types it is
   naturally possible to render explicitly the signature of their
   results. For this purpose, we use the same notation as for
   functions. Consider for example the following signature:
   <pre class="prettyprint ml">
   module type S_RESULT = sig
     type s
     val pair : s &rarr; s * s
   end;;
   </pre>
   We can then reconsider an earlier example and explicitly type the
   result fo the functor <code>F</code> in two different ways:
   <pre class="prettyprint ml">
   module F_explicit (M : S) : S_RESULT = struct
     type s = M.t
     let pair x = (x, M.f x)
   end;;

   module F_explicit (M : S) = (struct
     type s = M.t
     let pair x = (x, M.f x)
   end : S_RESULT);;
   </pre>
   Explicit typing induces information hiding of the elements
   contained in the body of the functor. The rules are the following
   and reflect directly those which apply to modules:
   <br/>
   <br/>
   <b>Rule (1) : the visibility of the result of a functor : </b> The
   result of a functor unless explicitly typed by a signature has
   public contents.
   <br/>
   <br/>
   <b>Rule (2) : the visibility of the result of a functor : </b> The
   result of a functor explicitly typed by a signature <code>S</code>
   has public contents limited to those defined in the definition
   of <code>S</code> (with the exception of abstract types).  
   <br/>
   <br/>
   We can verify the safe application of the
   functor <code>F_explicit</code> above:
   <pre class="prettyprint ml">
   module Increm = struct
     type t = int
     let f x = x + 1
   end;;

   # module M1 = F_explicit (Increm);;

   # M1.pair 1;;
             ^
   Error: This expression has type int but an expression was expected
         of type M1.s = F_explicit(Increm).s
   </pre>
   The abstract type <code>s</code> of <code>M1</code>
   (from <code>t</code> of <code>Increm</code>) has become private
   since the functor result is explicitly typed.
   </p>
   <p>
   Evidently, individual masking of abstract types and abstract
   sub-modules by the constructions <code>with</code> adapt too to the
   case of the results of functors. One may then apply rigorous
   masking when programming with functors:
   <br/>
   <br/>

   <b>Modular programming with functors and rigorous masking:</b>
   <ol>
   <li>Every functor sees its result explicitly typed by a signature.</li>
   <li>The constructions <code>with type</code> (resp. <code>with
   module</code>)</li> are applied to the types (resp. sub-modules)
   aas necessary.
   </ol>
   <br/>
   <br/>
   </p>

   <h5>Shared types and transmission of types</h5>
   <p>
   If the explicit typing of the result of a functor can also benefit
   from type constraints, a new one appears however here : these
   constraints are able to be established between the types of the
   parameters of a functor and the types that appear in the body of
   this same functor. One may recreate the example from the preceding
   section in the manner following:
   <pre class="prettyprint ml">
   module F_explicit (M : S) :
     S_RESULT with type s = M.t =
   struct
     type s = M.t
     let pair x = (x, M.f x)
   end;;
   </pre>
   The result signature <code>S_RESULT</code> depends here
   on <code>M</code> which is permissible since it is part of the
   environment of constraint : the type <code>s</code> is
   systematically rendered concrete by the relationship to
   type <code>t</code> of the argument <code>M</code>. Therefore, the
   application of the functor makes it possible to export a type
   without having to know <i>a priori</i> the identity:
   <pre class="prettyprint ml">
   # module M1 = F_explicit (Increm);;
   
   # M1.pair 1;;
   - : M1.s * M1.s = (1, 2)
   </pre>
   Contrary to the example of the preceding section, the type of the
   result module remains public thanks to the type constraint. The
   type has been transmitted and made concrete through application of
   the functor. In fact, functors offer the opportunity to use
   constraints which are concerned with such "type sharing".
   </p>

   <h5>Non-module parameters</h5>
   <p>
   It is sometimes desirable to parametrize a functor by not only
   modules but also simple values. OCaml does not directly allow this
   mixing of genres. It suffices however to encapsulate the value to
   be transmitted in a module to obtain the desired effect. For
   example:
   <pre class="prettyprint ml">
   # module F (M : sig val x : int end) = struct
       let v = M.x
     end;;

   # module M = F (struct let x = 3 end);;

   # M.v;;
   - : int = 3
   </pre>
   Here is a less formal example. Its about matrices on integers of a
   certain size (without masking and reduced to a simple operation):
   <pre class="prettyprint ml">
   module Int_matrix (S : sig val size : int end) = struct
     type mat = int array array
     let add m1 m2 =
       let mat = Array.create_matrix S.size S.size m1.(0).(0) in
       for i = 0 to (S.size - 1) do
         for j = 0 to (S.size - 1) do
           mat.(i).(j) <- m1.(i).(j) + m2.(i).(j)
         done
       done;
       mat
   end;;
   </pre>
   For example:
   <pre class="prettyprint ml">
   # module Int_matrix_3x3 = Int_matrix (struct let size = 3 end);;

   # let m = [|[|1; 1; 1|]; [|1; 0; 1|]; [|1; 1; 1|]|];;

   # Int_matrix_3x3.add m m;;
   - : int array array = [|[|2; 2; 2|]; [|2; 0; 2|]; [|2; 2; 2|]|]
   </pre>
   By means of a functor, we remedy here the fact of not being able to
   define "dependant types". In fact, it is not possible in OCaml to
   give a type parameter on values such that:
   <pre class="prettyprint ml">
   # type (n : int, 'a) matrix = ...
   </pre>
   or <code>n</code> would be instantiated by an integer.
   </p>

   <h5>Functors : a generic modular programming type</h5>
   <p>
   Functors constitute in ML, the principal tools of generic modular
   programming, that is to say, the expression of abstractions over
   modules. It is necessary to remark however that modular
   generiticity is not a possibility exclusive to the ML languages and
   that it does not necessarily take this form:
   <ul>
   <li>C++ offers "parameteric classes" or "class templates". The
   parameters of these constructions are not however types but simply
   instansiable by a rewriting mechanism proceeding compilation. The
   parametrized components therefore are not completely compilable
   without being instantiated and type control can only be established
   when they are actually used. On the other hand, for reasons of
   optimization, each instantiation generates independent code
   distinct from the others.</li>
   <li>The languages Eiffel and Java 1.5 offer generic constructions
   with standard parameters : their instantiations must then satisfy a
   class type or an interface. One speaks here of "generiticity
   constraints". However, these type constraints do not allow a fine
   analysis of typing in all situations : in these languages, the
   instantiation of the parameters is often dependent on the inclusion
   polymorphism which benefits the objects.
   </li>
   <li>In Ada, generiticity over modules may equally be constrained
   and is strictly typed. That generiticity is however somewhat
   obstructed by cumbersome writing and use.
   </li>
   </ul>
   This rapid inventory leads us to hightlight the advantages of
   modular generiticity of the ML languages:
   <br/>
   <br/>
   <b>The specification of generic modular programming in ML : </b>
   Functors are autonomous components, individually compilable, easy
   to use, strictly typed and generiticity constrained. As modular
   components they are integrally integrated into the type system.
   <br/>
   <br/>
   Let us develop the last point of this box. We saw earlier that the
   relationship between signature/module is similar to the relationsip
   of type/value.
   \[
     \begin{eqnarray}
      value    &\leftrightarrow&   module \nonumber \\
      type     &\leftrightarrow&   signature \nonumber \\
      function &\leftrightarrow&   functor \nonumber
     \end{eqnarray}
   \]
   Modules are defined and indeed typed like other values in the
   language, and signatures may have multiple instantiations. Fron now
   on, we also know that functors allow to pass modules as arguments
   and return modules as results. We shall see later that they have
   their own signatures and they accept other functors as
   arguments. Thus very clearly, functors extend the parallel between
   the world of typical values and the world of modules. Generic
   modular programming is similar to a language with typical functions
   which favors a functional style. We will return to these general
   questions when functors have been presented in more detail.
   </p>

   <h4>Techniques for using functors</h4>
   <p>
   </p>

   
   <hr/>
   <p>
     References:<br/>
     "Programmation fonctionnelle, g&#233;n&#233;rique et objet: une introduction avec le langage OCaml" -- Narbel P., 2005
   </p>
  </body>
</html>
