<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
          "http://www.w3.org/TR/html4/strict.dtd">
<html>
  <head>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
      extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js"],
      jax: ["input/TeX", "output/HTML-CSS"],
      tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      },
      "HTML-CSS": { availableFonts: ["TeX"] }
      });
    </script> 
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
    <title>Narbel</title>
  </head>
  <body>
    <h2>Generic programming via modules and functors</h2>

    <h3>Modular programming</h3>
    <p>
    The readability, development, finding of errors, testability,
    robustness and adaptability of a program depends mainly on the
    organization into its independent parts and hierarchies. Without
    the adoption of boundaries, the development of a program quickly
    proves difficult to manage and maintenance a burden. Additionally,
    a program often relies on parts that are more general than
    it. Distinuishing these parts permits reutilization of their use
    in other settings and aids in the realization of other
    programs. Structuring, hierarchization and partitioning are the
    essential ingredients of programs ambitious in size and life-time.
    </p>
    <p>
    The possibility of building environments protected from each other
    is already provided for in functional programming through the
    notion of closures. This sub-spacing favors indeed some of the
    properties mentioned above. Nevertheless, the functions are
    limited to values, the protection they impose uniform and not
    lending easily to certain adaptions or extensions. Similarly, type
    structures such as records are likely to generate sub-spaces of
    names used for encapsulation purposes. However, these subspaces
    are equally as limiting as function closures.
    </p>
    <p>
    It is natural therefore to offer a more general means of
    construction for encapsulation. We have already met and used this
    means in fact through OCaml libraries : modules. This new form of
    encapsulation will indeed:
    <ul>
      <li>
      Allow for the construction of sub-spaces of names that do not
      impose restrictions on the elements of the language : modules
      can contain values, the definition of types, exceptions, other
      modules, etc.
      </li>
      <li>
      Allow control of the visibility of each of the elements
      encapsulated.
      </li>
    </ul>
    </p>
    <p>
    Modules are certainly not an original construction of ML
    languages. They exist in most current programming
    languages. However, ML modules possess specifics on which the
    following sections will expand on fully : the type system includes
    them in their own right. Each module posses a unique type : it is
    an instance of this type and recognized as such by the type
    system. From this point of view, a module resembles a typed value
    such as an integer or a character string. The typing system can
    thus extend to the global properties of a program and intervene in
    the elaboration and validation of a software architecture.
    </p>

    <h4>Modules : A general encapsulator</h4>

    <h5>Defining modules</h5>
    <p>
    The syntax of a module in OCaml comes down to framing a series of
    definitions and expressions by the keywords <code>struct</code>
    and <code>end</code>. As earlier announced, there are few
    restrictions as to the nature of the entities that may be placed
    there:
    <pre class="prettyprint ml">
      struct
        type ...          exception ...
        let ...           module ...
        module type ...   open ...
        include ...       &lt;exp&gt;
        ...
      end
    </pre>
    The first three kinds of
    definitions, <code>type</code>, <code>exception</code>
    and <code>let</code> are familiar. The occurence
    of <code>&lt;exp&gt;</code> indicates a module can also contain
    any expression. We introduce the other key-words and extents in
    the following.
    </p>
    <p>
    The encapsulation mechanism above does not alone define a value,
    it is necessary to explicitly associate it with name. To do this
    one uses the <code>module</code> keyword and the chosen names must
    start with a capital letter:
    <pre class="prettyprint ml">
    module &lt;name&gt; = struct
      ...
    end
    </pre>
    </p>
    <p>
    <i>Rules of a module definition : All the elements enclosed by
    a <code>struct</code>-<code>end</code> are compiled and evaluated
    sequentially in the order they appear. Each new element can use
    the previously defined elements and is strictly associated with
    the module. The overall result is bound to the
    identifier <code>&lt;name&gt;</code></i>.
    </p>
    <p>
    For simple bindings, if the overall evaluation is interrupted due
    to the emergence of an exception due to the evaluation of an
    individual element, the module is not built.
    </p>
    <p>
    Here is the first example of a module:
    <pre class="prettyprint ml">
    module Math = struct

      let rec fact n =
        if n &lt;= 1 then 1 else n * fact (n - 1)

      let rec fib n =
        if n &lt;= 0 then 0
        else if n = 1 then 1
        else fib (n - 1) + fib (n - 2)

      let rec sum f n0 n =
        if n < n0 then 0
        else (f n) + (sum f n0 (n - 1))

    end
    </pre>
    So here we have assembled a collection of arithmetic functions
    into a module of name <code>Math</code>.
    </p>

    <h5>Accessing module elements</h5>
    <p>
    By default, the elements of a module are accessible from its
    exterior. As observed in using the standard libraries, the access
    to these items is through indirection using a "member selection
    notation": <i>&lt;Module&gt.&lt;element&gt</i>. So, with the
    module <code>Math</code> of the preceding section:
    <pre>
    # Math.fact 5;;
    - : int = 120

    # Math.fib 6;;
    - : int  = 8 

    # Math.sum (fun n &rarr; n) 0 4;;
    - : int = 10

    # Math.sum (fun n &rarr; Math.fact n) 1 4;;
    - : int = 33
    </pre>
    </p>

    <h5>The modular form of data-types</h5>
    <p>
    Modules used to organize sets of definitions of functions can also
    include definitions of types and thus can serve as a means of
    encapsulation of data-types. That is to say, it is possible then
    to collect in a module the definition of a type and the functions
    that are associated with that type.
    </p>
    <p>
    Here is an example based on complex numbers:
    <pre class="prettyprint ml">
    module Complex = struct

      type complex = {re : float; im : float}

      let make (r, i) = {re = r; im = i}
      let add z w = {re = z.re +. w.re; im = z.im +. w.im}
      let norm z = sqrt (z.re ** 2. +. z.im ** 2.)

    end
    </pre>
    The representation of values is achieved by the use of a record
    type <code>{re : float; im : float}</code>. All the elements of
    this module are public and can be used directly:
    <pre class="prettyprint ml">
    # let z1 = Complex.make (4., 3.);;
    val z1 : Complex.complex = {Complex.re = 4.; Complex.im = 3.}

    # Complex.add z1 z1;;
    - : Complex.complex = {Complex.re = 8.; Complex.im = 6.}

    # Complex.norm z1;;
    - : float = 5.

    # z1.Complex.re;;
    - : float = 4.
    </pre>
    Note that these complex numbers are instances of the
    data-type <code>complex</code>. These instances are dependent on
    the the functions contained in the module, that is to
    say, <code>add</code> and <code>norm</code>. The encapsulation of
    a data-type in a module is indeed often characterized by such a
    centralized organisation. By contrast, we can compare this case
    with that record types, that is here, each instance contains both
    values and functions. We will discuss this important point of
    comparison later.
    </p>
    <p>
    Here are some more examples of data-types in modular form. First,
    let us consider a type that represents points in a plane
    associated with the usual Euclidean distance.
    <pre class="prettyprint ml">
    module Plane = struct
      type point = P of float * float

      let make_point (x, y) = P (x, y)

      let dist (P (x1, y1), P (x2, y2)) =
        sqrt ((x1 -. x2) ** 2. +. (y1 -. y2.) ** 2.)
    end
    </pre>
    A difference of this example from the preceding is that here, the
    representation of values of <code>point</code> are as instances of
    a singlar sum type. The techniques of expressing types we already
    know apply equally well in the context of modules.
    </p>
    <p>
    Data structures (or containers) can also take a coherent form by
    means of modules. For example, here's how to gather the
    definitions associated with lists:
    <pre class="prettyprint ml">
    module L = struct
      type &alpha; lin = Empty | Cons of &alpha; * &alpha; lin

      let empty () = Empty

      let add x l = Cons (x, l)

      let rec mem x l = match l with
        | Empty &rarr; false
        | Cons (x, xs) &rarr; x = y || mem x xs

      let rec apend l1 l2 = match l1 with
        | Empty &rarr; l2
        | Cons (x, xs) &rarr; Cons (x, append xs l2)
    end;;

    # let l1 = L.add 3 (L.empty ())
    val l1 : int L.lin = L.Cons (3, L.Empty)

    # let l1 = L.add 4 l1;;
    val l1 : int L.lin= L.Cons (4, L.cons (3, L.Empty))

    # L.mem 42 l1;
    - : bool = false
    </pre>
    The type of the containers is naturally generic as the the
    representation of values of <code>&alpha; lin</code> is:
    <pre>
    # L.add 3.1415926 (L.Empty);;
    - : float L.lin = L.Cons (3.1415926, L.Empty)

    # L.add "colorisation des esprits" (L.empty ());;
    - : string L.lin = L.cons ("colorisation des esprits", L.Empty)
    </pre>
    In fact, most data types defined in the standard OCaml library are
    implemented using this technique.
    </p>

    <h5>Remarks on the rules of module definitions</h5>
    <p>
    It is useful to have a precise idea about the consequences of the
    rules of definitions associated with the construction of a
    module. These are some of the important points:
    <ul>
      <li>
      <i>The evaluation of elements in a module follow their
      individual evaluation rules</i>.
      <br/>
      <br/>
      Here is an example illustrating the case of functions:
      <pre class="prettyprint ml">
      # module M = struct
          let f () = 1 / 0
        end;;
      # M.f ();;
      Exception : Division_by_zero.
      </pre>
      It is only when <code>f</code> is applied that an exception is
      thrown. Constrast this with the case of the construction of a value:
      <pre class="prettyprint ml">
      # module M = struct
          let x = 1 / 0
        end;;
      Exception : Division_by_zero.
      # M.x ;;
      Unbound value M.x
      </pre>
      The evaluation of the body of a <code>let</code> occurs during
      the construction of the module. Similarly, simple expressions:
      <pre class="prettyprint ml">
      # module M = struct
          print_endline "Inside M"
          let f x = x + 1
        end;;
      Inside M
 
      #M.f;;
      - : int &rarr; int
      </pre>
      The printing of the character string is effected during the
      construction of <code>M</code>. In the case where such
      expressions are followed, it is neccessary to use
      seperators. One can make use of double semi-colons:
      <pre class="prettyprint ml">
      # module M = struct
          print_endline "in M" ;;
          print_endline "yes, in M";;
          let f x = x + 1
        end;;
      </pre>
      However, the tradition in OCaml requires rather that we stick.
      with <code>let</code> bindings. Evaluations that only occur
      during the construction of a module are really only useful in
      edge cases (the construction of a module generates a
      module). Therefore, the type of these expressions is
      necessarily <code>unit</code> and the following form is also
      possible:
      <pre class="prettyprint ml">
      # module M = struct
          let () = print_endline "in M"
          let () = print_endline "yes, M"
          let f x = x + 1
      </pre>
      What we've written here are artifical <code>let</code>
      constructions by way of pattern matching on a unique instances
      of type <code>unit</code>. Thus the form <code>let () =
      ...</code> in a module invariably indicates an expression that
      will be evaluated during the construction of the module.
      <br/>
      <br/>
      </li>
      <li>
      <i>Dependence on the placement of elements in a module</i>
      <br/>
      <br/> The evaluation of a module is sequential. A definition in
      a module may not utilize a definition that follows it:
      <pre class="prettyprint ml">
      # module M = struct
          let f x = (g x) + 1
          let g x = x + 2
        end;;
      Unbound value g
      </pre>
      In the case you wanted to override this rule, it is necessary to
      make use of a <code>let rec</code> construction and define
      mutally recursive functions:
      <pre class="prettyprint ml">
      # module M = struct
          let rec f x = (g x) + 1
          and g x = x + 2
        end;;
      </pre>
      <br/>
      <br/>
     </li>
     <li>
       <i>Internal module state</i>
       <br/>
       <br/>
       It is possible to define modifiable variables in a module. Such
       variables constitute internal state. Reconsider the earlier
       example of points in the plane. We can provide a way to measure
       the extent of their establishment through such internal state
       wich will be denoted here as <code>count</code>:
       <pre class="prettyprint ml">
         module Plane_count = struct
           type point = {number : int; coord : float * float}

           let count = ref 0 (*Initialization*)

           let make_point (x, y) =
             incr count; {number = !count; coord = (x, y)}

           let dist p1 p2 =
             let (x1, y1) = p1.coord and (x2, y2) = p2.coord in 
               sqrt ((x1 -. x2) ** 2. +. (y1 -. y2.) ** 2.)
         end;;
       </pre>
       For example:
       <pre class="prettyprint ml">
       # Plane_count.make (0., 0.);;
       - : Plane_count.point = {Plane_count.number = 1;
                                Plane_count.coord = (0., 0.)}
       # Plane_count.make (1., 1.);;
       - : Plane_count.point = {Plane_count.number = 2;
                                Plane_count.coord = (1., 1.)}
       </pre>
       <br/>
       <br/>
     </li>
     <li>
       <i>Multiple definitions and redefinitions of elements in a
       module</i> <br/> <br/> If an association is defined multiple
       times in a module, it is only the last definition that will be
       taken into account. The sequential evaluation of elements in a
       module imply behaviors consistent with similar evaluations in
       the global environment. For example:
       <pre class="prettyprint ml">
       module M = struct
         let number = 1
         let number = 2.1
         let number = "three"
       end;;

       # M.number;;
       - : string = "three"
       </pre>
     </li>
    </ul>
    </p>

    <h5>Local modules</h5>
    <p>
    In OCaml, modules can emerge in local environments defined by way
    of a new <code>let</code> construction:
    <pre class="prettyprint ml">
    let module &lt;name&gt; = struct ... end in &lt;exp&gt;
    </pre>
    where the name of the module is usable in the
    expression <code>&lt;exp&gt;</code>. One of the main interest of
    local modules is to remedy the limitations of environments defined
    by <code>let</code>-<code>in</code> that can not in fact, include
    certain entities. On the contrary, local modules are not subjected
    to these restrictions. They allow, among other things, to
    associate types or exceptions to an expression. For example, we
    observe that sum types can clarify code. As such, they can
    sometimes be considered as a localized and specific aid. Consider
    this example in polynomials of degree 2:
    <pre class="prettyprint ml">
    # let poly2 a b c =
        let module O = struct
          type order = Less | Equal | Greater
          let less_or_equal x y =
            if x < y then Less else
            if x = y then Equal 
            else Greater
           end in
           match (O.less_or_equal ...) with
             | O.Equal &rarr; ...
             | O.Greater &rarr; ...
             | O.Less &rarr; ...;;
     val poly2 : float &rarr; float &rarr; float &rarr; solution
    </pre>
    The type <code>order</code> resides privately and solely in the
    function <code>poly2</code>. We will see other uses of local
    modules.
    </p>

   <h4>Signatures : the type of modules</h4>

   <h5>Inferred signatures</h5>
   <p>
   The behavior of modules in OCaml is similar to that of values in
   many ways. In paricular, each module possesses a type that is
   integrated with and used by the type-system. The type of a module
   can be computed by inference from the module's definition. As
   stressed in the introduction, this is one of the specifics of ML
   languages. However, the somewhat different nature of these types
   justifies distinguishing them from others. The types of modules are
   called <i>signatures</i>.  <br/> <br/> <b>Property (1) of signatures</b> :
   A signature can be inferred from the definition of a module.  <br/>
   <br/> For example, recall the module corresponding to the
   implementation of a type for complex numbers. The resulting
   signature obtained by type inference follows:
   <pre class="prettyprint">
   module Complex :
     sig
       type complex = {re : float; im : float}
       val make : float * float &rarr; complex
       val add : complex &rarr; complex &rarr; complex
       val norm : complex &rarr; float
     end
   </pre>
   A signature is essentially a summary of all the elements of the
   module to which it corresponds.
   </p>

   <h5>Defining signatures</h5>
   <p>
   As is the case for types of values, it is possible to define
   signatures independently of modules. A signature then consists of a
   simple suite of definitions and declarations enclosed in the
   keywords <code>sig</code> and <code>end</code>:
   <pre class="prettyprint ml">
   sig
     val ...             type ...
     exception ...       module ...
     module type ...     open ...
     include ...         ...
   end
   </pre>
   Note that the identifiers must be delcared with the
   keyword <code>val</code> (rather than <code>let</code>). For
   example:
   <pre class="prettyprint ml">
   val x : char
   val f : int &rarr; float
   val g : &alpha; &rarr; int
   </pre>
   As for modules, it is neccessary to link a signature to a name
   using the keywords <code>module type</code>:
   <pre class="prettyprint ml">
   module type &lt;NAME&gt; = sig
       ...
   end
   </pre>
   There are no syntactic constraints regarding the names of of module
   types with respect to enforcing uppercase or lowercase
   characters. However, to distinguish the names of signatures from
   other identifiers, a convention adopted in the ML literature is to
   spell them entirely in capital letters. Here are some definitions
   of signatures corresponding to the modules presented in early
   sections. For example, here is the signature for <code>Math</code>:
   <pre class="prettyprint ml">
   module type MATH = sig
    val fact : int &rarr; int
    val fib : int &rarr; int
    val sum : (int &rarr; int) &rarr; int &rarr; int &rarr; int
   end
   </pre>
   And here are the signatures of the modules <code>Complex</code>
   and <code>Plane</code> respectively and, the module <code>L</code>
   associated with lists.
   <pre class="prettyprint ml">
   module type COMPLEX = sig
     type complex
     val make : float * float &rarr; complex
     val add : complex &rarr; complex &rarr; complex
     val norm : complex &rarr; float
   end;;

   module type METRIC_SPACE_2D = sig
     type point
     val make_point : float * float &rarr; point
     val dist : point &rarr; point &rarr; float
   end;;

   module type LINEAR_CONTAINER = sig
     type &alpha; lin
     val empty : unit &rarr; &alpha; lin
     val add : &alpha; &rarr; &alpha; lin &rarr; &alpha; lin
     val mem : &alpha; &rarr; &alpha; lin &rarr; bool
     val append : &alpha; lin &rarr; &alpha; lin &rarr; &alpha; lin
   end;;
   </pre>
   The examples illustrate the following important point:
   <br/>
   <br/>
   <b>The fundamental interest of signatures :</b> They express certain
   characteristics of modules without including any implmentation.
   <br/>
   <br/>
   </p>

   <h5>Abstract types</h5>
   <p>
   The signatures of the last section have show that it is possible to
   use the keyword <code>type</code> without necessarily associating
   it with an explicit definition. We saw there for example:
   <pre class="prettyprint ml">
     type complex
     type point
     type &alpha; lin
   </pre>
    That is, it can be limited to the names of types declared in
    signatures:
    <br/>
    <br/>
    <b>Definition:</b> In a signature, a simple declaration of a name
    of a type is called an abstract type.  <br/> <br/> This name is
    justified because these types allow for an abstraction of the
    existence of particular types. To be precise:
    <br/>
    <br/>
    <b>The interest of abstract types and the coherence of a
    signature:</b> The abstract types of a signature <code>S</code>
    declare the names of types which are usable for the types of other
    elements in <code>S</code>. They thus impose a global coherence to
    typing other elements of the signature <code>S</code>, and this
    without being dependent on the definitions of these types.<br/>
    <br/> <br/> Moreover, when the parameters are abstract types, this
    makes possible expressions of typing patterns. For example, in the
    signature <code>LINEAR_CONTAINER</code>, there were the following
    generic declarations:
    <pre class="prettyprint ml">
    type &alpha; lin
    val add : &alpha; &rarr; &alpha; lin &rarr; &alpha; lin
    val mem : &alpha; &rarr; &alpha; lin &rarr; bool
    </pre>
    So, for example, the type <code>&alpha; &rarr; &alpha; lin &rarr;
    &alpha; lin</code> describes a generic operation of adding an
    element of type <code>&alpha;</code> to an <code>&alpha;
    lin</code> containing other items of the same type. In the
    implementation, the typing consistency will be ensured.
   </p>

   <h5>Elements implemented in signatures</h5>
   <p>
   Even if the main part of a signature is constituted merely of
   simple declarations, some of the elements can be implemented. It is
   possible to define exceptions:
   <pre>
   module type S = sig
     exception No
     exception Out_of_bounds of float
     ...
   end
   </pre>
   On the other hand, types can also be defined in a signature. For
   example, the signature <code>COMPLEX</code> includes the definition
   of a record type:
   <pre class="prettyprint ml">
   module COMPLEX = sig
     type complex = {re : float; im : float}
     ...
   end
   </pre>
   Such types are called "concrete types" (or "manifest types")
   distinguishing them from abstract types.
   </p>

   <h5>Signatures for explicitly typing modules</h5>
   <p>
   Signature definitions only make sense if they can be linked to
   modules. As for simple values, it is possible to explicitly ascribe
   a signature to a module. The syntax is similar:
   <pre class="prettyprint">
     module &lt;NAME&gt; : &lt;SIGNATURE&gt; = struct
       ...
     end
   </pre>
   The first application of this is to add explicit typing information
   to the definition of a module. Type inference can put this into
   correspondence with its own calculation. We can therefore check by
   inference that a module corresponds to its signing. For example, if
   we use the module <code>L</code> associated with lists we can
   explicitly type it to the signature <code>LINEAR_CONTAINER</code>.
   <pre class="prettyprint ml">
   # module L : LINEAR_CONTAINER = struct
       type &alpha; lin = Empty | Cons of &alpha; * &alpha; lin
       let empty () = Empty
       let add x l = ...
       let rec mem x l = ...
       let rec append l1 l2 = ...
     end;;
   module L : LINEAR_CONTAINER
   </pre>
   Here we get a terse response from the type system indicating
   acceptance that <code>L</code> can be typed as
   a <code>LINEAR_CONTAINER</code>. In contrast, an invalid explicit
   typing not sanctioned by inference will be documented as a type
   error. For example, consider a situation where a module does not
   implement all the elements of the
   signature <code>LINEAR_CONTAINER</code>:
   <pre class="prettyprint ml">
   # module L : LINEAR_CONTAINER = struct
       type &alpha; lin = Empty | Cons of &alpha; * &alpha; lin
       let add x l = Cons (x, l)
     end;;
   The field &alpha;ppend' is required but not provided
   The field 'mem' is required but not provided
   The field 'empty' is required but not provided
   </pre>
   The main rule of explicit typing with signatures follows:
   <br/>
   <br/>
   <b>Rule of explicit typing by signature:</b> The explicit typing of
   a module <code>M</code> to a signature <code>S</code> is valid only
   if the elements defined and declared in <code>S</code> are
   implemented in <code>M</code> (with exactly the same names). The
   elements of <code>M</code> must be equal, consistent with or more
   general than those indicated in <code>S</code>.
   <br/>
   <br/>
   Here are some examples to help explain the rules:
   <ul>
   <li><i>Independence from the order of definitions.</i>
   <br/>
   <br/>
   The order of appearance of the elements of the module is not
   important as long as its type corresponds with the signature.
   <br/>
   <br/>
   </li>
   <li>
   <i>The effect of explicitly typing on individual elements.</i>
   <br/>
   <br/>
   Signing by explicit typing acts to explicitly type each individual
   element of the module. For example:
   <pre class="prettyprint ml">
   module type S = sig
     val fst : int * float &rarr; int
   end;;

   module M : S = struct
     let fst (x, y) = x
   end;;

   #M.fst ;;
   - : int * float &rarr; int
   </pre>
   Here the function <code>fst</code> given by the explicit typing to
   the signature <code>S</code> is equivalent to:
   <pre class="prettyprint ml">
     let fst ((x, y) : int * float) : int = x;;
   </pre>
   An occassional error is to implement an element of a module that is
   less general than its declaration. For example:
   <pre class="prettyprint ml">
   module type S = sig
     val f : &alpha; &rarr; &alpha;
   end;;

   module M : S = struct
     let f x = x + 1
   end;;
   </pre>
   The above is an error. This point will later be discussed in more
   detail.  
   <br/>
   <br/>
   </li>
   <li>
   <i>Parameteric abstract types</i>
   <br/>
   <br/>
   An implementation of an abstract type can make use of
   type variable parameters. For example:
   <pre class="prettyprint ml">
   module type S = sig
     type (&alpha;, &beta; &gamma;) t
   end;;

   module M : S = struct
     type (&alpha;, &beta; &gamma;) t = int
   end;;
   </pre>
   One can restrict the generiticity of a type paramter of an abstract
   type. The inverse is not possible:
   <pre class="prettyprint ml">
   # type t = &alpha; list;;
   Unbound type parameter &alpha;
   </pre>
   <br/>
   </li>
   <li>
   <i>Globale coherence of the type of a module</i>
   <br/>
   <br/>
   Using abstract types in a signature permits expressing the overall
   typing coherence between the elements of a signature. For example,
   reconsider the module <code>Plane</code>:
   <pre class="prettyprint ml">
   module Plane = struct
     type point = P of float * float

     let make_point (x, y) = P (x, y)

     let dist (P (x1, y1)) (P (x2, y2)) =
       sqrt ((x1 -. x2) ** 2. +. (y1 -. y2) ** 2.)
   end;;
   </pre>
   The inferred signature is:
   <pre class="prettyprint ml">
   module Plane : sig
     type point = P of float * float
     val make_point : float * float &rarr; point
     val dist : point &rarr; point &rarr; float
   end
   </pre>
   The use of the simple inductive type permits the use of the
   type <class>point</class> in the type of the
   functions <code>make</code> and <code>dist</code>. But here,
   another version of the module uses a type abbreviation:
   <pre class="prettyprint ml">
   module Plane = struct
     type point = float * float

     let make_point (x, y) = (x, y)

     let dist (x1, y1) (x2, y2) = 
       sqrt ((x1 -. x2) ** 2. +. (y1 -. y2) ** 2.)
   end;;
   </pre>
   The inferred signature follows:
   <pre class="prettyprint ml">
   module Plane : sig
     type point = float * float
     val make_point : &alpha; * &beta; &rarr; &alpha; * &beta;
     val dist : float * float &rarr; float * float &rarr; float
   end
   </pre>
   The type <code>point</code> here is a priori without manifest
   utility and the associated functions don't use it (the type
   inference possesses no evidence to connect them with the
   type <code>point</code>). Explicit typing with a signature remedies
   the situation. Indeed, reconsider signing with:
   <pre class="prettyprint ml">
   module type METRIC_SPACE_2D = sig
     type point
     val make_point : float * float &rarr; point
     val dist : point &rarr; point &rarr; float
   end;;
   </pre>
   Then,
   <pre class="prettyprint ml">
   # module Plane : METRIC_SPACE_2D = struct

       type point = float * float

       let make_point (x, y) = (x, y)

       let dist (x1, y1) (x2, y2) = 
         sqrt ((x1 -. x2) ** 2. +. (y1 -. y2) ** 2.)
     end;;
   module Plane : METRIC_SPACE_2D

   # Plane.make_point;;
   - : float * float &rarr; Plane.point

   # Plane.dist;;
   - : Plane.point * Plane.point &rarr; float
   </pre>
   The types of the functions here became specific. The explicit
   typing by signature has had a structuring effect on the collection
   of the types of the elements of the module.
   <br/>
   <br/>
   </li>
   <li>
   <i>Concrete types and exceptions</i> 
   <br/>
   <br/>
   If a signature <code>S</code> contains concrete types of
   exceptions, the modules that implment it must necessarily contain
   the same definitions. For example:
   <pre class="prettyprint ml">
   module type S = sig
     exception Bad of int
     type &alpha; inverse = Full | Empty of &alpha;
   end;;

   module M : S = struct
     exception Bad of int
     type &alpha; inverse = Full | Empty of &alpha;
   end;;
   </pre>
   </li>
   </ul>
   </p>

   <h5>The instantiation relationship between modules and signatures</h5>
   <p>
   A signature may be inferred by the type system for a particular
   module. On the other hand, a module may correspond with a signature
   by explicit typing. It is then said that the module
   implementation <i>satisfies</i> that signature. To stick to that
   though would be to forget an important and original characteristic
   of the module system:
   <br/>
   <br/>
   <b>Property (2) of signatures:</b> The same signature may be
   implemented by multiple distinct modules.
   <br/>
   <br/>
   To highlight the similarity of modules with simply typed values, we
   can extend the meaning of the word "instance".
   <br/>
   <br/>
   <b>Definition:</b> A module that implements (or satisfies) a
   signature, we say is an <i>instance</i>.  <br/> <br/> For example,
   consider a new signature that describes a two-dimensional space
   equipped with a distance metric:
   <pre class="prettyprint ml">
   module type METRIC_SPACE_2D = sig
     type point
     val make_point : float * float &rarr; point
     val dist : point &rarr; point &rarr; float
   end;;
   </pre>
   It is possible to instantiate it in many different ways:
   <pre class="prettyprint">
   module Plane : METRIC_SPACE_2D = struct
    type point = float * float
    let make_point (x, y) = ...
    let dist (x1, y1) (x2, y2) = ...
   end;;

   module Plane_count : METRIC_SPACE_2D = struct
     type point = {number : int; coord : float * float }
     let make_point (x, y) = ...
     let dist p1 p2 = ...
   end;;

   module Manhattan_plane : METRIC_SPACE_2D = struct
    type point = float * float
    let make_point (x, y) = (x, y)
    let dist (x1, y1) (x2, y2) = 
      abs_float (x1 -. x2) +. abs_float (y1 -. y2)
   end;;
   </pre>
   With this, these three spaces can coexist in the same progam:
   <pre class="prettyprint ml">
   # Plane.dist;;
   - : Plane.point &rarr; Plane.point &rarr; float

   # Plane_count.dist;;
   - : Plane_count.point &rarr; Plane_count.point &rarr; float

   # Manhattan_plane.dist;;
   - : Manhattan_plane.point &rarr; Manhattan_plane.point &rarr; float
   </pre>
   </p>
   <p>
   Note that the two properties highlighted above - inference and
   multiple instantiation - are absent from most other
   languages. Multiple instantiation not only increases the reuse of
   signatures, but we will also see that it turns out to be natural in
   defining "functions of mouldes" whose parameters are the types of
   signatures.
   </p>

   <h4>Techniques for writing signatures</h4>

   <h5>Signatures as a means of specification and interface</h5>

   <p>If there is a singularity of ML relative to other languages
   (modules are instances of signatures), their basic use is very
   usual. Indeed, explicit typing of modules showcases signatures as a
   means of interface specification:
   <ul>
   <li><i>Formal description.</i> The prior elaboration of signatures
    admits the design of programs without having to face the practical
    problems of implementation: we focus on the organization of
    sub-spaces of names, on the relations, the constraints to be
    specified there. It is only in the second phase that we undertake
    implementation. The implmementation of a program is then based on
    the collection of pre-existing signatures.
    <br/>
    <br/>
   </li>
   <li><i>Transmission of documentation.</i> Signatures also lend
    themselves as a means of transmission of an abridged form of the
    possibilities their bodies offer the potential user.
   </li>
   These links between signatures and modules thus induce a method of
   production of programs that is measured and thoughtful. This method
   applied during program development takes a certain thoroughness.
   </ul>
   </p>

   <h5>The limitations of signatures as specifications</h5>

   <p>The signatures of ML provide a limited means of
   specification. Signatures can only include properties whose
   verification can be realized within the reach of the type
   system. For example, reconsider the
   signature <code>METRIC_SPACE_2D</code>. The
   declaration <code>dist</code> there is deemed to specify a function
   of distance. The declaration describes binary function acting on
   the <code>point</code> type and computing a number of
   type <code>float</code>:
   <ul>
     <li><i>Weakness in the implementation.</i> A programmer can not
     rely on the system to check the character of the distance
     function an implementation of <code>dist</code> will have
     produced.  <br/> <br/>
     </li>
     <li><i>Weakness of use.</i> A user of an instance of the
     signature <code>METRIC_SPACE_2D</code> can not be sure of the
     character of the distance function provided by <code>dist</code>.
     </li>
   </ul>
   For example, the module following satisfies the signature
   of <code>METRIC_SPACE_2D</code> but it's function <code>dist</code>
   is not a distance:
   <pre class="prettyprint ml">
   module Buggy_plane : METRIC_SPACE_2D = struct
     type point = float * float
     let make_point (x, y) = (x, y)
     let dist (x1, y1) (x2, y2) = x1 +. y1 +. x2 +. y2
   end
   </pre>
   As part of a complete description of a metric space , the axioms of
   the definition of a distance would be included:
   \[
   \begin{eqnarray}
   \forall x,y \in point,&\;\;&0 \le dist (x, y) \le \infty \nonumber \\
   \forall x,y \in point,&\;\;& dist(x, y) = 0 \iff x = y \nonumber \\
   \forall x,y \in point,&\;\;& dist(x, y) = dist(y, x) \nonumber \\
   \forall x,y \in point,&\;\;& dist(x, z) \le  dist(x, y) + dist (y, z)
   \end{eqnarray}
   \]
   Only their verification on <code>dist</code> would ensure the
   character of the distance function. That verification is quite out
   of reach of the type system. Languages that include such
   possibilities of specification require production of mathematical
   evidence adapted case by case. In the language of OCaml, we resort
   to verification of specific implementations via assertions and
   tests.
   </p>

   <h5>Mitigation of the limitations of specification via signatures</h5>

   <p>
   The simpliest and most traditional method of mitigating the
   limitations consists of associating signatures with documentation
   in the form of comments. The constraints, the properties, the
   behaviors of elements may be made more or less formal and
   precise. For example:
   <pre class="prettyprint ml">
   module type METRIC_SPACE_2D = sig
     type point
     val make_point : float * float &rarr; point
     val dist : point &rarr; point &rarr; float
     (*Satisifies the axioms of a distance function, can raise
      [Invalid_argument] *) 
   end
   </pre>
   This tactic can be applied generally and systematically during the
   elaboration of signatures. It is obviously understood to be a
   compromise since the type system can exert no control over them.
   </p>
   <p>
   We wil later see however that sometimes OCaml offers more effective
   means by nesting signatures in other modules or the use of
   functions of modules. Also, technically, a specification can
   combine the type system. For example, in the
   signature <code>MATH</code> we have:
   <pre class="prettyprint ml">
   val sum : (int &rarr; int) &rarr; int &rarr; int
   </pre>
   In this declaration, while it defines the form of the function, we
   are guessing the first parameter represents the operation that
   defines the sum. On the other hand, the declaration fails to
   describe the remaining two parameters. The use of comments would
   remedy this lack of precision but OCaml provides an extension which
   offers a solution which integrates better with this kind of problem
   : labeled parameters. We can use this feature in the signature to
   clarify the role of these parameters. For example:
   <pre class="prettyprint ml">
   val sum : f : (int &rarr; int) &rarr; start : int &rarr; goal : int &rarr; int
   </pre>
   Then, modules that satisfy the signature will have these types
   labeled providing coherence. For example:
   <pre class="prettyprint ml">
   let rec sum ~f ~start ~goal =
     if goal < start then 0
     else (f goal) + sum ~f:f ~start:start ~goal:(goal - 1)
   </pre>
   Any gaps in the naming of the parameters will be sanctioned by a
   type error. The labeling of parameters then permits an enriched
   signature in terms of documentation and is verifiable by the type
   system during instantiation.
   </p>

   <h5>The generalization of signatures</h5>

   <p>
   The existence of abstract types in signatures permits a new
   technique of generalistation. For example, consider once again the
   signature <code>MATH</code>:
   <pre class="prettyprint ml">
   module type MATH = sig
    val fact : int &rarr; int
    val fib : int &rarr; int
    val sum : (int &rarr; int) &rarr; int &rarr; int &rarr; int
   end
   </pre>
   This signature restricts the declarations to numbers of the
   type <code>int</code>. The specification sets here a representation
   that leads to a particular precision in implementations. We can
   replace the occurences of <code>int</code> with an abstract type:
   <pre class="prettyprint ml">
   module type MATH_GEN = sig
    type t
    val fact : t &rarr; t
    val fib : t &rarr; t
    val sum : (t &rarr; t) &rarr; t &rarr; t &rarr; t
   end
   </pre>
   We have obtained a generalization of the
   signature <code>MATH</code> over the the type <code>int</code>.
   <br/>
   <br/>
   <b>Principle of generalization of a signature :</b> Replace the
   specific type in the signature with an abstract type.
   <br/>
   <br/>
   </p>

   <h5>Signatures and the functional or imperative style</h5>

   <p>
   A signature can induce a programming style. In particular, those
   operations with the result type <code>unit</code> indicate an
   imperative program. For example, here is a variation on the
   specification of the type of linear containers:
   <pre class="prettyprint ml">
   module type LINEAR_CONTAINER_IMP = sig
     type &alpha; lin
     val empty : unit &rarr; &alpha; lin
     val mem : &alpha; &rarr; &alpha; lin &rarr; bool
     val add : &alpha; &rarr; &alpha; lin &rarr; unit (*procedure*)
     val append : &alpha; lin &rarr; &alpha; lin &rarr; unit (*procedure*)
     val length : &alpha; lin; &rarr; int
     val nth : &alpha; lin &rarr; int &rarr; &alpha;
   end
   </pre>
   The functions <code>add</code> and <code>append</code> here have
   return type <code>unit</code> which imposes the requirement of an
   implmentation necessarily of imperative character.
   </p>
   <p>
   On the other hand, the items specified by a signature may overall
   lead one to adopt an imperative rather than a functional style. For
   example, conser a new version of the preceding signature:
   <pre class="prettyprint ml">
   module type LINEAR_CONTAINER = sig
     type &alpha; lin
     val empty : unit &rarr; &alpha; lin
     val mem : &alpha; &rarr; &alpha; lin &rarr; bool
     val add : &alpha; &rarr; &alpha; lin &rarr; &alpha; lin (*function*)
     val append : &alpha; lin &rarr; &alpha; lin &rarr; &alpha; lin (*function*)
     val length : &alpha; lin; &rarr; int
     val nth : &alpha; lin &rarr; int &rarr; &alpha;
   end
   </pre>
   Apriori this signatures specifies an implementation of functional
   character because the functions <code>add</code>
   and <code>append</code> compute containers rather than a unit
   value. Suppose that we have at our disposal such a representation,
   and suppose we wished to obtain a function that runs through the
   elements of <code>&alpha; lin</code> instances. Here as the only
   access function is <code>nth</code>, which accesses the $n$-th
   element of an instance, it might be tempting to go the way of
   imperative loops adapted to the management of indices. Thus, a
   signature that specifies a data structure have functional character
   that lends itself to recursive decomposition, should also specify
   directly generalized processing functions like iterators or folds.
   </p>

   <h4>Public and private modules</h4>

   <p>
   The mechanisms of encapsulation induce rules about the visibility
   of elements in a structure. An element that is <i>public</i> (or
   'exported') is usable from outside of the encapsulation. An element
   that is <i>private</i> (or 'hidden') is not. So for example, the
   local bindings of a function are private while the fields of a
   record are public. Modules offer a mechanism more nuanced where it
   is possible to explicitly render individual elements public or
   private. This control of visibility allows us to apply techniques
   of information hiding and precise control of the links between
   modules.
   </p>

   <h4>Public and private modules</h4>

   <h5>Public</h5>

   <p>
   First of all, we have already exercised the following rule of visibility:
   <br/>
   <br/>
   <b>Rule (1) of the visibility of modules: </b> The contents of a
   module without an explicit signature are public.  <br/> <br/> For
   example, recall the implementation of a datatype for lists:
  <pre class="prettyprint ml">
   module L = struct 
     type &alpha;lpha lin = Empty | Cons of &alpha; * &alpha; lin
     let empty () = Empty
     let add x l = Cons (x, l)
   end 
  </pre>
   Without explicit signing,
   the module exposes all its contents. The representation of such
   values, <code>&alpha; lin</code> is therefore usable for direct use:
   <pre class="prettyprint ml">
   # L.empty ();;
   - : &alpha; L.lin - L.Emtpy

   # let l1 = L.add 3 (L.empty ());;
   val l1 : int L.lin = L.Cons (3, L.Empty)
   </pre>
   </p>

   <h5>Private</h5>

   <p>
   During the presentation of the rules of explicit typing via
   signatures we did not highlight an important point : the explicit
   typing of a module <code>M</code> by a signature <code>S</code>
   remains valid if at least all of the elements of <code>S</code> are
   defined in <code>M</code>. The rule that follows is the natural
   complement of the behavior of explicit typing since the signature
   acts as interfaces between modules:
   <br/>
   <br/>
   <b>Rule (2) of the visibility of modules: </b> The elements of a
   module <code>M</code> typed explicitly with a
   signature <code>S</code> are public only if they appear
   in <code>S</code> (except for abstract types). All other elements
   in <code>M</code> are private.
   <br/>
   <br/>
   For example, reconsider the
   module <code>Plane_count</code>. This one possesses the following
   signature:
   <pre class="prettyprint ml">
   module type METRIC_SPACE_2D_COUNT = sig
     type point
     val count : int ref
     val make_point : float * float &rarr; point
     val dist : point &rarr; point &rarr; float
   end
   </pre>
   The internal state <code>count</code> appears in the signature. In
   the original rendering of <code>METRIC_SPACE_2D</code> this
   variable was absent:
   <pre class="prettyprint ml">
   module Plane_count : METRIC_SPACE_2D = struct
     type point = {number : int; coord : float * float}
     let count = ref 0 (*Initialization*)
     let make_point (x, y) = incr count; {number = !count; coord = (x, y)}
     let dist p1 p2 = ...
   end;;

   # Plane_count.make_point ;;
   - : float * float &rarr; Plane_count.point

   # Plane_count.count ;;
   Unbound value Plane_count.count
   </pre>
   It is not possible to acces the variable denoted
   by <code>count</code>. Notice that the
   module <code>Plane_count</code> can be considered an instantiation
   of both signatures <code>METRIC_SPACE_2D</code>
   and <code>METRIC_SPACE_2D_COUNT</code>.
   </p>
   <p>Explicit typing implies which properties are important and
   underlies the independence of signatures relative to modules:
   <br/>
   <br/>
   <b>Property (3) of signatures:</b> The same module may instantiate
   multiple distinct signatures.
   </p>

   <h5>Compatibility of signatures</h5>

   <p>
   By what has been said in the previous section, we can now specify a
   reinterpration of the rules of explict typing by signature.
   <br/>
   <br/>
   <b>Compatibility between signatures : </b>
   Suppose <code>M<sub>1</sub></code> is a module satisfying the
   signature <code>S<sub>1</sub></code>; also, <code>M<sub>1</sub></code>
   also satisfies <code>S<sub>2</sub></code>. Then if:
   <ol>
   <li><code>S<sub>1</sub></code> includes <code>S<sub>2</sub></code>
   in terms of its set of elements.</li>
   <li>The types of the elements of <code>S<sub>1</sub></code> are
   respectively, equal to, compatible with or more general than those
   of <code>S<sub>2</sub></code>.</li>
   <li>Certain concrete types in <code>S<sub>1</sub></code> are
   abstract in <code>S<sub>2</sub></code>.</li>
   </ol>
   In this case we will say, the signature <code>S<sub>1</sub></code>
   is compatible with the signature <code>S<sub>2</sub></code>
   and <code>M<sub>1</sub></code> is an instance of both.
   <br/>
   <br/>
   So, the example of the preceding section, the
   signature <code>METRIC_SPACE_2D_COUNT</code> is compatible
   with <code>METRIC_SPACE_2D</code>. Note this definition is in
   general accord with the general definition of the compatibility of
   types. It can also be described as <i>structural</i> : it depends
   only on the form of the signatures, it does not need to be made
   explicit by the programmer.
   </p>

   <p>
   The compatibility between signatures must be associated with
   another possibility of modules which brings them closer to the
   usual behavior of values : a module may be bound to an arbitrary
   number of distinct identifiers. It is indeed possible to construct
   new bindings of modules to existing modules. For example:
   <pre class="prettyprint ml">
   # module P = Plane_count;;
   </pre>
   Here the module <code>P</code> is made to be a reference to the
   same implementation of the module <code>Plane_count</code>. It is
   similar to the effect to that which governs the definition of new
   bindings by <code>let</code> : a new copy of the
   module <code>Plane_count</code> is not produced (in this imperative
   example, the internal counter of the <code>Plane_count</code>
   points will be shared).
   </p>

   The construction of such module links can obviously be accompanied
   by explicit typing and under the umbrella of the notion of
   compatibility:
   <pre class="prettyprint ml">
   # module P1 : METRIC_SPACE_2D = Plane_count;;
   # module P2 : METRIC_SPACE_2D_COUNT = Plane_count;;
   </pre>
   or, in an equivalent manner:
   <pre class="prettyprint ml">
   # module P1 = (Plane_count : METRIC_SPACE_2D);;
   # module P2 = (Plane_count : METRIC_SPACE_2D_COUNT);;
   </pre>
   The explicit typing here authorises multiple visibilities of the
   same module : the module <code>P<sub>2</sub></code> exports all the
   elements of the <code>Plane_count</code> module whereas the
   module <code>P<sub>1</sub></code> just those elements that appear
   in the signature <code>METRIC_SPACE_2D</code>. Such multiple views
   can make sense in many situations. For example:
   <ul>
   <li><i>Distinguishing between error search phases.</i>  Elements
   are made public to be deprived but on which an error search applies
   (I have no idea what this means either)</li>
   <li><i>Distinguishing between access levels.</i> More or less of
   complete access is granted to the users of a module.</li>
   </ul>
   Note that this explicit typing via signatures can be phrased in
   terms of the classical type-transformation term of an "up-cast", a
   term which tenotes transformation of the the type of an element in
   the sense of a compatibility relation. A restriction on the "window
   of visibility" of a module by becoming the instance of a more
   general signature. The reverse, that is a type-transformation of
   the form of a "down-cast" is not allowed. There are in fact no more
   traces of the initial shape of a module after an up-cast. For
   example, if we now reconsider the previous example:
   <pre class="prettyprint ml">
   # module P1 : METRIC_SPACE_2D = Plane_count;;
   # module P2 : METRIC_SPACE_2D_COUNT = P1 ;;
   Signature error
   </pre>
   It is not possible to retrieve the initial module by an <i>a
   posteriori</i> retyping to its complete signature.
   </p>

   <h5>Public exceptions</h5>

   <p>
   In the context of explicit typing, the exporting of exceptions
   necessarily passes through their definition in the signature. For
   example:
   <pre class="prettyprint ml">
   module type FACT = sig
     exception Neg
     val fact : int &rarr; int
     (*Raises [Neg] if the given argument is negative*)
   end;;

   module E : FACT = struct
     exception Neg
     let rec fact n = ...
   end;;
   </pre>
   Conforming to the rules of explicit typing by signatures, an
   instantiation of the signature <code>FACT</code> includes
   necessarily the exception <code>Neg</code>. This double definition
   is a mark of exporting an exception and makes it usuable outside
   the module:
   <pre class="prettyprint ml">
   # E.Neg ;;
   - : exn = E.Neg
   </pre>
   The interest in exporting them of course is to make possible their
   processing from outside the module. Their appearence in the
   signature gives more opportunity to specify the character of the
   functions likely to use them. Their commentary can thus help
   prepare for the treatment of errors. Note however, some exceptions
   need not be exported. They can sometimes be restricted to
   exploitation by the private implementation of the module. Recall
   also that their exists in OCaml a fairly large collection of
   predefined exceptions that are global.
   </p>

   <h5>Public types</h5>

   <p>
   With explicit typing by signatures, as for exceptions, to export
   types from a module requires their implementation in the
   signature. In other words, the types must be concrete and not
   abstract if they are to be exported. For example, consider complex
   numbers, but this time with a representation in the form of records
   which integrate both the real part, their imaginary part and their
   precalculated norm:
   <pre class="prettyprint ml">
   module type COMPLEX = sig
     type complex = {real : float; im : float; norm : float}
     val make : float * float &rarr; complex
     val add : complex &rarr; complex &rarr; complex
     val norm : complex &rarr; float
   end;;
   </pre>
    The definition of the type <code>complex</code> within the
    signature renders it public for any instantiation. In particular,
    the fields of the record are directly usable:
   <pre class="prettyprint ml">
   module Complex : COMPLEX = struct
     type complex = {real : float; im : float; norm : float}

     let make (r, i) = {re = r; im = i;
                        norm = sqrt (r ** 2. + i ** 2.)}
     let add z w = ...
     let norm z = z.norm
   end;;

   # let zq = Complex.make (4., 3.);;
   val z1 : Complex.comple = 
     {Complex.re = 4.; Complex.im = 3.; Complex.norm = 5}

   # z1.Complex.re;;
   - : float = 4.

   # z1.Complex.norm;;
   - : float = 5.
   </pre>
   However, the interest of exporting types is questionable. For
   example, one observes here an interaction between the
   field <code>norm</code> and the function <code>norm</code> and
   assumes an equivalence. The relationship between the declared norm
   and the calculated norm can nevertheless take a more sophisticted
   turn.
   </p>

   <h5>Private and abstract types</h5>

   <p>
   A final development is necessary regarding visibility and the
   explicit typing of modules. As stated in the "rule (2) of the
   visibility of modules", there is a particular case: when explicitly
   typing modules with signatures, an abstract type is not rendered
   public. The abstract character of such types is
   maintained. Modifying the previous example:
   <pre class="prettyprint ml">
   module type COMPLEX = sig
     type complex (*abstract*)
     val make : float * float &rarr; complex
     ...
   end;;
    
   module Complex : COMPLEX = struct (*explicit type*)
     type complex = {real : float; im : float; norm : float}

     let make (r, i) = {re = r; im = i;
                        norm = sqrt (r ** 2. + i ** 2.)}
     ...
   end;;

   # let z1 = Complex.make (4., 3.);;
   val z1 : Complex.complex = &lt;abstr&gt;

   # z1.Complex.re
   Unbound record field label
   </pre>
   The responses of the type inference hide here the representation of
   the type mentioning only that it is <code>&lt;abstr&gt;</code>. It
   is therefore impossible to access directly, even to display, the
   values associated with a complex number. Specific accessors are now
   indispensable. It is possible to extend the
   signature <code>COMPLEX</code> with a general accessor, here we'll
   name it <code>show</code> which returns a complex number in the
   form of a pair of <code>float</code>:
   <pre class="prettyprint ml">
   module type COMPLEX = sig
     type complex (*abstract*)
     val make : float * float &rarr; complex
     val show : complex &rarr; float * float
     ...
   end;;

   module Complex : COMPLEX = struct (*explicit type*)
     type complex = {real : float; im : float; norm : float}

     let make (r, i) = {re = r; im = i;
                        norm = sqrt (r ** 2. + i ** 2.)}

     let show z = (z.re, z.im)

     ...
   end;;
   </pre>
   The type <code>complex</code> is henceforth hidden, instantiable
   and exploitable:
   <pre class="prettyprint ml">
   # let z1 = Complex.make (4., 3.);;
   val z1 : Complex.complex = &lt;abstr&gt;

   # Complex.show z1;
   - : float * float = (4., 3.)
   </pre>
   </p>

   <p>
   Certain types of data lend themselves to the hiding of their
   representation better than others. For example, those
   data-structures that naturally provide accessors and constructors
   of empty structures or of particular sizes. Let us recall the
   following example:
   <pre class="prettyprint ml">
   module type LINEAR_CONTAINER = sig
     type &alpha; lin
     val empty : unit &rarr; &alpha; lin (*constructor*)
     val add : &alpha; &rarr; &alpha; lin &rarr; &alpha; lin
     val nth : &alpha; lin; &rarr; int &rarr; &alpha; (*accessor*)
   end;;

   module L : LINEAR_CONTAINER = struct
     type &alpha; lin = Empty | Cons of &alpha; * &alpha lin
     let empty () = Empty
     let add x l = ...
     let nth l n = ...
   end;

   # let l1 = L.add 111 (L.add 666 (L.empty ()));;
   val l1 : int L.lin = &lt;abstr&gt;

   # L.nth l1 1;;
   - : int = 666
   </pre>
   The universal type parameter <code>&alpha;</code> can be equally
   well instantiated with a hidden type as with a public type. In
   other words, the responsibility of msasking the values contained by
   the containers is left in the hands of the users. For example, it is
   possible to insert a hidden complex number in the container of
   type <code>&alpha; lin</code>:
   <pre class="prettyprint ml">
   # let l1 = L.add (Complex.make (4.0, 3.0)) (L.empty ());;
   val l1 : Complex.complex L.lin = &lt;abstr&gt;

   # L.nth l1 0;;
   - : Complex.complex = &lt;abstr&gt;
   </pre>
   Of course, the application of the <code>show</code> accessor is required if it is desired to obtain the explicit values:
   <pre class="prettyprint ml">
   # Complex.show (L.nth l1 0);;
   - : float * float = (4., 3.)
   </pre>
   We therefore have the possibility to implement controlled
   visibility of the elements which make up a module. In the case of
   the implementation of data types, this complete mastery of
   visibility permits us to define abstract data types where details
   of the representation are necessarily hidden (and therefore based
   on abstract types in the corresponding signatures).
   </p>

   <h4>Abstract data types</h4>

   <h5>The reasons for hiding and substitution</h5>
   <p>
   Visibility control of the elements of modules, in other words
   - <i>implementation hiding</i> - is an important tool for the
   production of modular programs of quality. Hiding in effect assures
   indepdence between modules. Without that independence, certain
   properties mentioned at the outset of the section are
   compromised. For example, implementation dissemination can make it
   difficult to make any subsequent changes and adapations and
   extensions tedious and delicate to carry out.
   </p>
   <p>
   On the other hand, hiding is based on signatures, that is, elements
   that describe the programm without fixing on or revealing an
   implementation (the specification). The signatures contain the
   abstractions, the interfaces, a screen over the particulars of a
   program. However the signatures indicate as well the organisation
   of the program composed as distinct modules. They represent by
   themselves the logical architecture.
   </p>
   <p>
   If the properties sought through modular programming have so far
   been expressed in a very general way, what has just been said has
   allowed us to establish a principal that more concretely
   characterize a good modular organisation:
   <br/>
   <br/>
   <b>The principle of modular substitutivity : </b> Let <b>S</b> be
   the set of signatures that specify a modular program <i>Prog</i>,
   and let <code>M</code> be a component of <i>Prog</i> that satisfies
   a signature <code>S</code> \(\in\) <b>S</b>. Then, any component
   that also satisfies <code>S</code> may be substituted
   for <code>M</code> without any other modifications of <i>Prog</i>.
   <br/>
   <br/>
   This principle expresses what is meant by "to be independent" in
   the case of a set of modular components. It gives rise to a similar
   virtue of the notion of referential transparency in functional
   programming, that is to say, a strict localization of the effects
   of an action on the program. Under the aegis of the "principle of
   substitutivity", a program can be first specified and its
   realization and development broken down component by component.
   </p>
   <p>
   In the following, we now illustrate some of the ideas of
   implementation of abstract data types and present precise
   techniques offed by OCaml to implement them. We shall then return
   to these general questions.
   </p>

   <h5>How to evolve datatypes</h5>

   <p>A representative situation for evolution in modifying programs
   consists of adaptions in the interest of performance improvments in
   time and space. Optimisation is often performed after an operation
   is revealed to be complex and tedious. It is therefore economic in
   the early phases of development of a program to make it easy to
   return thereafer and substitute more efficient code.
   </p>
   <p>
   In the context of abstract data types, these modifications lead
   generally to representations that are very far removed from those
   that seem natural at the outset. In effect, the implementations
   then carry technical information which contributes to the
   optimization of their associated functions. We have already seen
   several examples. For example, consider the case of the
   specification of a datatype for queues:
   <pre class="prettyprint ml">
   module type FIFO_CONTAINER = sig
     type &alpha; queue
     val empty : unit &rarr; &alpha; queue
     val add : &alpha; &rarr; &alpha; queue &rarr; &alpha; queue
     val fst : &alpha; queue &rarr; &alpha;
     val out : &alpha; queue &rarr; &alpha; queue
   end;;
   </pre>
   The signature could be directly implemented with a list and without
   too much regard to the effects of the persistent nature resulting
   from being of functional character:
   <pre class="prettyprint ml">
   module Q_list : FIFO_CONTAINER = struct
     type &alpha; queue = &alpha; list
     let empty () = []
     let add x q = q @ [x]
     let fst q = ...
     let out q = ...
   end;;
   </pre>
   The signature however, equally allows for an implementation
   optimized for queues:
   <pre class="prettyprint ml">
   module Q_burton : FIFO_CONTAINER = struct
     type &alpha; queue = Q of &alpha; list * &alpha; list
     let empty () = Q ([], [])
     let add x (Q (l1, l2)) = ...
     let fst q = ...
     let out q = ...
   end;;
   </pre>
   This change of representation is transparent to any user who is
   restricted to the signature <code>FIFO_CONTAINER</code> : the
   module <code>Q_burton</code> may be directly substituted
   for <code>Q_list</code> even though the representations are quite
   different.
   </p>
   <p>
   Here's another classic example for the structure of association
   tables. These tables may be initially specified in a minimal way:
   <pre class="prettyprint ml">
   module type ASSOC_TABLE = sig
     type (&alpha;, &beta;) assoc
     val empty : unit &rarr; (&alpha;, &beta;) assoc
     val get_pair : (&alpha;, &beta;) assoc &rarr; &alpha; * &beta;
     val assoc : (&alpha;, &beta;) assoc &rarr; &alpha; &rarr; &beta;
     val add : &alpha; &rarr; &beta; &rarr; (&alpha;, &beta;) assoc &rarr; (&alpha;, &beta;) assoc
     val sub : &alpha; &rarr; (&alpha;, &beta;) assoc &rarr; (&alpha;, &beta;) assoc
   end;;
   </pre>
   This signature is easily implemented as a list:
   <pre class="prettyprint ml">
   module Assoc_list : ASSOC_TABLE = struct
     type (&alpha;, &beta;) assoc = (&alpha; * &beta;) list

     let empty () = []

     let get_pair l = 
       try
         List.hd l 
       with
       | Failure "hd" &rarr; failwith "No pair"

      let assoc l key = List.assoc key l

      let add key data l =
        try (assoc l key; failwith "Already inserted")
        with | Not_found &rarr; (key, data) :: l
     
      let sub key l = ...
   end;;

   # let t1 = Assoc_list.add 1 &alpha;' (Assoc_list.empty ());;
   val t1 : (int, char) Assoc_list.assoc = &lt;abstr&gt;

   # let t1 = Assoc_list.add 2 &beta;' t1;;
   val t1 : (int, char) Assoc_list.assoc = &lt;abstr&gt;

   # Assoc_list.assoc t1 1;;
   - : char = &alpha;'
   </pre>
   When the elements of an association table are frequently accessed,
   it is normal to organise the association table in order that
   accessing elements is of logarithmic complexity. For this we can
   utilize the simple definition of binary search trees but of the
   balanced variety, for example, red-black trees:
   <pre class="prettyprint ml">
   module Assoc_rb_tree : ASSOC_TABLE = struct
     type color = R | B

     type (&alpha;, &beta;) assoc =
       | Empty
       | Node of color * (&alpha;, &beta;) * (&alpha;, &beta;) assoc * (&alpha;, &beta;) assoc

     let empty () = Empty
 
     let get_pair t = match t with
       | Empty &rarr; failwith "No pair"
       | Node (_, x, _, _) &rarr; x

     let rec assoc t key = match t with
       | Empty &rarr; raise Not_found
       | Node (_, (key', data), l, r) &rarr;
           if key = key' then data else
           if key < key' then assoc l key 
           else assoc r key

      let local_balance = ...
      let add key data t = ...
      let sub key t = ...
   end;;
   </pre>
   Again, the optimisation can be used transparently due to
   conformance to the <code>ASSOC_TABLE</code> signature:
   <pre class="prettyprint ml">
   # let t1 = Assoc_rb_tree.add 1 &alpha;' (Assoc_rb_tree.empty ());;
   val t1 : (int, char) Assoc_rb_tree.assoc = &lt;abstr&gt;

   # let t1 = Assoc_rb_tree.add 2 &beta;' t1;;
   val t1 : (int, char) Assoc_rb_tree.assoc = &lt;abstr&gt;

   # Assoc_rb_tree.assoc t1 1;;
   - : char = &alpha;'
   </pre>
   One obtains the same behavior as for the preceding implementation.
   </p>

   <h5>Optimizing datatypes by "memoization"</h5>

   <p>
   Here are other examples of abstract data types using a particular
   optimization technique. Recall the case of complex numbers with a
   representation that includes a pre-calculated norm. If this value
   is not used, this calculation becomes useless. One way to remedy
   this situation is to calculate it on first use (this is called
   "memoization"). Here is an implementation which qpplies this
   technique that equally well satisfies the
   signature <code>COMPLEX</code>:
   <pre class="prettyprint ml">
   module Complex_memo : COMPLEX = struct
     type complex = { re : float; im : float;
                      mutable norm : float option } (*memoization*)

     let make (r, i) = { re : r; im : i; norm = None}

     let show z = (z.re; z.im )

     let add z w = make (z.re +. w.re, z.im +. w.im)

     let norm z = match z.norm with
       | Some x &rarr; x
       | None &rarr; let m = sqrt (z.re ** 2. + z.im ** 2.) in
                 (z.norm <- Some m; m)
   end;;
   </pre>
   This optimization is transparent from the point of view of using
   complex numbers through the signature <code>COMPLEX</code>:
   <pre class="prettyprint ml">
   # let z1 = Complex_memo.make (3., 4.);;
   val z1 : Complex_memo.complex = &lt;abstr&gt;

   # let z2 = Complex_memo.add z1 z1;
   val z2 : Complex_memo.complex = &lt;abstr&gt;

   # Complex_memo.show z2;;
   - : float * float = (8., 6.)
   </pre>
   There are cases where memoization of all calculations proves to be
   unsuitable or too heavy. For example, successive searches into a
   data structure can not all be transformed into immediate
   access. The idea is rather to put in place "caches" which provide
   direct references only for the most recent searches. These caches
   act as a set of opportunities to take "shortcuts". A problem then
   arises when one modifies the data structure: elements that are
   deleted by are nevertheless referenced by a cache are not
   recoverable by the garbage collector; they remain referenced by
   their shortcuts but they may not be utilized as they no longer
   exist... A solution to this paradox is offered by the notion of
   a <i>weak</i> reference, that is a reference to an element the
   garbage collector is entitled to recover. As long as these element
   exist, these references make it possible to reach them; if these
   elements are to be destroyed, these references do not impede the
   garbage collector in harvesting them.
   </p>
   <p>
   The <code>Weak</code> module in the OCaml stanard library provides
   an implementation of a table of weak references. For example, we
   can integrate the technique of memoization by caches with an
   inmplementation of a table of associations : each will have an
   individual cache that will allow to reach directly the elements
   previously accessed. The association function will therefore give
   priority to the cache and then, in the case of failure on the table
   of associations. This operation will also be responsible for
   updating the cache. Here is an implementation based on binary trees
   that satisfies the signature <code>ASSOC_TABLE</code>:
   <pre class="prettyprint ml">
   module Assoc_tree : ASSOC_TABLE = struct
     let cache_size = 5 (*fixed cache size*)

     type (&alpha;, &beta;) bintree = 
       | Bin_empty
       | Bin_node of (&alpha; * &beta;) * (&alpha;, &beta;) bintree * (&alpha;, &beta;) bintree

     type (&alpha;, &beta;) assoc = { tree : (&alpha;, &beta;) bintree ;
                             cache : (&alpha; * &beta;) Weak.t ;
                             mutable index : int
                          }

      let empty () = { tree = Bin_empty; 
                       cache = Weak.create cache_size;  
                       index = 0}

      let get_pair { tree = t } = match t with
        | Bin_empty &rarr; failwith "No pair"  
        | Bin_node &rarr; (x, _, _) &rarr; x

      let assoc_direct table key =
        let rec aux t = match t with
          | Bin_empty &rarr; raise Not_found
          | Bin_node ((key'; data'), t1, t2) &rarr;
              if key = key' then data' else
              if key < key' then aux t1 else aux t2
        in aux table.tree

      let assoc table key =
        let res = ref None in
        let index = ref 0 in
        begin (*search the cache*)
          while (!index < cache_size) && (!res = None) do
            match Weak.get table.cache !index with
              | Some (key', data) &rarr;
                  if key = key' then res := Some data else incr index
              | None &rarr; incr index
          done ;
          match !res with
            | Some x &rarr; x
            | None &rarr;
                let data = assoc_direct table key in
                Weak.set table.cache table.index (Some (key, data));
                table.index <- (table.index + 1) mod cache_size;
                data
        end

       let add key data table = ...
       let sub key table = ...
   end;;
   </pre>
   Obviously, this implementation is much more complex than the others
   and only really justified for very large trees. However, the
   optimization is still transparent to the user. All these examples
   show that an improvement of a data type could include radical
   changes in the form of its instances. Exporting of the
   representation of these types would be very bad if they had to be
   modified after their dissemination into the code. This work could
   prove to be not only laborious but problematic. Indeed, the user
   might find herself in the necessity of managing the creation, the
   coherence and the processing in the module associated with the
   datatype. That said, implementation hiding is a technique not
   without difficulties and traps. We will develop some of them in the
   following. Let us first recall that the type
   variables <code>&alpha;</code>, <code>&beta;</code> etc are instantiable in
   masked types. On the other hand, only structural functions are
   capable of offering a universal generiticy, that is to say, a truly
   uniform treatment of their arguments whatever the representation.
   </p>

   <h5>Hiding and generating predefined predicates</h5>

   <p>
   The multiple implementations of the last few pages have established
   the framework of the "principle of module substituion". Optimized
   versions have replaced non-optimized versions transparently. This
   is only possible however if we take care to avoid transmitting
   implicitly someting concealed between the components in spite of
   their adherence to their respective signatures.
   </p>
   <p>
   There exists a case in OCaml which is particularly representative
   of this difficulty. For example, reconsider the complex number
   type <code>Complex_memo</code> which uses memoization for the
   norm. The representation of values of the type is the following:
   <pre class="prettyprint ml">
   type complex = {re : float; im : float; mutable norm : float option}
   </pre>
   Recall that the predefined equality operator '<code>=</code>' over
   records, compares each field. Under these conditions, the equality
   function is no long valid on such a lazy representation:
   <pre class="prettyprint ml">
   # let z1 = Complex_memo.make (1., 1.1)
     let z2 = Complex_memo.make (1., 1.1);;

   # z1 = z2;; 
   - : bool = true

   # Complex_memo.norm z1;
   - : float = 1.414213

   # z1 = z2;;
   - : bool = false
   </pre>
   The origin of this behavior may be even more difficult to discover
   when comparison predicates are used by other functions. For example:
   <pre class="prettyprint ml">
   # let z1 = Complex_memo.make (1., 1.)
     let z2 = Complex_memo.make (1., 1.)
     let l1 = [z1; z1; z1];;

   # List.mem z2 l1;;
   - : bool = trure

   # Complex_memo.norm z1;;

   #List.mem z2 l1;
   - : bool = false
   </pre>
   Implmentation of the function <code>List.mem</code> utilizes the
   default equality function.
   </p>
   <p>Thus, the contribution of these comparison predicates puts in
   peril the independence of modular components. The earlier example
   shows that moving from a trivial implementation of complex numbers
   to an implementation with memoisation induces noticeable
   differences in behavior.
   <br/>
   <br/>
   <b>Constraint (1) of substitutivity : </b> The principle of module
   substitutivity is not strictly applicable in OCaml when abstract
   types are used by functions that use comparison functions of their
   instances.  <br/> <br/> In particular, a signature for complex
   numbers must inclue an explicit specification of functions to
   compare them to work around the problems just discussed:
   <pre class="prettyprint ml">
   module type COMPLEX = sig
     type complex
     val make : float &rarr; float &rarr; complex
     val show : complex &rarr; float * float
     val eq : complex &rarr; complex &rarr; bool
     val less_than_eq : complex &rarr; complex &rarr; bool
     ...
   end;;
   </pre>
   </p>

   <h5>Hiding and imperative optimizations</h5>

   <p>
   We have seen examples using imperative features whilst ensuring
   partioning of this style: nothing was visible outside of the
   module. The values were simply associated with modifiable
   information that optimized their evaluation. The only noticeable
   effect in this case is an "evaluation sharing" which does not alter
   referential transparency. The preceding section illustrates the
   problem of comparing values by means of the default predicates but
   this difficulty was related only to an interaction between hiding
   and restrained generiticy of the predicates. It would be possible
   to envisage transformations of the implementation of a module
   integrating more fully the imperative style. For example, here is a
   signature specifying the type of sets:
   <pre class="prettyprint ml">
   module type SET = sig
     type &alpha; set
     val empty : unit &rarr; &alpha; set
     val mem : &alpha; &rarr; &alpha; set &rarr; bool
     val add : &alpha; &rarr; &alpha; set &rarr; &alpha; set
     val union : &alpha; set &rarr; &alpha; set &rarr; &alpha; set
     val inter : &alpha; set &rarr; &alpha; set &rarr; &alpha; set
   end;;
   </pre>
   It is possible first of all to utilize a functional representation
   of sets:
   <pre class="prettyprint ml">
   module Set_fun : SET = struct
     type &alpha; set = &alpha; &rarr; bool
     let empty () = fun y &rarr; false
     let mem x s = s x
     let add x s = if mem x s then s else fun y &rarr; s y || x = y
     let rec union s1 s2 = fun y &rarr; s1 y || s2 y
     let rec inter s1 s2 = fun y &rarr; s1 && s2 y
   end;;
   </pre>
   So,
   <pre class="prettyprint ml">
   # let s1 = Set_fun.add 1 (Set_fun.add 2 (Set_fun.empty ()));;
   val s1 : int Set_fun = &lt;abstr&gt;

   # Set_fun.mem 2 s1;;
   - : = true
   </pre>
   The purely functional style allows here a terse and not conductive
   to errors program. On the other hand, the complexities in time and
   space are high. Consequently, seceral possibilities of optimization
   might be contemplated. Association tables for example might be
   considered for exploiting an ordering of the elements of the set
   and thereby inducing a tree like structure. One could also
   contribute a hash table of imperative character such as to be found
   in the <code>Hashtable</code> module of the standard library. Note
   that tables are presented as association tables. In order to use
   them as simple tables, the usual tactic is to systematically
   associate keys with constants. The latter can then correspond to
   the elements of the set. Here is a new implementation that
   satisfies <code>SET</code>:
   <pre class="prettyprint ml">
   module Set_h : SET = struct
     type &alpha; set = (&alpha;, unit) Hashtbl.t

     let dummy = ()

     let empty () = Hashtbl.create 0

     let mem x h = Hashtbl.mem x

     let add x h1 =
       if mem x h1 then h1
       else let h = Hashtbl.copy h1 in (Hashtbl.add h x dummy; h)

     let union h1 h2 =
       let h = Hashtbl.copy h1 in
       Hashtbl.iter (fun x _ &rarr; ignore (add x h)) h2; h

     let inter h1 h2 =
       let h = empty () in
       Hashtbl.iter (fun x _ &rarr;
         if (Hashtbl.mem h1 x) && (Hashtbl.mem h2 x) then
           Hashtbl.add h x dummy) h1; h
   end;;
   </pre>
   Then, in the same manner as <code>Set_func</code> :
   <pre class="prettyprint ml">
   # let s1 = Set_h.add 1 (Set_h.add 2 (Set_h.empty ()));;
   val s1 : int Set_h = &lt;abstr&gt;

   # Set_h.mem 2 s1;;
   - : = true
   </pre>
   Due to the use of hash tables, accessing the elements of the set is
   fast (the function <code>mem</code> is guaranteed to return in
   constant time). However, it should be noted this implementation
   preserves the functional character of the specification of the
   operation <code>add</code>, that is,
   <pre class="prettyprint ml">
   val add : &alpha; &rarr; &alpha; set &rarr; &alpha; set
   </pre>
   Indeed, the implementation of <code>add</code>
   in <code>Set_h</code> causes the sets to be persistent : each
   insertion implies a complete copy of the hash table. We could of
   course override this property of <code>add</code> so as to
   camouflage it's imperative behavior :
   <pre class="prettyprint ml">
   # let add x h1 =
       if mem x h1 then h1
       else (Hashtbl.add h1 x dummy; h1)
   val add : &alpha; &rarr; &alpha; set &rarr; &alpha; set
   </pre>
   We refer here to the table <code>h1</code> after
   modification. However, doing so give rise to the problems of
   referential transparency no longer being verified in an expression
   making use of these sets and delicate errors may result.
   </p>
   <p>
   This exmaple illustrates the neccessity of reflecting clearly the
   intent of the style of the signature and to conform to it.
   <br/>
   <br/>
   <b>Constraint (2) of substitutivity : </b> The pricinciple of
   module substitutivity is not strictly applicable in a functional
   framework if imperative features are not strictly
   compartmentalized.
   <br/>
   <br/>
   In other words, the preservation of the substitution principle
   justfies what is illustrated in:
   <br/>
   <br/>
   <b>Indication of imperative features in the specificiation : </b>
   In signatures, those operations with imperative behavior appear as
   procedure declarations (results are of type <code>unit</code>).
   <br/> <br/> For example, if full use were to be made of a table of
   imperative style, the signature <code>SET</code> should reflect
   this:
   <pre class="prettyprint ml">
   module type SET = sig
     type &alpha; set
     val add : &alpha; &rarr; &alpha; set &rarr; unit
     ...
   end;;
   </pre>
   The function for adding an element to a set exhibits an imperative
   character.
   <pre class="prettyprint ml">
   # let add x h =
       if not (mem x h) then Hashtbl.add h x dummy;;
   val add : &alpha; &rarr; &alpha; set &rarr; unit
   </pre>
   This example shows again the difficulties of preventing propagation
   of the imperative style. If its application gives rise to
   behavioral changes which escape a specification, they will surprise
   and demand consequent work of a search for errors : an expected
   effect when the principle of substitutivity applies only in
   pretense. The strict partitioning of styles however here leads to a
   multiplication of signatures : the ones in a style purely
   functional, the others in the imperative style. Optmization via
   imperative constructs is not directly applicable. It is however
   possible to unify signatures by application of a generalization for
   the return types of functions. Indeed, in the framework of
   implementing abstract data types, these types characterize the
   style alone. For example,
   <pre class="prettyprint ml">
   module type SET_GEN = sig
     type &alpha; set
     type &alpha; result
     ...
     val add : &alpha; &rarr; &alpha; set &rarr; &alpha; result
     ...
   end;;
   </pre>
   The type <code>&alpha; result</code> can be instaniated either by
   the same type as <code>&alpha; set</code> indicating a functional
   implementation or, by by <code>unit</code> indicating an imperative
   one.
   </p>
   
   <h5>The need for individual hiding of abstract types</h5>

   <p>
   Our current knowledge of the control of type visibility is
   summarized in the following alternative when a
   signature <code>S</code> is used to explicitly type a
   module <code>M</code>:
   <ul>
   <li>A concrete type in <code>S</code> is public</li>
   <li>A type abstract in <code>S</code> is private to <code>M</code></li>
   </ul>
   These possibilities lack a little nuance. We might sometimes want
   to export an abstract type of <code>S</code> after its
   implmentation in <code>M</code>. But what are the situations that
   engener the need to derogate from type abstraction? Here is the
   representative case. When the represntation of values is to be
   hidden but there is a need to use its constructors as
   accessors. The constructors must then have arguments whose types
   are public and the accessors must also have results whose types are
   public. For example, the signature <code>COMPLEX</code> declares
   functions in the following form:
   <pre class="prettyprint ml">
   val make : float * float &rarr; complex
   val show : comple &rarr; float * float
   </pre>
   Here the respective types of the parameters and the result are
   based on the predefined type <code>float</code>. This constraint is
   probably acceptable for conventional use but it will prevent the
   implementation of certain implementations. Suppose we wished to
   obtain a type for "big complex numbers" from the library
   module <code>Num</code>, that is to say,
   <pre class="prettyprint ml">
   module Complex_num = struct
     type complex = C of Num.num * Num.num

     let make (str_r, str_i) = 
       C (Num.num_of_string str_r, Num.num_of_string str_i)

     let show (C (r, i)) =
       (Num.string_of_num r, Num.string_of_num i)

     let add (C (r1, i1)) (C (r2, i2)) =
       C (Num.( + ) r1 r2, Num.( + ) i1 i2)

     let norm (C (r, i)) =
       sqrt (Num.float_of_num 
         (Num.add_num (Num.square_num r) (Num.square_num i)))
   end;;
   </pre>
   These complex numbers possess real and imaginary parts that are
   abitrarily large and precise:
   <pre class="prettyprint ml">
   # let z1 = Complex_num.make ("3214321/764365", "8920146398/4291")
     let z2 = Complex_num.add z1 z1;;
   # Complex_num.show z2;
   - : string * string = ("3214321/764365", "8920146398/4291")
   </pre>
   It is observed that the types of the parameters of the constructor
   and the accessor of the module <code>Complex_num</code> have
   undergone a transformation. The exterior representation of large
   numbers from <code>Num</code> uses strings instead of floating
   numbers.
   <pre class="prettyprint ml">
   val make : string * string &rarr; complex
   val show : complex &rarr; string * string
   </pre>
   The module <code>Complex_num</code> does not satisfy the
   signature <code>COMPLEX</code>. We can nevertheless generalize will
   this signature with respect to the types of constructors of the
   accessors.
   <br/>
   <br/>
   <b>Technique of generalization of constructors/accessors for
   external types</b> : If <code>t</code> is the representation of
   values of a datatype, we associate a type <code>extern_t</code>
   which constitues the externally view of an instance of
   type <code>t</code>.  
   <br/>
   <br/>
   Thus, in <code>COMPLEX</code> we replace the type <code>float *
   float</code> with a new abstract type <code>extern_complex</code>:
   <pre class="prettyprint ml">
   module type COMPLEX_MASK = sig
     type complex
     type extern_complex
     val make : extern_complex &rarr; complex
     val show : complex &rarr; extern_complex
     val add : complex &rarr; complex &rarr; complex
     val norm : complex &rarr; float
   end;;
   </pre>
   The definition of the type <code>extern_complex</code> can then be
   added to <code>Complex_num</code>:
   <pre class="prettyprint ml">
   module Complex_num = struct
     type complex = C of Num.num * Num.num
     type extern_complex = string * string
     ...    
   end;;
   </pre>
   This implementation becomes compliant to the
   signature <code>COMPLEX_MASK</code>:
   <pre class="prettyprint ml">
   module Complex_num : COMPLEX_MASK = struct
    ...
   end;;
   </pre>
   However, the types <code>complex</code>
   and <code>extern_complex</code> are now both made private by this
   explict typing. The functions <code>make</code>
   and <code>show</code> have become unusable:
   <pre class="prettyprint ml">
   # let z1 = Complex_num.make ("3214321/764365", "8920146398/4291");;
   Type error
   </pre>
   This technique of generalization has augmented the possibilities of
   instantiation of the signature but has neccessarily requires to
   export certain abstract types after their implementation. This
   situation find itself in connection with the
   signature <code>SET_GEN</code> whose definitions of the generalized
   type <code>&alpha; result</code> will also have to be exported. In
   other words, we need a new rule of visibility of individual hiding
   of abstract types. The more careful control of the visibility of
   the types will be possible thanks to a new construction which will
   be described in the following.
   </p>

   <h5>Individual hiding and type constraints</h5>
   <p>
   Signatures can be supplemented by explicit type constraints. The
   constraints are capable of associating <i>a posteriori</i> with
   definitions of abstract types, and are expressed through the
   construction <code>with type</code>:
   <pre class="prettyprint ml">
   &lt;SIGNATURE&gt; with type &lt;type 1&gt; = &lt;expression of type 1&gt;
                     and type ...
                     and type &lt;type n&gt; = &lt;expression of type n&gt;
   </pre>
   where the <code>&lt;type i&gt;</code> denote types included
   in <code>&lt;SIGNATURE&gt;</code> and the <code>&lt;expression of
   type i&gt;</code> is a valid type definition in the environment at
   the moment of application of the type constraint. For example:
   <pre class="prettyprint ml">
   # module type S1 = sig
       type t
       val f : t &rarr; t
     end;;

   # module type S2 = (S1 with type t = int);;
   module type S2 = sig
     type t = int
     val f : t &rarr; t
   end
   </pre>
   Thanks to this constraint, the abstract type <code>t</code> is
   abstract in <code>S1</code> and made concrete in <code>S2</code>.
   <br/>
   <br/>
   <b>Making types concrete with the <code>with type</code>
   construction</b>: Type constraints can make concrete types of types
   that were not originally so. These types then become exportable.
   <br/> <br/> A signature can thus see some of its abstract types
   become concrete. This transformation resolves the problem posed by
   the signature <code>CONCRETE_MASK</code> of the preceding section:
   <pre class="prettyprint ml">
   module Complex_num : COMPLEX_MASK
      with type extern_complex = string * string =
   struct
     type complex = C of of Num.num * Num.num
     type extern_complex = string * string
     let make (str_r, str_i) = ...
     let show (C (r, i)) = ...
       ...
   end;;
   </pre>
   The constructor <code>make</code> becomes accessible from outside
   the module:
   <pre class="prettyprint ml">
   # let z1 = Complex_num.make ("3214321/764365", "8920146398/4291");;
   val z1 : Complex_num.complex = &lt;abstr&gt;
   </pre>
   </p>
   <p>
   Here are some remarks to help with usage of type constraints:
   <ul>
   <li><i>Neccessary duplication.</i> The syntax imposed by the
   construction <code>with type</code> sometimes seems somwhat
   fastidious since it requires a flagrant duplication between the
   type constraints and the definitions in the module. The
   implementation of the module must be consistent with the signature
   transformed by the addition of the type constraint. This
   duplication of code is the same as that which occurs in the
   relationship between signatures directly containing concrete types
   and their instantiations.
   <br/>
   <br/>
   </li>
   <li><i>Irreversibility of hiding. </i> A type which is hidden may not become revealed by the addition of a type constraint. For example,
   <pre class="prettyprint ml">
   # module type S1 = sig type t end;;
   # module M1 : S1 = struct type t = int end;;
   # module M2 : S1 with type t = int = struct type t = M.t end;;
   Type error
   </pre>
   The system cannot make the link here between <code>int</code>
   and <code>M.t</code>. Indeed, the name of a hidden type is
   definitiely associated with it's module : the name of
   the <code>int</code> type hidden in <code>M</code>
   is <code>M.t</code>. It will no longer be equivalent to "int". Type
   abstraction is directly reflected in OCaml by this syntactic
   difference between the names of types. 
   </li>
   </ul>
   </p>
   <p>
   Type constraints are the last ingredient needed to systematically
   implement abstract data type and more generally, modules whose
   implementations are systematically masked even in the case where it
   is necessary to export abstract types.
   <br/>
   <br/>
   <b>Modular programming with rigorous hiding</b>
   <ol>
   <li>No type definition is given in the signatures (no type
   definitively fixed as concrete)</li>
   <li>
   All modules are explicitly typed with a signature. <code>with
   type</code> constructions are applied on those types that need to be
   exported.
   </li>
   </ol>
   <br/> <br/> We will discuss again the interest in this modular
   programming style. Note that the first point above does not
   prohibit making use of global types like for example, the
   predefined types. The generalization of types in signatures is not
   an obligation, this is only a means of which we will still say a
   few words in the next section.
   </p>

   <h5>The conceptual generalization of signatures</h5>
   <p>
   Generalization renders signatures adaptable without having to
   redefine them, to rename them and thus to organize their
   variations. Additionally, the possibilities offered by type
   constraints make it possible to not fear the effects of the rules
   of visibility. If the examples of the preceding pages reveal
   essential techniques, it is important to remark that generalization
   can also extend conceptually the field of description of a
   signature. For example, consider a new signature of the notion of a
   bi-dimensional space with a distance:
   <pre class="prettyprint ml">
   module type METRIC_SPACE_2D = sig
     type point
     val make_point : float * float &rarr; point
     val dist : point &rarr; point &rarr; float
   end;;
   </pre>
   The number of dimensions of the space is fixed by the type of the
   constructor <code>make_point</code>. Applying the external type
   technique it is possible to work around this constraint and propose
   a more general specification of spaces:
   <pre class="prettyprint ml">
   module type METRIC_SPACE = sig
     type point
     type extern_point
     val make_point : extern_point &rarr; point
     val dist : point &rarr; point &rarr; float
   end;;
   </pre>
   And here first of all an instance adapted from one previously
   presented which could do all the business:
   <pre class="prettyprint ml">
   module Plane_count : METRIC_SPACE
     with type extern_point = float * float = 
   struct
     type point = { number : int; coord : float * float }
     type extern_point = float * float
     let count = ref 0
     let make_point (x, y) = ...
     let dist (x1, y1) (x2, y2) = ...
   end;;
   </pre>
   But, it is equally possible to define spaces with different
   dimensions. For example, a space of dimension \(1\):
   <pre class="prettyprint ml">
   module Line : METRIC_SPACE
     with type extern_point = float =
   struct
     type point = float
     type extern_point = float
     let make_point x = x
     let dist x1 x2 = abs_float (x1 -. x2)
   end;;
   </pre>
   It is also possible to envisage instantiations of the
   signature <code>METRIC_SPACE</code> with a dramatically different
   nature. For example, recognition and compression of alphanumeric
   character strings are based generally on quantitative comparisons
   and their representations as binary numbers. The functions of
   distance can then be put into contribution in order to structure
   the set of recognized characters and the characters to be
   recognized. The simplest of these functions is to count the number
   of pixels different from the respective representations. Here is a
   possible implementation of this novel space also
   satisfying <code>METRIC_SPACE</code>:
   <pre class="prettyprint ml">
   module Bit_map : METRIC_SPACE
     with type extern_point = int array array =
   struct
     type point = Bitmap of int array array
     type extern_point = int array array

     let make_point b = Bitmap b

     let dist (Bitmap b1) (Bitmap b2) =
       let len_x = Array.length b1 in
       let len_y = Array.length b1.(0)  in
       let diff_count = ref 0 in
       if len_x = Array.length b2 &&
          len_y = Array.lgength b2.(0)
       then
         for i = 0 to len_x -1 do
           for j = 0 to len_y - 1 do
             if b1.(i).(j) <> b2.(i).(j) then incr diff_count
           done
         done
       else failwith "Bitmap sizes different"
       float (!diff_count)
   end;;
   </pre>
   </p>

   <h5>Tactics for naming abstract data types</h5>
   <p>
   The implementation of abstract data types by modular means is
   dependent on the relationships mainted by three elements:
   <ol>
   <li>The signature of the datatype</li>
   <li>The type of the data itself</li>
   <li>The representation of values included in the datatype</li>
   </ol>
   These three elements must of course bear names and their choice is
   not so innocent of that. The names participate in the quality of
   the abstraction and they predispose more or less to
   compatibility. One point in particular distinguishes many "tactics
   of naming" (which we have already observed in previous examples):
   <ul>
   <li><i>Homogenous naming tactics.</i> The distinctions between the
   three elements above are reduced by names which are as similar as
   possible. For example:
   <pre class="prettyprint ml">
   module type COMPLEX = sig
     type complex
     val add : complex &rarr; complex &rarr; complex
     ...
   end;;

   module Complex : COMPLEX = struct
     type complex = ...
     ...
   end;;
   </pre>
   This homogeneity of naming expresses here that there is only one
   element that counts : the type of complex numbers.
   <br/>
   <br/>
   </li>
   <li><i>Algebraic naming tactics.</i> The distinctions between the
   three elements are emphasized by giving them distinct names. The
   "algebraic" character of the type of data are also made apparent :
   a type of data is endeed a set of values structured by associated
   operations.
   <br/>
   <br/>
   <ul>
   <li><i>Strong distinction.</i> We assert the difference between the
   type of data and its representation of values by different and
   descriptive names. For example:
   <pre class="prettyprint ml">
   module Plane = struct
     type point = ...
     let dist x y = ...
   end;;
   </pre>
   The representation of values here bears the particular name
   of <code>point</code> to which is added a distance generating by
   itself a particular space that is to say, the <code>Plane</code>.
   <br/>
   <br/>
   </li>
   <li><i>Weak distinction.</i> The characteristics of the
   representation of values are eluded by giving it a formal name and
   the most neutral possible (classicly, <code>t</code>). For
   example:
   <pre class="prettyprint ml">
   module Complex = struct
     type t
     ...
   end;;
   </pre>
   In contrast to the "homogenous" naming technique, an attempt is
   made here to diminish the distinctions between the datatype and the
   representation of values altering the role of the latter. The full
   name of the type in effect becomes <code>Complex.t</code>.
   </li>
   </ul>
   </li>
   </ul> 
   The tactic of algebraic naming permits expression a distinction
   between a datatype and the containing signature : the instances of
   the signature can in themselves form a characteristic group. For
   example:
   <pre class="prettyprint ml">
   module type METRIC_SPACE = sig
     type point
     ...
   end;;

   module Plane : METRIC_SPACE = struct
     type point = ...
     ...
   end;;
   </pre>
   Here <code>Plane</code> is a particular instance of a metric space,
   that is to say <code>METRIC_SPACE</code>.
   <br/>
   <br/>
   The same tactic can be applied to complex numbers but it requires a
   generalization of the signature. It is sufficient in doing this to
   recognize that complex numbers are only one instance of a structure
   that makes it possible to "make calculations under favorable
   conditions". For example:
   <pre class="prettyprint ml">
   module type ARITH = sig
     type nb                       type extern_nb
     val make : extern_nb &rarr; nb    val show : nb &rarr; extern_nb
     val zero : nb                 val one : nb
     val add : nb &rarr; nb &rarr; nb      val sub : nb &rarr; nb &rarr; nb
     val mul : nb &rarr; nb &rarr; nb      val div :  nb &rarr; nb &rarr; nb
   end;;
   </pre>
   The type of complex numbers can then become an instance of that
   signature:
   <pre class="prettyprint ml">
   module Complex : ARITH = struct
     type nb = ...
     ...
   end;;
   </pre>
   </p>
   <p>
   Let us compare these naming tactics. The tactic of "homogenous"
   naming permits economic generality while making declarations
   explicit within a signature. For example:
   <pre class="prettyprint ml">
   val add : complex &rarr; complex &rarr; complex
   </pre>
   This tactic generates redundancies however since the name of the
   complete type is <code>Complex.complex</code>. On the other hand,
   it hinders the generalization of a signature since a particular
   name is associated with the representation of values. For example,
   a generalized signature such as <code>ARITH</code> must not display
   a name such as <code>complex</code>. In contrast, the "strong
   algebraic" naming tactic remedies the redundancies and does not
   interfere with the generalization of a signature. Additionally,
   this tactic favors compatibility between signatures when for
   example, the representation of values is systematically named
   "t". Nevertheless, this induces a loss of precision. For example,
   in the case of complex numbers, the function for addition is
   specified as :
   <pre class="prettyprint ml">
   val add : t &rarr; t &rarr; t
   </pre>
   This imprecision can become annoying when number modules interact
   with each other or when representation of values utilizes multiple
   distinct types. It also sometimes reduces the possibility of
   pooling types. Finally, the "weak algebraic" tactic proposes to
   make a more explicit distinction between names. This also engenders
   some imprecision but reduces the barriers to compatibility between
   signatures.
   </p>
   <p>
   No naming tactic is therefore perfect. As a compromise, the "weakly
   algebraic" tactic is used in practice. This for example, is applied
   to many types in the standard OCaml library. We will see further on
   that there exists a technique to rename the elements of a module in
   fairly good conditions.
   </p>

   <h5>Universal type parameters and abstract types</h5>
   <p>
   It is neccessary to be careful of the level of generiticity which
   is explained in a signature. Consider for example the case of a
   function <code>f</code> specified in a signature and whose
   type <code>T</code> makes use of type
   parameters <code>&alpha;</code>, <code>&beta;</code> etc. The
   implementation of <code>f</code> must be compatible
   with <code>T</code>, at least as generic as imposed
   by <code>T</code>. Experience shows that this evidence is not so
   easy to apprehend.
   </p>
   <p>
   Here for example is a signature which might seem to specify in a
   very general manner types for ordered sets:
   <pre class="prettyprint ml">
   module type ORDER_GEN = sig
     val less_or_equal : &alpha; &rarr; &alpha; &rarr; bool
   end;;
   </pre>
   The signature requires production of an implementation
   of <code>less_or_equal</code> that is completely generic. Any
   function whose implementation is more specific would not
   satisfy. Let us recall that only the predefined predicates are able
   to offer such generiticity. The signature that specifies ordered
   sets is therefore rather of the form:
   <pre class="prettyprint ml">
   module type ORDER = sig
     type t
     type extern_t
     val make : extern_t &rarr; t
     val show : t &rarr; extern_t
     val less_or_equal : t &rarr; t &rarr; bool
   end;;
   </pre>
   In this signature, the indicated implementation
   of <code>less_or_equal</code> is dependant on the instantiation of
   the abstract type <code>t</code>. The specification possesses a
   certain level of generiticity as in <code>ORDER_GEN</code> but only
   through the utilisation of the abstract type. The implementation
   here is not required to be totally generic and the
   function <code>less_or_equal</code> may exploit the characteristics
   of the concrete type <code>t</code>. Here is an example of ordered
   strings for the value of their interpretation in base 256 according
   to the ASCII code of their characters (for example, "ol"
   corresponds to the code \(cod () * 256^2 + cod (o) * 256^1 + cod
   (l) * 256^0\)). This implementation applies a memoization of the
   sum and illustrates a new case where hiding and specification are
   useful:
   <pre class="prettyprint ml">
   module String_ordered = struct
     type t = Str of string * Num.num option ref
     type extern_t = string

     let make s = Str (s, ref None)
     let show (S(s, _)) = s

     let ascii_value s =
       let value = ref (Num.Int 0) and len = (String.length s) - 1 in
       let basis = ref (Num.Int 1) in
       for i = len downto 0 do
         value := Num.add_num !value
               (Num.mult_num !basis (Num.Int (Char.code s.[i])));
         basis := Num.mult_num !basis (Num.Int 256)
       done;
       !value

     let less_or_equal s1 s2 =
       let extract_ascii_value (Str (s, c)) = match !c with
         | None &rarr; let d = ascii_value s in c := Some d; d
         | Some d &rarr; d
       in
       Num.le_num (extract_value s1) (extract_ascii_value s2)
   end;;
   </pre>
   There exist situations when the choice between type parameters and
   abstract types proves more delicate than the above especially when
   these two kinds of parameters combine. For example, consider the
   problem of specifying a datatype for a "production line". That is,
   processes that generate sequentially and on demand, random numbers,
   events of inputs/outputs, happiness of the day etc. Here is the
   first specification:
   <pre class="prettyprint ml">
   module type PRODUCTION_LINE_GEN = sig
     type &alpha; product_line
     val make : unit &rarr; &alpha; product_line
     val read_fst : &alpha; product_line &rarr; &alpha;
     ...
   end;;
   </pre>
   At first glance, nothing seems suspect in this signature that
   resembles those proposed for sequential containers. Nevertheless,
   it is observed that the constructor <code>make</code> must be
   generic even though it is rather to provide a production line of
   particular elements. Indeed, here is an example of a production
   line in the form of a stream that generates random binary sequences:
   <pre class="prettyprint ml">
   module Rand_bin = struct
     type &alpha; product_line = &alpha; stm
     let rec make () =
       Random.self_init ();
       stm_build (fun x &rarr; (Random.int 2)) 0
     let read_fst s = stm_hd s
     ...
   end;;
   </pre>
   This module does not satisfy the
   signature <code>PRODUCTION_LINE_GEN</code> since its constructor is
   obviously not generic being of type:
   <pre class="prettyprint ml">
   val make : unit &rarr; int stm
   </pre>
   The type is less general than specified. Nevertheless, as in the
   case of ordered types, we can replace the type variable with an
   abstract type:
   <pre class="prettyprint ml">
   module type PRODUCTION_LINE = sig
     type data
     type &alpha; product_line
     val make : unit &rarr; data product_line
     val read_first : data product_line &rarr; data
     ...
   end;;
   </pre>
   The <code>Rand_bin</code> module satisfies this signature:
   <pre class="prettyprint ml">
   module Rand_bin : PRODUCTION_LINE = struct
     type data = int
     type &alpha; product_line = &alpha; stm
     let rec make () =
       Random.self_init (); stm_build (fun x &rarr; (Random.int 2)) 0
     let read_fst s = stm_hd s
     ...
   end;
   </pre>
   The signature <code>PRODUCTION_LINE</code> uses here an abstract
   type <code>&alpha; product_line</code> so as to be able to indicate
   a strict relationship between the proudction lines and the data
   they produce. Indeed, in this signature, the type is explicitly in
   the expression <code>data product_line</code>. Here is an
   alternative:
   <pre class="prettyprint ml">
   module type PRODUCTION_LINE' = sig
     type data
     type product_line
     val make : unit &rarr; product_line
     val read_fst : product_line &rarr; data
     ...
   end;;
   </pre>
   The link between <code>data</code> and <code>product_line</code> is
   more precise, and this gives it more latitude : the representation
   of data in the link to the product isn't necessarily the same as
   that seen from the outside. For example, here is a case where the
   definition of the type <code>product_line</code> permits modifiable
   data:
   <pre class="prettyprint ml">
   module Rand_bin : PRODUCTION_LINE' = sig
     type data = int
     type product_line = data ref stm
     ...
   end;;
   </pre>
   </p>
   <p>
   Thus, the elaboration of signatures gives the programmer choices to
   make between universal paramters and abstract types. These should
   in fact be considered as two kinds of parameters in the signatures:
   <br/>
   <br/>
   <b>Difference between type parameters in signatures: </b>
   <ul>
   <li><i>Universal type parameters</i> impose generic
   implementations. Their instantiation is performed automatically by
   the type system.
   <br/>
   <br/>
   </li>
   <li><i>Abstract types</i> do not impose generic
   implementations. Their instantiations are established explicitly
   case by case.
   </li>
   </ul>
   <br/> 
   <br/>
   This distinction makes it possible to specify the level of
   generiticity of programs in signatures. In this respect, the
   preceding examples the general technique following:
   <br/> 
   <br/>
   <b>Mastering the generiticity of a signature:</b> Suppose a
   universal type <code>&alpha;</code> in a signature imposes a
   generic implementation. This parameter is replaced or controlled by
   a new abstract type.
   <br/>
   <br/>
   We will talk again about this delicate point.
  </p>

   <h4>Module inclusion relationships</h4>

   <h5>The inclusion of modules in signatures</h5>
   <p>
   In OCaml, reuse of a module in a module is expressed directly by
   the inclusion of one module in the other. This operation is
   established by the construction syntax following:
   <br/>
   <br/>
   <pre class="prettyprint ml">
   include &lt;Module&gt;
   </pre>
   <br/>
   <br/>

   The elements of the module <code>&lt;Module&gt;</code> are then
   defined in their entirety in the including module. For example,
   consider the following module:
   <pre class="prettyprint ml">
   module Increm = struct
     let f x = x + 1
   end;;
   </pre>
   The module can be included in another:
   <pre class="prettyprint ml">
   module More_than_increm = struct
     include Increm
     let g x = f (x * 10)
   end;
   </pre>
   This is equivalent to the following module definition:
   <pre class="prettyprint ml">
   module More_than_increm = struct
     let f x = x + 1
     let g x = f (x * 10)
   end
   </pre>
   </p>
   <p>
   Signatures also can include others with the same construction:
   <br/>
   <br/>
   <pre class="prettyprint ml">
   include &lt;SIGNATURE&gt;
   </pre>
   <br/>
   <br/>
   As for modules, the elements of <code>&lt;SIGNATURE&gt;</code> are
   declared and defined as part of the signature that includes
   them. For example, consider the signature of the
   module <code>Increm</code> above:
   <pre class="prettyprint ml">
   module type S = sig
     val f : int &rarr; int
   end;;
   </pre>
   The definition of the signature for the
   module <code>More_than_increm</code> can include the
   signatures <code>S</code>.
   <pre class="prettyprint ml">
   module MORE_THAN_S = sig
     include S
     val g : int &rarr; int
   end;;
   </pre>
   This definition is equivalent to the signature:
   <pre class="prettyprint ml">
   module type MORE_THAN_S = sig
     val f : int &rarr; int
     val g : int &rarr; int
   end;;
   </pre>
   The modules defined previously can be typed against these
   signatures:
   <pre class="prettyprint ml">
   module M1 : S = Increm;;
   module M2 : MORE_THAN_S = More_than_increm;;
   </pre>
   <br/>
   <br/>
   <b>The interest in module inclusion : </b> Inclusion facilitates
   the resule of modules. Also, inclusion of modules can reflect the
   inclusion of signatures and in the same way, inclusions of
   signatures can be concretely realized by the inclusion of modules.
   <br/>
   <br/>
   On the other hand, it can be remarked that the version
   of <code>MORE_THAN_S</code> with inclusion expresses explicitly the
   link with the signature <code>S</code> which is not the case for
   the version without inclusion. In other words:
   <br/>
   <br/>
   <b>The interest in signature inclusion : </b> Inclusion facilitates
   resuse of signatures. Also, inclusion of signatures allows for the
   specification of links between reutilized modules.
   <br/>
   <br/>
   </p>

   <h5>Inclusion for inheritance</h5>
   <p>
   Inclusion offers a direct means to extend and specialize existing
   modules and signatures. For example, consder a new implementation
   of complex numbers:
   <pre class="prettyprint ml">
   module Complex = struct
     type complex = float * float
     let make (r, i) = (r, i)
     let add (r1, i1) (r2, i2) = make (r1 +. r2, i1 +. i2)
     let norm (r, i) = sqrt (r ** 2. + i ** 2.)
   end;
   </pre>
   The module can easily be extended by inclusion:
   <pre class="prettyprint ml">
   module Complex_ext = struct
     include Complex;
     let mul (r1, i1) (r2, i2) =
       (r1 *. r2 -. i1 *. i2, i1 *. r2 + i2 *. r1)
   end;;
   </pre>
   <br/>
   <br/>
   <b>Module inheritance is implemented by inclusion:</b> One includes
   globally a module in another module and then extends, specializes
   or adapts.  
   <br/>
   <br/>
   On the other hand, here is a possible signature of
   the <code>Complex</code> module:
   <pre class="prettyprint ml">
   module type COMPLEX = sig
    type complex
    val make : float * float &rarr; complex
    val add : complex &rarr; complex &rarr; complex
    val norm : complex &rarr; float
   end;;
   </pre>
   A signature for the module <code>Complex_ext</code> can be directly
   derived by inclusion:
   <pre class="prettyprint ml">
   module type COMPLEX_EXT = sig
     include COMPLEX
     val mul : complex &rarr; complex &rarr; comples
   end;;
   </pre>
   Observe that the signature <code>COMPLEX_EXT</code> is compatible
   with <code>COMPLEX</code>:
   <pre class="prettyprint ml">
   # module C1 : COMPLEX = Complex_ext ;;
   module C1 : COMPLEX

   # module C2 : COMPLEX_EXT = Complex _ext ;;
   module C2 : COMPLEX_EXT
   </pre>
   <br/>
   <br/>
   <b>The behavior of module inheritance by inclusion : </b> One
   includes a signature <code>S1</code> in another
   signature <code>S2</code> to extend, specialize or
   adapt. Additionally, <code>S2</code> is compatible
   with <code>S1</code> (assuming no reclarations).
   <br/>
   <br/>
   Evidently, in the context of information hiding, the extending
   module cannot change the access privilege of the modules it
   includes, it will use the constructors and accessors previously
   defined. So, for example, let us suppose there is a
   module <code>Complex</code> that satisfies the following signature:
   <pre class="prettyprint ml">
   module type COMPLEX_MASK = sig
     type complex
     val make : float * float &rarr; complex
     val show : complex &rarr; float * float
     ...
   end;;
   </pre>
   An extension can be written using the accessors <code>make</code>
   and <code>show</code>:
   <pre class="prettyprint ml">
   module Complex_ext = struct
     include Complex
     let mul z w =
      let (r1, i1) = show z and (r2, i2) = show w in
      make (r1 *. r2 -. i1 *. i2, i1 *.r2 +. i2 *. r1)
   end;;
   </pre>
   This example shows that we can begin to examine the question "the
   dimensions of extensibility of types" for the case of abstract
   types. In particular, inclusion makes it easy to extend functions
   associated with a type and in a module framework with rigourous
   information hiding. We will treat later the case of the extension
   of representation of values. For now, we comment that "functors"
   are able to make generic these extensions.
   </p>

   <h5>Inclusion for inheritance</h5>
   <p>
   Inclusion also allows us to adapt existing modules and signatures :
   one redefines, one renames, one sometimes transforms elements
   module elements as necessary to obtain the extension. For example,
   let us reconsider the signature <code>ARITH</code>:
   <pre class="prettyprint ml">
   module type ARITH = sig
     type nb                        type nb_extern
     val make : extern_nb &rarr; nb     val show : nb &rarr; nb_extern
     val zero : nb                  val one : nb
     val add : nb &rarr; nb &rarr; nb       val sub : nb &rarr; nb &rarr; nb
     val mul : nb &rarr; nb &rarr; nb       val div : nb &rarr; nb &rarr; nb
   end;;
   </pre>
   Certain modules of the OCaml standard library are not far off being
   instances of this signature. However, the modules make use of the
   naming tactic where the representation of values is denoted by
   the <code>t</code> (the "strong algebraic" tactic) and do not apply
   the same conventions with respect to information hiding. We can use
   inclusion to make it easy to remedy this situation. For example,
   consider the case of the module <code>Int64</code> of the standard
   library which implements a datatype associated with whole numbers
   modulo \(2^{64}\) (that is, numbers in the range \([-2^{63}, 2^{63}
   - 1]\)). Here is how to adapt it such that it satisfies
   the <code>ARITH</code> signature:
   <pre class="prettyprint ml">
   module Arith_Int64 : ARITH  type nb_extern = string = 
   struct
     include Int64
     type nb = Int64.t (*rename type*)
     type extern_nb = string
     let make = of_string (*alias*)
     let show = to_string
   end;;

   # Arith_Int64.make "1000000000000000000000";;
   - : Arith_Int64.nb = &lt;abstr&gt;
   </pre>
   Note that is quite possible to include modules and revise some of
   their definitions. Adaption by inclusion can also benefit
   redefinitions of values and functions. However, there is a limit to
   such redefinitions : if there are mutual uses between functions
   contained in the module, if if a redefinition is applied between
   one of them, there will be no automatic update of their
   relation. In other words, the redefinitions do not incorporate a
   "delayed link" mechanism. For example:
   <pre class="prettyprint ml">
   module M = struct
     let f x = x + 1000
     let g x = (f x) + 1
   end;

   module Modified_M = struct
     include M
     let f x = x
   end;;
   </pre>
   The redefinition of <code>f</code> does not affect the definition
   of <code>g</code>:
   <pre class="prettyprint ml">
   # Modified_M.f 0 ;;
   - : int = 0

   # Modified_m.g 0 ;;
   - : int = 1001
   </pre>
   In the module framework, the programmer is in charge of assuring
   the cohesion of elements from the point of view of any
   redefinition. On the other hand, redefinitions may induce errors
   when they are not delibrate. This situation is all the more likely
   when modules are large and inclusions numerous. Generally,
   inclusions imply a pooling of definitions which provides
   opportunities for incoherencies. The following section introduces
   another means of expressing importations of modules end signatures
   that is more constrained and structured.
   </p>

   <h4>Module containment relations</h4>

   <h5>Containment of modules</h5>

   <p>Modules may embed other modules. We call this containment of
   modules and <i>parent-module</i> the module which contains others
   and those contained modules <i>sub-modules</i> of the parent
   module. Recall the earlier example:
   <pre class="prettyprint ml">
   module Increm = struct
     let f x = x + 1
   end;;
   </pre>
   A new module emerges from a sub-module in the other:
   <pre class="prettyprint ml">
   module More_than_increm = struct
     module Sub = Increm
     let g x = Sub.f (x * 10)
   end;;
   </pre>
   Contrary to inclusion of modules, containment respects the
   partitioning of the modules. They do not put all the definitions at
   the same level and they therefore do not imply unqualified
   redefinitions.
   </p>

   <h5>Opening of modules</h5>

   <p>
   Containment of modules must be compared to another construction
   that acts equally within the framework of links between
   modules. Using contained modules implies indirections "pointer
   notation". Sometimes this constraint seems to excessively increase
   the verbosity of programs especially when module names are very
   explicit. So, the language provides the means to "open" a module so
   that the names of the elements are directly addressable. It
   suffices to make this happen with the following directive:
   <br/>
   <pre class="prettyprint ml">
   open &lt;Module&gt;
   </pre>
   <br/> The elements conainted in <code>&lt;Module&gt;</code> are
   then accessible at the level of the the occurence of
   the <code>open</code> directive. No indirections are required.
   </p>
   <p>For example, consider a new module <code>Increm</code> opened in
   another module.
   <pre class="prettyprint ml">
   module More_than_increm = struct
     open Increm
     let g x = f (x * 10)
   end;;
   </pre>
   This is equivalent to the module definition:
   <pre class="prettyprint ml">
   module More_than_increm = struct
     let g x = Increm.f (x * 10)
   end;;
   </pre>
   </p>
   <p>
   Contrary to inclusion and containment, opening of modules does not
   produce any new definitions : it operates only on the space of
   identifiers. However, suppose there is an <code>x</code> valid at
   the point of application of an open directive of a
   module <code>M</code>; if <code>x</code> is also the name of an
   element of <code>M</code>, the open implies an irreversible
   redefinition of <code>x</code>. Consequently, as for inclusion,
   opens may involve name complications delicate to organise.
   </p>
   <p>
   For example, the modules <code>List</code>, <code>Array</code>
   and <code>Stack</code> from the sandard library have in common a
   certain number of functions with the same names. In the module
   following, the opening of these three modules will define a
   function <code>last</code> that gives rise to a type error:
   <pre class="prettyprint ml">
   # module M = struct
       open List
       open Stack
       open Array
       let last lin = nth lin ((length lin) - 1)
     end;;
    Type error
   </pre>
   Indeed the function <code>nth</code> is provided by
   the <code>List</code> module, but the <code>length</code> function
   has come from the <code>Array</code> module to which is
   applied <code>last</code>. The suite of module opens is ordered
   differently than required for a correct version:
   <pre class="prettyprint ml">
   # module M = struct
       open Stack
       open Array
       open List
       let last lin = nth lin ((length lin) - 1)
     end;;
   </pre>
   <br/>
   <br/>
   <b>The technique of openings transformed into sub-modules:</b> Any
   opening of a sub-module <code>M</code> can be replaced by an
   explicit import of <code>M</code> as a sub-module.
   <br/>
   <br/>
   Note that there exists a derivative of this technique. If
   utilisation of a module can be restrained to a simple expression
   such as a function body, it is possible to consider a local module
   . For example:
   <pre class="prettyprint ml">
   module M = struct
     let last lin =
       let module L = List in
       L.nth lin ((L.length lin) - 1)
   end;;
   </pre>
   On the other hand, opening a module possesses another important
   inconvenience : they are not representable at the level of the
   specification. We have seen that this is the case for inclusions
   and will now discover it for nesting.
   </p>

   <h5>Embedding in signatures : abstract sub-modules</h5>
   <p>
   Signatures also lend themselves to the embedding of modules. A
   signature can declare modules by the aid of the following
   construction:
   <pre class="prettyprint ml">
   module type ... = sig
     ...
     module &lt;Name&gt; : &lt;SIGNATURE&gt;
     ...
   end
   </pre>
   The notation is similar to the declaration of values in a signature
   e.g. <code>val &lt;name&gt; : &lt;type&gt;</code>. For example,
   here is a signature for the module <code>More_than_increm</code>:
   <pre class="prettyprint ml">
   module type S = sig
     val f : int &rarr; int
   end;;

   module type MORE_THAN_S = sig
     module Sub : S
     val g : int &rarr; int
   end;;
   </pre>
   These declarations of sub-modules in signatures are reminiscent of
   abstract types. We will therefore name them here in accordance of
   this recollection:
   <br/>
   <br/>
   <b>Definition : </b> In a signature, a simple type declaration of
   the name of a sub-module is called an abstract sub-module.
   <br/>
   <br/>
   </p>

   <h5>The link between signatures and abstract sub-modules</h5>
   <p>
   As in the case of the inclusion of signatures, an abstract
   sub-module permits the declaration of a link between modules at the
   level of a specification. The embedding also makes possible
   description of the particular relationships between elements of the
   sub-module and parent module. Consider this example derived from
   one preceding:
   <pre class="prettyprint ml">
   module type S = sig
     type t
     val f : t &rarr; t
   end

   module type MORE_THAN_S = sig
     module Sub : S
     val g : Sub.t &rarr; Sub.t
   end
   </pre>
   Here, the links between the instances of <code>S</code> and those
   of <code>MORE_THAN_S</code> concretely express the way types are
   used : the function <code>g</code> is based on a type provided
   by <code>Sub</code>. We have therefore increased the precision of
   the signature <code>MORE_THAN_S</code> such that thte
   function <code></code> must be linked to an abstract type described
   by <code>S</code>. Therefore a function <code>g</code> can always
   be based on a function <code>f</code> associated with its type
   by <code>S</code>. Generalizing:
   <br/>
   <br/>
   <p>Interest in abstract sub-modules : </p> Abstract sub-modules of
   a signature <code>S</code> declare the names of modules whose
   elements are usuable for the types of other elements
   in <code>S</code>. They also specify links of reutilization between
   modules, and this without being dependent on the particulars of
   implementations of modules.
   <br/>
   <br/>
   We also talk sometimes of <i>abstraction composition</i>. Here is
   an example less formal than the preceding:
   <pre class="prettyprint ml">
   module type SET = sig
     type &alpha; set
     val empty : unit &rarr; &alpha; set
     val mem : &alpha; &rarr; &alpha; set &rarr; bool
     val add : &alpha; &rarr; &alpha; set &rarr; unit
     ...
   end;
   </pre>
   One proposed implementation, the module <code>Set_H</code> -- makes
   use of a hash table from the standard library. Suppose suche hash
   tables are specified by means of the
   signature <code>HASH_TABLE</code>. It is then possible to give
   oneself a new signature which imposes on the representation of sets
   that they be an implementation of <code>HASH_TABLE</code>:
   <pre class="prettyprint ml">
   module type SET_HASH = sig
     module H : HASH_TABLE
     type &alpha; set = &alpha; H.t
     val empty : unit &rarr; &alpha; set
     val mem : &alpha; &rarr; &alpha; set &rarr; bool
     val add : &alpha; &rarr; &alpha; set &rarr; unit
     ...
   end;;
   </pre>
   This constraint in the specficiation indicates that any
   implementation of <code>SET_HASH</code> benefits a priori the
   properties of hash tables. In particular, access to the elements of
   a set will have constant complexity. On the other hand, variations
   of the instantiation of the type <code>&alpha; set</code>'s masking
   conventions will be delegated to the sub-modules <code>H</code>.
   </p>
   <p>
   This example illustrates how use of abstract sub-modules may remedy
   some of the limitations we spoke of earlier of signatures : thanks
   to them, it is possible to integrate greater precision into a
   specification. On the other hand, note the
   signature <code>SET_HASH</code> is compatible with the
   signature <code>SET</code> : any module that
   satisfies <code>SET_HASH</code> equally well
   satisfies <code>SET</code>. As in the case of signature inclusion,
   we specified here very naturally, compatible specializations.
   </p>
   <p>
   Here is an abstract of the technique we have presented:
   <br/>
   <br/>
   <b>Technique of specication of a signature by abstract sub-modules
   : </b> Any module <code>M</code> with signature <code>S</code>
   using modules <code>M1</code>, <code>M2</code>,
   ..., <code>Mn</code> may induce a specialized
   signature <code>S_PLUS</code>:
   <ol>
   <li>In <code>S_PLUS</code> we declare <code>M2</code>,
   ..., <code>Mn</code> as abstract sub-modules.</li>
   <li>The elements of <code>S_PLUS</code> rely on the elements of the
   signatures of the abstract sub-modules.</li>
   </ol>
    The signature <code>S_PLUS</code> is rendered compatible
   with <code>S</code>.
   <br/>
   <br/>
   This technqiue permits also, systematic expression of the links
   between modules at the level of signatures. The advantages of this
   follow:
   <br/>
   <br/>
   <b>The advantages of specialization of signatures :</b>
   <ol>
   <li>Help refining type inference, enriched analysis of the module
   components, to give information to the programmer.</li>
   <li>Aid to the programmer in understanding the logical architecture
   since the relevant signatures are already part of the interactions
   between components.</li>
   </ol>
   <br/>
   <br/>
   </p>

   <h5>Abstract sub-modules and inclusion constraints</h5>
   <p>
   The specialization of signatures facilitates the possibilty of
   directly constraining an inclusion by the following syntax:
   <pre class="prettyprint ml">
   include &lt;SIGNATURE&gt; with type &lt;type 1&gt; = &lt;expression of type 1&gt;
                             and type ...
                             and type&lt;type n&gt; = &lt;expression of type n&gt;
   </pre>
   Recalling the example of the preceding section, suppose a general
   signature <code>SET</code> with a pre-existing specialization. It
   is possible to obtain that specialization directly with an
   inclusion constraint:
   <pre class="prettyprint ml">
   module type SET_HASH = sig
     module H : HASH_TABLE
     include SET with type &alpha; set = &alpha; H.t
   end;
   </pre>
   The type constraint here is particular : it deals only with
   abstract types. Indeed, the type constraints of the preceding pages
   always used a term on the right denoting a type duly defined. While
   being abstract, the type <code>&alpha; H.t</code> is nevertheless part
   of the environment; it may also therefore contribute to the
   definition of a type.
   <br/>
   <br/>
   <b>Definition : </b> When a type constraint consists entirely of
   abstract types, these types are called <code>sharing types</code>.
   <br/>
   <br/>
   We have seen other occurences of this notion.
   </p>

   <h5>Hiding the types of sub-modules</h5>
   <p>
   The existence of module embedding neccessitates a clarification of
   the effect of explicit typing by signature. The rule follows:
   <br/>
   <br/>
   <p><b>Rule (3) of visibility of a module (precision) : </b> The
   effects of a valid explicit typing of <code>M</code> apply
   individually to the sub-modules of <code>M</code>.  
   <br/>
   <br/> 
   In consequence, suppose a module <code>M1</code> contained in a
   module <code>M2</code> : while the type of <code>M2</code> is
   explicit and valid, the implementation of the abstract types
   of <code>M1</code> are hidden. For example:
   <pre class="prettyprint ml">
   module type S1 = sig
     type t
     val cst : t
   end;;

   module type S2 = sig
     module Sub : S1
     val f : Sub.t &rarr; Sub.t
   end;;

   module M1 = struct
     type t = int
     let cst = 3
   end;;

   module M2 : S2 = struct (*explicitly typed*)
     module Sub = M1
     let f x = Sub.cst + x
   end;;
   </pre>
   The explicit typing of <code>M2</code> by <code>S2</code> implies
   it is the parent of a sub-module <code>Sub</code> - and
   so <code>M1</code> - is also subject to the rule of hiding:
   <pre class="prettyprint ml">
   # M2.Sub.cst;;
   - : M2.Sub.t = &lt;abstr&gt;

   # M2.f 1;;
   Type error
   </pre>
   The type of the constant contained in <code>Sub</code> is hidden
   even though it would come from the module <code>M1</code> which
   exported its initial definition.
   </p>
   <p>
   So, individualized masking is sometimes established on elements of
   sub-modules by using the construction <code>with type</code>. For
   example:
   <pre class="prettyprint ml">
   module M2 : S2 = 
     with type Sub.t = int = struct
     module Sub = M1
     val f x = Sub.cst + x
   end;;

   # M2.f 1;;
   - : M2.Sub.t = 4
   </pre>
   </p>
   <p>
   In the case of sub-modules possessing multiple types, and for
   additional clarity, the exists an equivalent
   construction <code>with module</code>:
   <pre class="prettyprint ml">
   &lt;SIGNATURE&gt; with module &lt;module 1&gt; = &lt;expression of module 1&gt;
                     and module ...
                     module &lt;module n&gt; = &lt;expression of module n&gt;
   </pre>
   where the <code>&lt;module i&gt;</code> denotes a sub-module within
   the signature <code>&lt;SIGNATURE&gt;</code> and
   the <code>&lt;expression of module i&gt;</code> are the valid
   definitions of modules in the environment at the moment of
   application of the type constraint. This construction iss in fact
   only an abbreviation of the set of constraints <code>with
   type</code> associated with all of the types appearing in
   the <code>&lt;expression of module i&gt;</code>. So, the following
   version of module <code>M2</code> is equivalent to the earlier one:
   <pre class="prettyprint ml">
   module M2 : S2 = 
     with module Sub = M1 =
   struct
    module Sub = M1
    let f x = Sub.cst + x
   end;;
   </pre>
   The masking with a structuring in sub-modules therefore requires a
   certain rigor under pain of lots of unnessary type
   errors. Recalling the example where explicit typing of a module by
   a signature may be rendered unuable if there has been no masking
   preperation, that is to say, if the constructors and accessors have
   not been forseen. In fact, a systematic approach to masking
   simplifies the reasoning. Thus, here is a precise statement
   concerning modular programming with "rigorous masking":.
   <br/>
   <br/>
   <b>Modular programming with rigorous masking (precision): </b> Any
   module is explicitly typed by a signature. The
   construction <code>with module</code> are applied to the
   sub-modules whose export is necessary.  <br/> <br/> As masking is
   irreversible, a construction <code>with module</code> on hidden
   types will only have influence on its public elements. By applying
   a rigorous masking, it is sufficient to ask at the level of each
   module whether its types or its sub-modules must be exported or
   not. The complexit of embeddings will not affect the complexity of
   the decisions to be taken concerning exports.
   </p>

   <h5>Flattening the nesting of modules</h5>
   <p>
   Despite their simplicity, the preceding examples illustrate again a
   phenomon which may become inconvenient when module embeddings are
   numerous. For example, the complete name of the type <code>t</code>
   in the module <code>M2</code>, that is to
   say, <code>M2.Sub.t</code>, reflects the complete embedding
   structure of the modules. In order to mitigate this effect, one
   redefines certain elements of abstract sub-modules to the level of
   the signature. It is then possible to "flatten" the level of
   embedding in a manner visible from the exterior of the module. For
   example:
   <pre class="prettyprint ml">
   module type S1 = sig
     type t
     val f : t &rarr; t
   end;;

   module type S2 = sig
     module Sub : S1
     type t = Sub.t
     val g : t &rarr; t
   end;;
   </pre>
   Here, the type <code>t</code> of <code>Sub</code> is replaced at
   the level of the signature <code>S2</code>. That signature includes
   from there on, the type as part of its entirity.
   </p>
   <p>
   This technique permits therefore establishing a partial inclusion
   of another module. It is crucial for making an intuitively
   structured structuring of sub-modules.
   </p>

   <h5>Modular aggregation of data-types</h5>
   <p>
   The use of sub-modules gives us leave to consider datatypes whose
   representation of values depend directrly on other datatypes. We
   have in fact already applied this idea: the
   signature <code>SET_HASH</code> indicates that the representation
   of set values be based on hash tables. Here is another example in
   the same vein. Let us propose a generalized version of an event
   loop capable of processing a set of graphic computations. This set
   will be structure in terms of association tables which we specify
   by means of the signature <code>ASSOC_TABLE</code>. The precise
   specification of the the datatype adapted to graphics interactions
   is thus the following:
   <pre class="prettyprint ml">
   module type GRAPHIC_ENVIRONMENT = sig
     module T : ASSOC_TABLE
     type action = int &rarr; int &rarr; unit (*fixed for simplicity*)
     type behaviors = (char, action) T.assoc
     val empty : unit &rarr; behaviors
     val add : char &rarr; action &rarr; behaviors &rarr; behaviors
     val interaction_with_mouse : behaviors &rarr; unit
   end;;
   </pre>
   The form of the datatype is classic except for the fact that the
   representation of the values of <code>behaviors</code> is a type
   directly dependent on the abstract sub-module <code>T</code>. A
   requirement on implementations is thus clearly expressed in this
   signature: graphics environments are necessarily association
   tables. To instantiate a <code>GRAPHIC_ENVIRONMENT</code>, one
   may reutilize and combine an implementation of events (given in an
   earlier chapter in the book this has been copied from) the the
   implementation <code>Assoc_tree</code> of association tables based
   on red-black trees:
   <pre class="prettyprint ml">
   module G_env : GRAPHIC_ENVIRONMENT = struct
     module T = Assoc_rbtree
     module G = Graphics (*an internal renaming*)
     type action = int &rarr; int &rarr; unit
     type behaviors = (char, action) T.assoc

     let empty () = T.empty ()

     let add key action l = T.add key action l

     let interaction_with_mouse l =
       let action_state = ref (snd (T.get_pair l)) in
       while true do
         let s = G.wait_next_event [Button_down; Key_pressed] in
         if s.button then ! action_state s.mouse_x s.mouse_y
         else if s.keypressed then
         try
           action_staett := T.assoc l s.key
         with
           | Not_found &rarr; ()
       done
   end;;
   </pre>
   It is then possible to create specific graphics interaction loops:
   <pre class="prettyprint ml">
   # let g1 = G_env.empty ();;
   val g1 : G_env.behaviors = &lt;abstr&gt;

   # let g1 = G_env.add 
             'l' (fun x y &rarr;
                    if x < 30 && y < 30 then failwith "Exit"
                    else if current_point () = (-1, -1)
                    them moveto x xy else lineto x y)
              g1;;
   val g1 : G_env.behaviors = &lt;abstr&gt;

   # let interaction_loop_1 () = G_env.interaction_with_mouse g1;;
   val interaction_loop_1 : unit &rarr; unit
   </pre>
   The relation between the graphics environments and association
   tables here illustrates a particular point: the management of the
   specific type of <code>ASSOC_TABLE</code> is completely in the
   charge of the type described for <code>G_env</code>. No use of
   module <code>Assoc_rbtree</code> is required from the outside : the
   module <code>G_env</code> alone creates and manipulates the
   association table. As such, the explicit typing of the
   module <code>G_env</code> need not constrain the association table
   type provided by <code>T</code>.
   </p>
   <p>
   The relation between the two datatypes may be characterised by the
   following:
   <br/>
   <br/>
   <b>Definition :</b> Suppose that<code>M_sub</code>
   and <code>M</code> describe abstract datatypes and
   that <code>M_sub</code> is a sub-module in <code>M</code>. We
   say <code>M</code> is an <i>aggregation module</i> if it manages
   completely the instances of type provided by <code>M_sub</code>.
   <br/>
   <br/>
   </p>

   <h5>Modular associations of datatypes</h5>
   <p>
   The notion of module aggregation that we have just described has of
   course a less binding version:
   <br/>
   <br/>
   <b>Definition :</b> Suppose that <code>M_sub</code>
   and <code>M</code> describe abstract datatypes and
   that <code>M_sub</code> is a sub-module of <code>M</code>. We say
   that <code>M</code> is an <i>association module</i> if the
   management of the instances of the type provided
   by <code>M_sub</code> are not completely under the charge
   of <code>M</code>.
   <br/>
   <br/>
   Another way of saying this, the exploitation of the
   module <code>M_sub</code> remains explicit (at least in part) for
   use of module <code>M</code>. For example, reconsider first of all
   a version of the signature <code>COMPLEX</code>:
   <pre class="prettyprint ml">
   module type COMPLEX = sig
     type complex
     type extern_complex
     val make : extern_complex &rarr; complex
     val show : complex &rarr; extern_complex
     val zero : complex  val one : complex
     val add : complex &rarr; complex &rarr; complex
     val mul : complex &rarr; complex &rarr; complex
     val norm : complex &rarr; float
   end;;
   </pre>
   Here, a specialization which succinctly describes a type associate
   with functions of complex numbers:
   <pre class="prettyprint ml">
   module type COMPLEX_FUN = sig
     module C : COMPLEX
     type fun_t
     type extern_fun_t
     val make : extern_fun_t &rarr; fun_t
     val apply : fun_t &rarr; C.complex &rarr; C.complex
     val apply : fun_t &rarr; C.Complex &rarr; C.complex
     val iterate : fun_t &rarr; int &rarr; C.complex &rarr; C.complex
   end;;
   </pre>
   Apart from nesting an implementation of <code>COMPLEX</code>, the
   signature specifies a priori any function which would be likely to
   create or manage complex numbers for themselves. Consequently,
   these will necessarily come from the instance of the
   sub-module <code>C</code>. Another way of saying this is the use
   and the management of complex number is not transparent to the the
   use of the the functions of a module that
   satisfies <code>COMPLEX_FUN</code>: we are indeed in one case of a
   module association. For example, here first of all an implemenation
   based on a simple instance of <code>COMPLEX</code>:
   <pre class="prettyprint ml">
   module Complex_F1 : COMPLEX
     with type extern_complex = float * float = 
   struct
     type complex = float * float
     type extern_complex = complex
     let make (r, i) = (r, i)
     let show (r, i) = (r, i)
     let zero = (0., 0.)
     let one = (1., 0.)
     ...
   end;;

   module CFuns : COMPLEX_FUN
     with type extern_fun_t = Complex_F1.complex &rarr; Complex_F1.complex
     with module C = Complex_F1 =
   struct
     module C = Complex_F1
     type fun_t = Fun of (C.complex &rarr; C.complex)
     type extern_fun_t = Complex_F1.complex &rarr; Complex_F1.complex

     let make f = Fun f
     let apply (Fun f) z = fz
     let rec iterate (fun f) n z =
       if n < 1 then z else iterate (Fun f) (n - 1) (f z)
   end;;
   </pre>
   The use of the module <code>C</code> can be carried out through the
   use of the module <code>CFuns</code>:
   <pre class="prettyprint ml">
   # let z1 = Complex_F1.make (2., 0.);;
   val z1 : Complex_F1.complex = &lt;abstr&gt;

   # let sqr = CFuns.make (fun z &rarr; Complex_F1.mul z z);;
   val z2 : CFuns.fun_t = &lt;abstr&gt;

   # Complex_F1.show (CFuns.apply sqr z1);;
   - : Complex_F1.extern_complex = (4., 0.)
   </pre>
   The utilisation may equivalently be carried from a
   sub-module <code>C</code> of <code>CFuns</code>:
   <pre class="prettyprint ml">
   # let z1 = CFuns.C.make (2., 0.);;
   val z1 : CFuns.C.complex = &lt;abstr&gt;

   # CFuns.C.show z1;;
   - : CFuns.C.extern_complex = (2., 0.)
   </pre>
   However, the user is still in the situation of having to create and
   manage the complex numbers. On the other hand, the type
   constraint <code>with module C = Complex_F1 ...</code> necessarily
   associates with <code>CFuns</code>. Indeed, the distinction between
   module aggregation and association is characterized by the module
   headers during the application of rigorous masking:
   <br/>
   <br/>
   <b>Criterion for the use of type constraints :</b> A module
   aggregation does not require a type constraint <code>with
   module</code> with regards to sub-module embedding. In contrast, a
   module association generally requires one.  <br/> <br/> Here is
   another implementation of <code>COMPLEX_FUN</code> which
   illustrates how the signature may be instantiated differently under
   the same module association conditions. The functions on complex
   numbers can be specialized to polynomials. We will represent them
   here by list of pairs (cofficient/powers of the indeterminate). So,
   for example $p(z) = (1 + i)z^{3} + (2 + i)z + (3 + i)$ is
   represented as:
   <pre class="prettyprint ml">
     p = [((1., 1.), 3); ((2., 1.), 1); ((3., 1.), 0)]
   </pre>
   <pre class="prettyprint ml">
   module CPolynom : COMPLEX_FUN
     with type extern_fun_t = (Complex_F1.complex * int) list
     with module C = Complex_F1 =
   struct
     module C = Complex_F1
     type fun_t = Fun of (C.complex &rarr; C.complex)
     type extern_fun_t = (C.complex * int) list

     let apply (Fun f) z = f z
 
     let rec iterator (Fun f) n z =
       if n < 1 then z else iterator (Fun f) (n - 1) (f z)

     let power z0 n =
       iterate (Fun (fun z &rarr; C.mul z z0)) n C.one

     let make coeflist =
       Fun (fun z &rarr; (List.fold_right
                       (fun (x, y) &rarr; C.add v (C.mul x (power z y)))
                       coeflist C.zero))
   end;;
   </pre>
   So, for example:
   <pre class="prettyprint ml">
   # let z1 = Complex_F1.make (2., 0.);;
   val z1 : Complex_F1.complex = &lt;abstr&gt;

   # let p1 = CPolynom.make [(z1, 2)];;
   val p1 : CPolynom.fun_t = &lt;abstr&gt;

   # Complex_F1.show (CPolynom.apply p1 z1);;
   - : Complex_F1.extern_complex = (8., 0.)
   </pre>
   </p>

   <h5>A complete example : "apple-men"</h5>
   <p>
   An abstract datatype may involve more several types in its
   representation of values. For example, an "apple-man" set (a kind
   of Mandlebrot set) associates a function $f(z_{1}, z_{2})$ of
   complex numbers and consists of all values $c$ such that the
   iterations $f(c, 0)$ do not diverge to infinity. In more precise
   terms, this set is defined as: \[ \{c \in \mathbb{C}\;|\;\lim_{n
   \to \infty}\|f^{n}(c, 0)\| \ne \infty\} \] To implement a program
   that permits the study of these "apple-men" sets makes natural use
   of theree datatypes : complex numbers, their functions and their
   sets. By reconsidering the signature <code>COMPLEX_FUN</code> and
   the signature <code>SET</code>, a minimal signature which specifies
   a type for "apple-men" sets follows (we utilise here lableled
   parameters for precision of the constructor):
   <pre class="prettyprint ml">
   module type APPLE_MEN = sig
     module CF : COMPLEX_FUN
     module S : SET
     type complex = CF.C.complex
     type complex_fun = CF.fun_t
     type set_elements
     type apple_man = set_elements S.set
     val make : f_c : (complex &rarr; complex_fun) &rarr;
                      diverg_ball : float &rarr;
                      max_iter : int &rarr; int
                      size : int &rarr;
                      start : float &rarr;
                      apple_man
   end;;
   </pre>
   The principle type <code>apple_man</code> described here is an
   "apple-man" set according to the definition depending on the
   signature <code>SET</code>. The constructor <code>make</code> takes
   a function parameter <code>f_c</code>$= f (c, .)$, and the
   divergencewill be established experimantally by observing the
   values after <code>max_iter</code> iterations of <code>f_c
   (0)</code>: if a value obtained exceeds <code>diverg_ball</code>,
   then the function is assumed to have diverged. The
   parameters <code>size</code> and <code>start</code> will make it
   possible to define the discretisation of the complex plane where
   the analysis will take place, that is to say a grid of points of
   the size of the square <code>[-start,
   start]</code>$\times$<code>[-start, start]</code>. Given this
   specification, we can thus for example, reuse the polynomials
   of <code>CPolynom</code> and the sets of <code>Set_H</code> in an
   imperative version. Then, an implementation of the
   signature <code>APPLE_MEN</code> made possible is provided in the
   following:
   <pre class="prettyprint ml">
   module A : APPLE_MEN 
     with type set_elements = int * int
     and module CF = CPolynom
     and module S = Set_H =
   struct
     module CF = CPolynom
     module S = Set_H
     type complex = CF.C.complex
     type complex_fun = CF.fun_t
     type set_elements = int * int
     type apple_man = set_elements S.set
 
     let make ~f_c ~diverge_ball ~max_iter ~size ~start =
       let rec diverg f z n =
         let z' = CF.apply f z in
         if CF.C.norm z > diverge_ball then true else
         if n >= max_iter then false
         else diverg f z' (n + 1) in
       let start2 = (start *. 2.) /. (float size) in
       let origin =  CF.C.zero in
       let set = S.empty () in
       let arr = Array.make size 0. in
       for i = 0 to size - 1 do
         arr.(i) <- -.start +. ((float i) *. start2) done;
       done;
       for i = 0 to size - 1 do
         for j = 0 to size - 1 do
           let z = (CF.C.make (arr.(i), arr.(j))) in
           let f = f_c z in
           if not (diverg f origin 0) then S.add (i, j) set
         done
       done;
       set
   end;;
   </pre>
   In the header of the module, the two constraints <code>with module
   = ...</code> indicate each module association from the point of
   view of <code>CF</code> and <code>S</code>. The
   constraint <code>with type set_elements = ...</code> of the
   principal abstract type of the "apple-man"
   sets <code>set_elements</code> are represented externally as
   coordinate indicies of the whole (implicitly derived from a regular
   discretization of a square domain of the plane).
   </p>
   <p>
   Here for example, the expression which constructs one "apple-man"
   of $f(c, z) = z^{4} + z^{2} + c$ for a grid $300 \times 300$ of the
   domain <code>[-1.5, 1.5]</code>$\times$<code>[-1.5, 1.5]</code>:
   <pre class="prettyprint ml">
   # let bonze = 
       A.make ~f_c:(fun c &rarr; CPolynom.make [(Complex_F1.one, 4);
                                            (Complex_F1.one, 2);
                                            (c, 0)])
              ~diverg_ball:100.00 ~max_iter:10 ~size:300 ~start:1.5;;
   val bonze : A.apple_man = &lt;abstr&gt;
   </pre>
   </p>

   <h4>Masking of types in question</h4>

   <h5>The choice to mask</h5>
   <p>
     In OCaml, the attraction of exporting types is great. Their
     instances are directly visible and accessible, the constructors
     and sum types and their field accessors of records are
     available. Instances of these types may benefit from pattern
     recognition and filtering at any point in the program. Moreover,
     no difficulties of masking need to be overcome and no type
     constraints are required in the signatures.
   </p>
   <p>
   However, the definitions of types constitute entirely a choice of
   implementation. Made public, they are likely to be diffused
   throughout the program, breaking the partitioning between
   components and by the same token, most of the expected qualities of
   a modular architecture. After the preceding examples, we can in
   fact express how the masking remedies this and summarize the
   discussion with full knowledge of the facts:
   <br/>
   <br/>
   <b>Advantages of masking :</b> Masking stops the dissemination of
   implementation choices. Refactoring, extensions and testing are
   facilitated, circumscribed and localized. The "principle of module
   substitutivity" may apply in these conditions.
   <br/>
   <br/>
   Masking is also part of a good general programming practice:
   <br/>
   <br/>
   <b>Masking and programming :</b> A program with rigorous masking
   requires a global and fine use of signatures. It is the reflection
   of a precise work of analysis of the partitions between components,
   their links and the types they contribute. On the other hand, in
   OCaml this work can be partially verified by the type system.
   <br/> <br/> We have shown here how to obtain a rigorous masking
   while preserving the possibilities of specifying and realizeing a
   network of relations between the modular components. Of course, its
   implementation includes requirements that are not neglible:
   <br/>
   <br/>
   <b>Inconveniences of masking :</b> Masking imposed written burdens
   (such as for example, the use of accessors, constructors, make-up
   types, type constraints), and is not without impact on the speed of
   execution of a program (in particular, data access passes through
   at least one indirection).  <br/> <br/> These disadvantages explain
   why it is not so easy to systematically subscribe to the rules of
   rigorous masking.  As for the "dense typing style" or the
   functional/imperative choice to apply, it depends on the
   situation. For example, the elaboration of an optimized program or
   prototype may sometimes be satisfied with an approximate
   masking. On the other hand, when the reuse of code and subsequent
   modifications are certain, the effort required by a rigorous
   masking will take on its full meeting.
   </p>
   <p>
   The example of "apple-man" sets was therefore a representative
   implementation of what could be said. External modules are reused
   there without imposing any choice of implementation. Certain
   important characteristics (as the representation of complex
   numbers, their functions and sets) are thus directly modifiable in
   a localized way. Also, the set of signatures contributes rich
   information and offers a global vision which includes the
   description of the links beteen the different component
   modules. Finally, the program is itself reusable since it is
   essentially a specific form of a datatype associated with
   sets. Obviously, it is more complicated and probably slower than
   realization using different notions and direct melees.
   </p>
   <p>
   In this respect, if the argument for program speed seems often
   decisive for renouncing the quality of a modular structure,
   accelerating a program can often be achieved by other means. The
   indirect effects due to partitioning induce in effect a latency
   which is in general very marginal compared to the principal
   calculation. On the other hand, the partitionings may be poorly
   position or dependant on poor functionalities. For example, a type
   associated with images will need not limit access to their
   individual points, but instea provide accessors to their lines,
   their columns and sub-images. This type may also benefit from
   iterators or generalized functions of composition which will
   naturally limit the need for external access. The quality of a
   partition is sometimes in question and not the intrinsic notion of
   partitioning.
   </p>
   <p>
   In the same suit, we will clarify some technical points about
   masking and its integration into OCaml programs.
   </p>

   <h5>Module records</h5>

   <p>
   Masking seems to be inhibiting when applied to short
   modules. Reconsider the example of the specification of ordered
   sets with masking:
   <pre class="prettyprint ml">
   module type ORDER_MASK = sig
     type t
     type extern_t
     val make : extern_t &rarr; t
     val show : t &rarr; extern_t
     val less_or_equal : t &rarr; t &rarr; bool
   end;;
   </pre>
   This signature is rather intimidating when compared against another
   that does not prepare for masking:
   <pre class="prettyprint ml">
   module type ORDER = sig
     type t
     val less_or_equal : t &rarr; t &rarr; bool
   end;;
   </pre>
   However, a module which satisfies this signature necessarily
   implies that it's type <code>t</code> be public : no way is
   possible to manage the proceedings if it is masked. The form of the
   signature can therefore be considered as a construction of types
   that lies between the specification of abstract types and the
   definition of types of records. In fact, it contains elements with
   distinct names, does not impose or authorize masking and its
   instances are adapated to the modular framework. We will call these
   instances of <i>module records</i>.
   </p>
   <p>
   These constructions obviously have simplifying virtues, they allow
   us to express a datatype without worrying about its
   abstraction. For example, in the framework of modules where only
   basic types and predefined functions are used, masking may be
   superfluous and "module records" well adapted. They consist only of
   a modular formatting of elements defined at the global level. Here
   for example, an instance of the signature <code>ORDER</code>:
   <pre class="prettyprint ml">
   module Int_ordered = struct
     type t = int
     let less_or_equal = ( <= )
   end
   </pre>
   Apart from the general disadvantages of non-masking, here are more
   specific counterparts of such a type construction:
   <ul>
   <li><i>Difficulties when explicitly typing</i> A signature
   like <code>ORDER</code> which is not predisposed to masking may not
   be used for explicit typing with type constraints. We will see on
   the other hand that certain types cannot appear in a type
   constraint.</li>
   <li><i>Of the asssociated implementation</i> The construction
   and the managament of the coherence of instances of
   type <code>t</code> must necessarily be setup outside the modules
   that satisfy <code>ORDER</code>. However if the structure of these
   instances become complex, these operations can't take place outside
   the module, under penalty of being considered private functions if
   a typing by <code>ORDER</code> intervenes.
   </li>
   </ul>
   For example, here is an implementation of the
   signature <code>ORDER</code> for sets of characters where the order
   relation is inclusion (that is to say, $A \le B$ if $A \subseteq
   B$) implemented with the aid of a hash table:
   <pre class="prettyprint ml">
   module Char_set_ordered = struct
     type t = Set of (char, unit) Hashtbl.t

     let less_or_equal (Set h1) (Set h2) =
       let flag = ref true in
       (
          try
            Hashtbl.iter ( fun x y &rarr;
                             if not (Hashtbl.mem h2 x) then
                               raise Not_found ) h1
          with
           | Not_found &rarr; flag := false; );
       !flag
   end;;
   </pre>
   The only way to exploit this implementation consists of
   constructing sets outside of the module as predefined hash tables
   taking into account their specific storage contract (only the keys
   represent the elements). The non-masking of the implementation here
   is seriously defaulted.
   </p>
   <p>
   That said, we will show how such an approximate partioning tactic
   sometimes leads to minimal consequences, and even, on rare
   occasions justfied use of "module-recordings".
   </p>

   <h5>Masking <i>a posteriori</i></h5>
   <p>
   Approximate masking is not irreversible. It is possible to apply
   techniques we already know.
   <br/>
   <br/>
   <b>Masking <i>a posteriori</i> by inclusion:</b> A module may be by
   inclusion to integrate type abstractions, constructors and
   accessors. A data-type can thus become abstract <i>a
   posteriori</i>.
   <br/>
   <br/>
   If we resume the example of the preceding section, we can first
   obtain a signature derived from <code>ORDER</code> which prepares
   for masking the representation of values.
   <pre class="prettyprint ml">
   module type ORDER_MASK = sig
     include ORDER
     type extern_t
     val make : extern_t &rarr; t
     val show : t &rarr; extern_t
   end;;

   module Char_set_ordered_mask : ORDER_MASK
     with type extern_t = char list =
   struct
     include Char_set_ordered

     type extern_t = char list

     let make s =
       let h = Hashtbl.create (List.length s) in
       List.iter (fun x &rarr; Hashtbl.add h x ()) s;;
       Set h

     let show (Set h) =
       let l = ref [] in
       Hashtbl.iter (fun x y &rarr; l := x :: !l) h;
       !l
   end;;
   </pre>
   Not only is the representation of values masked, but usage is made
   easier as the user does not have to manage hash tables:
   <pre class="prettyprint ml">
   # let s1 = Char_set_ordered_mask.make ['a']
     let s2 = Char_set_ordered_mask.make ['a'; 'c'];;
   val s1 : Char_set_ordered_mask.t = &lt;abstr&gt;
   val s2 : Char_set_ordered_mask.t = &lt;abstr&gt;

   # Char_set_ordered_mask.less_or_equal s1 s2;;
   - : bool = true
   </pre>
   In conformance with what has already been noted, the extended
   signature is compatible with the intial version : the module
   satisfies not only <code>ORDER_MASK</code> but
   also <code>ORDER</code>.
   </p>

   <h5>Masking and module associations</h5>
   <p>
   We must now speak of a case where masking does not necessarily need
   to be imposed: that of certain specifications of module
   associations between data-types. In fact, in such a relationship,
   it sometimes happens that a data type does not create or access
   instances of the type it uses. For example, reconsider the
   specification of the type of functions of complex numbers:
   <pre class="prettyprint ml">
   module type COMPLEX = sig 
     type complex
     type extern_complex
     val make : extern_complex &rarr; complex
     val show : complex &rarr; extern_complex
     ...
   end;;

   module type COMPLEX_FUN = sig
     module C : COMPLEX
     type fun_t
     ...
   end;;
   </pre>
   In its simplicity, the signature <code>COMPLEX_FUN</code> does not
   describe <i>a priori</i> any function likely to create or
   manipulate only complex numbers. Also, for example, the
   functions <code>make</code> and <code>show</code> were not utilized
   in the implementations of <code>CFuns</code>
   and <code>CPolynom</code>. In other words, the implementation
   of <code>COMPLEX_FUN</code> does not depend on a particular masking
   convention. The modular association specification could therefore
   have been simplified by using a signature that does not prepare for
   masking, that is to say a signature of "module records":
   <pre class="prettyprint ml">
   module type COMPLEX_NOMASK = sig
     type complex
     ...
   end;;

   module type COMPLEX_FUN = sig
     module C : COMPLEX_NOMASK
     type fun_t
     ...
   end;;
   </pre>
   It will be noted moreover that <code>COMPLEX</code> can be assumed
   compatible with <code>COMPLEX_NOMASK</code>. As a consequence, an
   instance of <code>COMPLEX</code> could also be used in the context
   of this simplification.
   <br/>
   <br/>
   <b>Masking and module associations:</b> Consider the
   specification <code>S</code> of a modular association
   between <code>M</code> and a module it
   imports <code>M_sub</code>. Then, <code>S</code> may not impose
   masking on <code>M_sub</code> when the instances originating
   from <code>M_sub</code> are not likey to be created or accessed
   in <code>M</code>.
   <br/>
   <br/>
   </p>
   <p>
   Thus, even in the case which of the requirement of rigorous
   masking, it may be advantageous to have at our disposal both
   versions of a specification : that which prepares for rigorous
   masking and that which does not. We shall see other examples of
   module association relationships.
   </p>

   <h5>The limitations of type constraints</h5>
   <p>
   <br/>
   <br/>
   <b>Limitations of the use of type constraints:</b> Constraints of
   the form <code>with type</code> may not include inductive types or
   records.
   <br/>
   <br/>
   For example, the following module header will be sanctioned as an
   error:
   <pre class="prettyprint ml">
   module Complex : COMPLEX 
     with type extern_complex = C of Num.num * Num.num = 
   struct
     ...
   end;;
   </pre>
   An inductive type or a record type may not therefore be made
   concrete <i>a posteriori</i>, and lend themselves to the
   individualized masking of abstract types. There exist some
   possibilities to remedy this siutation:
   <ul>
   <li><i>Global types</i>. Inductive and record types may also be
   defined at the global level. That solution is certainly in conflict
   with the idea of masking but is sometimes justified in the rare
   cases where the types are deliberately considered as constants of
   an implementation. These constants are then often gathered into a
   particular module that exports all it contains (in a kind of
   extension of the module <code>Pervasives</code>)
   </li>
   <li><i>Semi-global types</i>. Modules can contain modules and their
   signatures. In other words, for embedding, a module is able to play
   the role of a "package". Inductive and record types that we want to
   be able to share among several are then defined outside of these
   but in one package. We will develop this idea further.
   </li>
   <li><i>Polymorphic variants</i>. In contrast to classic inductive
   types, polymorphic variant types are able to be rendered public by
   the contstruction <code>with type</code>. For example:
   <pre class="prettyprint ml">
   module Complex_num : COMPLEX_MASK
     with type extern_complex = [`Complex of string * string] =
   struct
     type extern_complex = [`Complex of string * string]
     type complex = C of Num.num * Num.num

     let make (`Complex (str_r, str_i)) =
       C (Num.num_of_string str_r, Num.num_of_string str_i)

     let show (C (r, i)) =
       `Complex (Num.string_of_num r, Nu.string_of_num i)

     ...
   end;;
   </pre>
   Since then, the constructor of a polymorphic variant is directly usable:
   <pre class="prettyprint ml">
   # let z1 = Complex_num.make  (`Complex ("3424543643232147643", "2432014/4291"));;
   - : Complex_num.complex = &lt;abstr&gt;

   # Complex_num.show z1;;
   - : Complex_num.extern_complex =
                                 `Complex ("3424543643232147643", "2432014/4291")
   </pre>
   Let us recall however that the typing abilities with this type
   variety will be less then with classical inductive types.
   </li>
   </ul>
   </p>

   <h5>The extension of the representation of values</h5>
   <p>
   We have previously seen how extension of the processing of a
   data-type was made relatively easy by the use of module
   inclusions. Consider now extensions of the representation of values
   of a data-type. In fact, in the case of abstract data types, the
   problem is simply in contradiction to masking : the representation
   of data is private by definition, it cannot <i>a priori</i> be
   extended. Consider however the particular situation in which each
   element of the representation of values posseses it's own
   constructor and accessor. In this case, techniques for extending
   the types of records and inductive types are applicable. For
   example, suppose that we have at our disposal a
   module <code>M</code> of a signature <code>S</code> which contains
   a type <code>t</code> which we wish to extend. Here is a general
   module possible for its extension:
   <pre class="prettyprint ml">
   module type S_ext = sig
     include S
     ... (*declarations of new operations*)
   end;;

   module M_ext : S_ext = sig
     module M_old S = M
     type t = ... (*definition extending [t]*)
     ... (*implementation of operations adapted for [t]*)
     ... (*implementation of new operations*)
   end;;
   </pre>
   Note here the implementation shows a module embedding even though
   the signature utilizes an inclusion. In fact, remember that types
   can not be multiply defined in the same module, it is necessary to
   prevent it : the type <code>t</code> of <code>M_ext</code> will be
   defined by explicit adaptions of the
   sub-module <code>M_old</code>. Furthermore, the functions inherited
   from <code>M</code> will also have to be explicitly adapted to the
   extented <code>t</code>. Here is a concrete illustration of this
   model: 
   <pre class="prettyprint ml">
   module type VALUE = sig
     type value
     val make_int : int &rarr; value
     val make_float : float &rarr; value
     val int_of_value : value &rarr; int
     ...
   end;;

   module Value : VALUE = struct
     type value = Int of int | Float of float
     let make_int i = Int i
     let make_float f = Float f

     let int_of_value v = match v with
       | Int i &rarr; i
       | Float f &rarr; int_of_float f
     ...
   end;;
   </pre>
   Now, here is an extension for the representation of rational
   fractions:
   <pre class="prettyprint ml">
   module type VALUE_EXT = sig
     include VALUE
     val make_ratio : int &rarr; int &rarr; value
   end;;

   module Value_ext : VALUE_EXT = sig
     module Val = Value
     type value = V of Val.value | Ratio of int * int
     let make_int i = V (Val.make_int i)
     let make_float f = V (Val.make_float f)
     let make_ratio a b = Ratio (a, b)

     let int_of_value v = match v with
       | V v &rarr; Val.int_of_value v
       | Ratio (a, b) &rarr; a / b
     ...
   end;;

   # let v1 = Val_ext.make_int 4;;
   val v1 : Value_ext.value = &lt;abstr&gt;

   # let v2 = Val_ext.int_of_value v1;;
   - : int = 4

   # let v2 = Value_ext.make_ratio 11 2;;
   val v2 : Value_ext.value = &lt;abstr&gt;

   # Value_ext.int_of_value v2;;
   - : int = 5
   </pre>
   It is therefore possible sometimes to benefit from code resuse when
   extending a representation of values that are masked. In the case
   of incudtive types as above, the technique correspons to external
   adaption of an abstract data type whose role is related to
   emulation - an overload. Note that the use of polymorphic variants
   may somewhat simplify this extension.
   </p>

   <h4>Modules in files and separate compilation</h4>

   We have established how modules allow us to structure programs into
   distinct components. Nevertheless, as these components become
   numerous, it is neccessary to store them, transmit them and to
   compile them in an organized way. For this purpose, a classic
   technique consists of producing the modules and their compilations
   in the form of external files of the host system. Module components
   can then be assembled according to the means of this system through
   tree branches of directories, archives and version management
   tools. The OCaml language provides two mechanisms which make it
   possible to utlize external files:
   <ol>
   <li>Direct interaction of source files into the top-level by
   recopying and recompiling them.</li>
   <li>Separate compilation of source files and their integration
   either into other compiled files or the top-level.</li>
   </ol>
   We now introduce these mechanisms in the following pages.

   <h5>Loading of modules into the top-level</h5>
   <p>
   The top-level offers a simple means for importing external files
   via the command:
   <pre class="prettyprint ml">
   #use "&lt;nom.ml&gt;"
   </pre>
   where "&lt;nom.ml&gt;" is a character string which designate the
   complete name of a file in the file-system. All the lines contained
   in this file are then copied and compiled in the top-level in the
   order in which they appear. For example, consider the
   file <code>distance.ml</code> consisting of the following
   definitions:
   <pre class="prettyprint ml">
   module type DISTANCE = sig
     val dist_to_zero : float &rarr; float &rarr; float
   end;;

   module Distance : DISTANCE = struct
     let sqr x = x ** 2.
     let dist_to_zero x y = sqrt (sqr x +. sqr y)
   end;;
   </pre>
   Given this:
   <pre class="prettyprint ml">
   # #use "distance.ml" ;;
   # Distance.dist_to_zero 1. 2. ;;
   - : float = 2.23606797749979   
   </pre>
   As in the top-level, the order of loading files must be subordinate
   to the order resulting from the dependencies between the
   definitions they contain. For example, here is a
   file <code>geometric_forms.ml</code> which utilize the definitions
   of <code>distance.ml</code>:
   <pre class="prettyprint ml">
   module type GEOMETRIC_FORMS = sig
     val disk : float &rarr; float &rarr; float &rarr; bool
   end;;

   module Geometric_forms : GEOMETRIC_FORMS = struct
     let disk radius x y =
       Distance.dist_to_zero x y &lt; radius
   end;;
   </pre>
   In the top-level, the loading of <code>distance.ml</code> must
   therefore precede that of <code>geometric_forms.ml</code>:
   <pre class="prettyprint.ml">
   # #use "distance.ml";;
   # #use "geometric_forms.ml";;
   
   # Geometric_forms.disk 1.0 0.7 0.4;;
   - : bool = true
   </pre>
   </p>
   <p>
   Note that <code>#use</code> commands can also take place in external
   files and thus constitute "load files" capable of reflecting the
   overall structuring of the avialable module components.
   </p>
   <p>
   This mechanism of integrating files directly into the top-level is
   a simple one which lends itself well to medium sized
   programs. However, it presents a major disadvantage when the size
   of the program is important : the files are recompiled each time a
   <code>#use</code> is evaluated and for each top-level session.
   </p>

   <h5>Separate compilation of modules</h5>
   <p>
   There exists an alternative to the preceding method : the
   compilation of external files more specifically, the separate
   compilation of modules. We say, "unit of compilation" for the pair
   of files formed by the following:
   <ul>

   <li>An <i>implementation file</i> which is capable of containing
   everything that can be contained in a module. The name of the file
   is given the suffix "<code>.ml</code>"
   </li>
   <li>An <i>interface file</i> which consists of the declarations
   associated with the definitions of the implementation file. The
   name of the file is the sanme as the implementation file but given
   the extension "<code>.mli</code>"</li>
   </ul>
   For example, if the two files are respectively
   named <code>name.ml</code> and <code>name.mli</code> (the first
   letter may equally be captilized, e.g. <code>Name.ml</code>
   and <code>Name.mli</code>), the unit of compilation associated is
   equivalent to the following module definition:
   <pre class="prettyprint ml">
   module Name : sig (*contents of name.mli*) end
     = struct (*contents of name.ml*) end;;
   </pre> 
   Unit of compilation are compilable external to the top-level and
   also separably. To so so one used the exteranl
   commands <code>ocamlc</code> or <code>ocamlopt</code>. During this
   compilation "object files" will be produced - the mark of separate
   compilation - and will bear the following names:
   <ul>
   <li>The result of compiling an implmentation
   file <code>name.ml</code> will have the name <code>name.cmo</code>
   (byte-code) or <code>name.cmx</code> (native).</li>
   <li>The result of compiling an interface file <code>name.mli</code>
   will invariably have the name <code>name.cmi</code>.</li>
   </ul>
   Note that if there is no interface file <code>.mli</code>, it will
   be automatically generated by type inference. This will correspond
   to the complete signature of the implementation file which amounts
   to exporting everything it contains.
   </p>
   <p>
   Here is the example of the preceding section adapted for
   conformance to the definition of a unit of compilation. Consider
   the file <code>distance.mli</code> following:
   <pre class="prettyprint ml">
   val dist_to_zero : float &rarr; float &rarr; float
   </pre>
   The file <code>distance.ml</code> then contains a possible
   implementation of this implicit signature:
   <pre class="prettyprint ml">
   let sqr x = x ** 2.
   let dist_to_zero x y = sqrt (sqr x +. sqr y)
   </pre>
   These two files form a unit of compilation equivalent to the
   definition of the following module:
   <pre class="prettyprint ml">
   module Distance : sig
     val dist_to_zero : float &rarr; float &rarr; float
   end = struct
     let sqr x = x ** 2.
     let dist_to_zero x y = sqrt (sqr x +. sqr y)
   end;;
   </pre>
   The compilation of the interface file must be carried out before
   the compilation of the implementation file. For example, in the
   case of generating byte-code from the files:
   <pre>
   $ ocamlc distance.mli
   $ ocamlc distance.ml
   </pre>
   The commands result in the generation of the
   files <code>distance.cmi</code> and <code>distance.cmo</code>. Note
   that the <code>ocamlc</code> and <code>ocamlopt</code> commands
   accept more than one argument : they can be files with extensions
   "<code>.mli</code>" and "<code>.ml</code>" or files
   "<code>.cmi</code>", "<code>.cmo</code>" (respectiveley
   "<code>.cmx</code>") alread compiled. We may therefore write:
   <pre>
   $ ocamlc distance.mli distance.ml
   </pre>
   </p>
   <p>
   Let us now continue the adaption of the example of the preceding in
   composing the following files:
   <pre class="prettyprint.ml">
   (*File : geometric_forms.mli*)
   val disk : radius:float &rarr; float &rarr; float &rarr; bool

   (*File : geometric_forms.ml*)
   let disk ~radius x y = Distance.dist_to_zero x y < radius
   </pre>
   The compilation of this new unit must integrate information taht
   makes it possible to establish links with the
   unit <code>distance</code>. As in the top-level an element used in
   a unit must have been defined in an earlier unit. The arguments of
   a compilation command reflect therefore this order. For example,
   if <code>distance.ml</code> has not already yet been compiled:
   <pre>
   $ ocamlc distance.mli distance.ml geometric_forms.mli geometric_forms.ml
   </pre>
   But also - and this is one of the interests of separate compilation
   -, if <code>distance.ml</code> has already been compiled, the
   object file may be included directly:
   <pre>
   $ ocamlc distance.cmo geometric_forms.mli geometric_forms.ml
   </pre>
   </p>
   <p>
   Another advantage of separate compilation consists of the ability
   to organize by means of tools external to the lanague (for
   example <code>make</code>). These tools take into consideration the
   links between the different units and allow selective
   recompiliation that depend on what modifications that have been
   carried out. Further, units of compilation can be grouped into
   libraries. This compilation can be effected with the option
   "<code>-a</code>" (the extension of the object file of a library is
   "<code>.cma</code>"). By default, the name of the library is
   "<code>library.cma</code>" but by means of the "<code>-o</code>"
   option, you can choose any name desired. For example,
   <pre>
   $ ocamlc -o metrics.cma -a \
       distance.cmo geometric_forms.mli geometric_forms.ml
   </pre>
   This command will create a library "<code>metrics.cma</code>" which
   assembles the modules <code>Distance</code>
   and <code>Geometric_form</code>.
   </p>
   <p>Thus, compilation units completely remedy the shortcomings of
   direct loads via the command <code>#use</code>.
   </p>

   <h5>Precompiled modules and the top-level</h5>
   <p>
   Units compiled to byte-code can be integrated into the
   top-level. The following command will be used for this purpose
   (instead of <code>#use</code> which only applies to files that have
   not been compiled):
   <pre class="prettyprint ml">
   #load "&lt;name&gt;.cmo"
   </pre>
   where "&lt;name&gt;.com" is a string designating the compile name
   of a file in the file-system. The consequences of this command are
   similar to <code>#use</code> : if the file <code>name.cmo</code>
   exists it is loaded intot he top-level in the form of a module
   named <code>Name</code> (without having to compile it). Consider a
   new example of the preceding section:
   <pre class="prettyprint ml">
   # #load "distance.cmo";;
   # #load "geometric_forms.cmo";;

   # Geometric_forms.disk 1.0 0.7 0.4;;
   - : bool = true
   </pre>
   It should be noted that this load can be established from the
   launch of the top-level. Just call <code>ocaml</code> with the
   corresponding "<code>.cmo</code>" files. For example:
   <pre>
   $ ocaml distance.cmo geometric_forms.cmo
   </pre>
   There also exists a command <code>ocamlmktop</code> which provides
   for building a top-level which contains the compiled units
   automatically.
   </p>
   <p>
   These new possibilities induce a general technique for development:
   <br/>
   <br/>
   <b>Program development by extension of the top-level : </b> Any
   implemented module can be compiled and definitively integrated into
   the top-level interaction loop. It becomes more and more
   specialized, evolving in concert with the program which is being
   developed.
   <br/>
   <br/>
   This technique offers a new form of "incremental programming" which
   applies at the modular level and complements the one we have
   illustrated at the functional level. The evolution of the top-level
   becomes an integral part of global development.
   </p>
   <p>
   For example, it is easy to provide the set of elements provided by
   default in the top-level. Consider a
   file <code>ocaml_plus.ml</code> including the generic constructors
   of lists which are not part of the module <code>List</code>, and a
   definition of binary tree type:
   <pre class="prettyprint ml">
   let rec list_build f n x =
     if n &lt;= 0 then []
     else x :: (list_build f (n - 1) (f x));;

   let list_interv n len =
     list_build (fun x &rarr; x + 1) len n;;

   type &alpha; bintree =
     | Bin_empty
     | Bin_node of &alpha; * &alpha; bintree * &alpha; bintree;;
   </pre>
   The following commands generate a top-level which contains these
   definitions:
   <pre>
   $ ocamlc ocaml_plus.ml
   $ ocaml ocaml_plus.cmo
   </pre>
   <pre class="prettyprint ml">
   # open Ocaml_plus ;;

                  Objective Caml

   # list_build ;;
   - : (&alpha; &rarr; &alpha;) &rarr; int &rarr; &alpha; &rarr; &alpha; list

   # Bin_empty ;;
   - : &alpha; Ocaml_plus.bintree = Bin_empty
   </pre>
   </p>

   <h5>Precompiled modules and side-effects</h5>
   <p>
   We have passed over silently in the course of the preceding
   discussion that compilation by <code>ocamlc</code>
   or <code>ocamlopt</code> generates not only object files
   corresponding to each compilation unit, but also an executable. By
   default, the name of that executable is <code>a.out</code> and it
   may be renamed by the option <code>-o</code>. Evidently, its
   execution can have consequences only by interposed side effect. For
   example, reconsider the file <code>fact.ml</code> following:
   <pre class="prettyprint ml">
   let rec fact n =
     if n &lt;=1 then 1 else n * fact (n - 1)
   let () = print_int (fact 3)
   let () = print_newline ()
   </pre>
   Then:
   <pre>
   $ ocamlc -o fact fact.ml
   $ fact
   6
   </pre>
   How do we reconcile this observation with what we have just
   introduced about separate compilation? First of all, the above file
   alone constitutes a compilation unit (we are in a case where the
   interface file <code>fact.mli</code> is automatically
   generated). That compilation unit then describes a module
   named <code>Fact</code> which exports all of it's contents. That is
   to say:
   <pre class="prettyprint ml">
   module Fact = struct
     let rec fact n =
       if n &lt;=1 then 1 else n * fact (n - 1)
     let () = print_int (fact 3)
     let () = print_newline ()
   end;;
   </pre>
   Recall the rules associated with the construction of a module :
   evaluation of the elements are in the order in which they occur. A
   module is in fact only a particular space of definitions and
   nothing prevents the evaluation/execution of expressions. The
   executable produced by separate compilation of a
   unit <code>M</code> corresponds to the series of
   evaluations/executions associated with the construction
   of <code>M</code>. The <code>fact</code> command above thus
   effectively summarizes to the calls of the two <code>Fact</code>
   display programs.
   </p>

   <h5>The technqiue of parent modules : packages</h5>
   <p>
   During the development of a modular program, there are several
   general techniuqes for using the compilation units. The simplest is
   the following:
   <br/>
   <br/>
   <b>Modular programming (C language style) :</b> Each module is
   associated with a unit of compilation of its own. The external file
   structure is then similar to the structure of modules in the
   program.
   <br/>
   <br/>
   The application of this technique implies the relationalship
   between the "<code>.mli</code>" and "<code>.ml</code>" files is
   very similar to the relationship between header files
   "<code>.h</code>" and implementation files "<code>.c</code>" in the
   C programming language. However, this technique demand also
   renouncing certain important possibilities offered by the module
   language system:
   <ul>
   <li><i>Anonymous signatures.</i> Interface files
   "<code>.mli</code>" do not name the signatures they describe. These
   signatures can therefore have no other role than to explicitly type
   their corresponding implementation file. Thus for example, all
   techniques related to inclusions and abstract sub-modules become
   unusable since they depend in part on the names of
   signatures. Similarly, constraints of the form <code>with
   type</code> no longer find a place in programes and hence a masking
   of the abstract types is no longer conceivable. We will see
   moreover that "functors" also require the use of named signatures.
   </li>
   <li><i>Uniqueness of the implmementation.</i> The univocal link
   between the interface "<code>.mli</code>" and implementation
   "<code>.ml</code>" files imposes <i>a priori</i> that each
   signature may have only one implementation in a program. Yet, one
   of the pecularities of the ML module system is to not only consider
   signatures as interfaces but also as types that can be instantiated
   in multiple ways.</li>
   </ul>
   That said, the technique of modular programming "C style" is not at
   all a fatality in OCaml because modules may contain other
   modules. Consequently, compilation units may themselves contain
   signatures and modules thus forming packages. For example, consider
   the implementation file <code>metric_space_unit.ml</code> following:
   <pre class="prettyprint ml">
   module type METRIC_SPACE = sig
     type point
     type extern_point
     val make_point : extern_point &rarr; point
     val dist : point &rarr; point &rarr; float
   end;;

   module Line : METRIC_SPACE
       with type extern_point = float =
   struct
     type point = Point of float
     type extern_point = float
     let make_point x = Point x
     let dist (Point x) (Point y) = abs_float (x -. y)
   end;;
   </pre>
   In the framework of compilation units, the file can be considered
   equivalent to the following module:
   <pre class="prettyprint.ml">
   module Metric_space_unit = struct
     module type METRIC_SPACE = ...
     module Line : METRIC_SPACE with type extern_point = float = ...
   end
   </pre>
   A corresponding interface file <code>metric_space_unit.mli</code>
   could be:
   <pre class="prettyprint ml">
   module type METRIC_SPACE = sig
     type point
     type extern_point
     val make_point : extern_point &rarr; point
     val dist : point &rarr; point &rarr; float
   end;;

   module Line : METRIC_SPACE with type extern_point = float
   </pre>
   Then, this compilation unit compiles like the others:
   <pre>
   $ ocamlc metric_space_unit.mli metric_space_unit.ml
   </pre>
   It's use further shows that masking of type has been applied as
   expected:
   <pre class="prettyprint ml">
   # #load "metric_space_unit.cmo" ;;

   # let p1 = Metric_space_unit.Line.make_point 4.3 ;;
   val p1 : Metric_space_unit.Line.point = &lt;abstr&gt;

   # Metric_space_unit.Line.dist p1 p1 ;;
   - : float = 0.
   </pre>
   </p>
   <p>
   An immediate advantage of this structuring into packages is to
   restore the possibilities of signatures. For example, in the other
   unit, we may integrate an implementation of plane which equally
   satisfies the signature <code>METRIC_SPACE</code> as the
   module <code>Line</code>. Here indeed is a new implementation
   file <code>metric_space_plane_unitl.ml</code>:
   <pre class="prettyprint ml">
   module M = Metric_space_unit

   module Plane : M.METRIC_SPACE
     with type extern_point = float * float = struct
     type point = ...
     ...
   end;;
   </pre>
   Compilation can be directly obtained:
   <pre>
   $ ocamlc metric_space_unit.cmo metric_space_plane_unit.ml
   </pre>
   </p>
   <p>
   This structuring of packages imples a new supplemental level of
   embedding and thus some heaviness in the form of names. As above,
   one can employ aliases in order to alleviate that or even consider
   the idea of using the <code>open</code> directive. In this
   framework, openings are less likely to result in inapproriate
   redefinitions and to weaken the global software architecture.
   </p>
   <p>
   So, in considering compilation units as a base for the idea of
   packages, it is possible to give an alternative technique for
   modular programming in the C style. In order to clearly identify
   the files, one could always suffix the names with
   "<code>_unit</code>" and their general form would consist of three
   parts:
  <br/>
  <br/>
  <b>General form of packages:</b> ("<code>.ml</code>" parent
   modules)
   <pre>
   module MI_1 = M1_unit
   ... (*aliases for imports*)
   module MI_k = Mk_unit
   </pre>
   <pre>
   module type S1 = ...
   ... (*signatures*)
   module type Sm = ...
   </pre>
   <pre>
   module M1 = ...
   ... (*modules*)
   module Mn
   </pre>
   We will replace here the expressions <code>module MI_i =
   Mi_uinit</code> with the expressions <code>open Mi_unit</code> in
   the case where one would be satisfied with simple openings of the
   packages <code>Mi_unit</code>.
   <br/>
   <br/>
   <b>Modular programming with packages:</b> The nominated modules and
   signatures are contained in packages that constitute
   implemementation "<code>.ml</code>" files. The structuring of
   external files induces then a new supplementary level of
   description connected to the structure of modules in the program.
   <br/>
   <br/>
   Implementation masking becomes once again fully controlable and the
   techniques of inclusion of modules and abstract sub-modules are
   again available. It should also be noted that one of the
   consequences of this structuring is to make the need for specific
   interface "<code>.mli</code>" files rather rare (remember these
   files are generated automatically if they are not provided). It is
   not very common to hide signatures and modules. Interface files can
   be useful when defining "locally global" elements taht are only
   shared by the components of the same package.
   </p>
   <p>
   It should be noted that in the case of explicit interface files,
   the above technique induces duplication of signatures between the
   "<code>.ml</code>" and "<code>.mli</code>" files. On the other
   hand, the notion of interface files is equally related to the
   possibility of describing and transmitting a programe without
   implementation. Package structuring can then be refined :
   <br/>
   <br/>
   <b>Modular programming with packages (precision) : </b> Packages
   can be separated into two species : those that contain only
   signatures and those that contain only modules. We thus obtain
   packages of specification and packages of implementation.
   <br/>
   <br/>

   Adapting the preceding example gives a new form of
   organisation. Firstly, here is the file that contains the
   signature (<code>metric_space_spec.ml</code>):
   <pre class="prettyprint ml">
   module type METRIC_SPACE = sig
     type point
     ...
   end;;
   </pre>
   Next, the implementation is provided in another file
   (<code>metric_space_impl.ml</code>):
   <pre class="prettyprint ml">
   module S = Metric_space_spec

   module Line : S.METRIC_SPACE
     with type extern_point = float =
   struct
     ...
   end;;
   </pre>
   Compilation of the ensemble is then obtained with the command:
   <pre>
   $ ocamlc metric_space_spec.ml metric_space_impl.ml
   </pre>
   In order to distinguish between them, specification packages and
   implementation packages can systematically employ suffixes as in
   the example, that is, respectively "<code>_spec.ml</code>" and
   "<code>_impl.ml</code>".
   </p>

   <h3>Generic modular programming : functors</h3>    

   <p>
   The preceding sections show why and how to decouple a program into
   seperate distinct components, how to partition components and how
   to specify them before implmentation. In particular, when we
   discussed the advisability of implementation hiding techniques, the
   main quality criteria being precision and shows, namely in the the
   situation of being able to modify and replace modules locally as
   related but autonomous elements. The subsitution principle is in
   effect the essential characteristic of organisation and module
   reuse. There remains at least one point to improve : the conditions
   that allow us to express and exploit this substitutivity. Generic
   programming allowing the full participation of modules.
   </p>
   <p>So, in these sections, first of all we introduce the notion of
   "functions of modules", that is, <i>functors</i>, which will be the
   principal tools of modular generiticity. We then present some
   conceptual models associated with their use. A thorough discussion
   will be provided about various types of signatures. Highlighting
   their features, we will find functors can be compiled
   independently, that they can posses more than one parameter, are
   typable by signatures of their own and they allow their arguments
   also to be functors. We will then discuss the advantages and
   inconveniences of generic modular programming based on
   functors. Finally, we introduce a graphical representation for
   functors and examples illustrating usage.
   </p>
    
   <h4>Functors</h4>

   <h5>The idea of "functions of modules"</h5>

   <p>
   We have seen that modules and signatures offer a simple means of
   adaption and extension. Recall the example based on the type of
   complex numbers with the following signature:
   <pre class="prettyprint ml">
   module type COMPLEX = sig
     type complex
     val make : float * float &rarr; complex
     val show : complex &rarr; float * float
     ...
   end;;
   </pre>
   So now supposing <code>Complex</code> is a module that satisfies
   the <code>COMPLEX</code> signature, an extension can easily be
   obtained by inclusion:
   <pre class="prettyprint ml">
   module Complex_ext = struct
     include Complex
     let mul z w =
       let (r1, i1) = show z and (r2, i2) = show w in
       make (r1 *. r2 -. i1 *.i2, i1 *. r2 +. i2 *. r1)
   end;;
   </pre>
   This extension is however specific to the
   module <code>Complex</code>. Yet it turns out it is structurally
   independent of the details of the implementation of the module :
   nothing in the body of the new function <code>mul</code> alludes to
   anything particularly specific to <code>Complex</code>. Consider
   the effect on a different implementation of <code>COMPLEX</code>,
   for example, <code>Complex_memo</code>. The extension follows:
   <pre class="prettyprint ml">
   module Complex_memo_ext = struct
     include Complex
     let mul z w =
       let (r1, i1) = show z and (r2, i2) = show w in
       make (r1 *. r2 -. i1 *.i2, i1 *. r2 +. i2 *. r1)
   end;;
   </pre>
   The substitution principle applies here, but is embodied by an
   explicit operation on the code : <code>Complex</code> is replaced
   by hand by the module <code>Complex_memo</code>. This situation is
   similarl in fact to not knowing the concept of function but only
   that of constants!
   </p>
   <p>
   So, very naturally, ML languages offer a construction related to
   that of functions that solves the problem:
   <pre class="prettyprint ml">
   module F (C : COMPLEX) = struct
     include C
     let mul z w =
       let (r1, i1) = show z and (r2, i2) = show w in
       make (r1 *. r2 -. i1 *.i2, i1 *. r2 +. i2 *. r1)
   end;;
   </pre>
   The operation <code>F</code> takes a module
   parameter <code>C</code> of type the
   signature <code>COMPLEX</code>. The application simply retunrs a
   module integration the argument transmitted as a parameter. So, for
   example, the two extensions of complex numbers discussed earlier
   can be obtained by direct applications of <code>F</code>:
   <pre class="prettyprint ml">
   # module Complex_ext = F (Complex);;

   # module Complex_memo_ext = F (Complex_memo);;
   </pre>
   </p>
   <p>
   This new kind of operation consititues a means to facilitate
   substituion of modules. It can express abstractions on modules
   through its parameters and therefore new forms of generalization
   and generiticity. We will develop and explain these ideas
   throughout the pages that follow.
   </p>

   <h5>Defining functors</h5>

   <p>
   A "function of modules", that is to say, a parameterized module, or
   more specifically a functor, permits the passing of modules as
   arguments to construct other modules on which they depend. The
   basic syntax of a functor in OCaml naturally resembles that of
   anonymous functions:
   <br/>
   <br/>
   <pre class="prettyprint ml">
   functor (&lt;Parameter&gt; : &lt;SIGNATURE&gt;) &rarr;
    struct
      type ...           exception ...
      let ...            module ...
      module type ...    open ...
      include ...        &lt;exp&gt;
      ...
    end
   </pre>
   <br/> <br/> In the above, it is indicated
   that <code>&lt;Parameter&gt;</code> necessarily
   satisfies <code>&lt;SIGNATURE&gt;</code>. As a functor computes a
   module, the body of the functor is enclosed the
   keywords <code>struct</code> and <code>end</code>. On the other
   hand, this construction does not itself define a value. We use a
   new module keyword to link to a name:
   <pre class="prettyprint ml">
   module &lt;Name&gt; = 
     functor (&lt;Parameter&gt; : &lt;SIGNATURE&gt;) &rarr;
      struct
        ...
      end
   </pre>
   Such a definition can be abbreviated as so:
   <br/>
   <br/>
   <pre class="prettyprint ml">
   module &lt;Name&gt; (&lt;Parameter&gt; : &lt;SIGNATURE&gt;) = struct
     ...
   end
   </pre>
   <br/> <br/> We obtain here a syntax similar to functions. The
   underlying rule of the definition of functors is given next:
   <br/>
   <br/>
   <b>Functor definition rule : </b> All the elements enclosed in
   the <code>struct-end</code> are compiled sequentially in the order
   they apppear. Each new binding may use the bindings that precede it
   and are strictly associated with the body of the functor. However,
   there are no evaluations. The overall result is bound to the
   identifier <code>&lt;Name&gt;</code>.  <br/> <br/> As for
   functions, evaluation of the body of the functor is effected on
   application and conforms to the rules of a simple module.
   </p>
   <p>Despite the similarities between functions and functors the
   following important difference should be noted:
   <br/>
   <br/>
   <b>The explicit typing of parameters is mandatory :</b> In
   constrast to functions, functors require explicit typing of their
   parameters.
   <br/>
   <br/> 
   In effect, the feature of type inference in ML languages does not
   extend to calculating the signatures of functor parameters (it is
   generally "undecidable").
   </p>

   <h5>Using functor parameters</h5>

   <p>
   The parameters of functors denote modules which are usually used in
   the body of the functor using indirection ("member-selection"
   notation). For example,
   <pre class="prettyprint ml">
   module type S = sig
    type t
    val f : t &rarr; t
   end;;

   module F (M : S) = struct
     type s = M.t  (*recover the type in [M]*)
     let pair x = (x, M.f x) (*apply the function [f] in [M]*)
   end;;
   </pre>
   The type <code>t</code> and the function <code>f</code> of the
   parameter <code>M</code> appear in the implementation of the body
   of the functor <code>F</code>. The parameters of a functor define a
   local environment but this time consisting of modules. The same
   rules of information hiding for simple values apply to the names of
   modules.
   </p>


   <h5>Functor application</h5>

   <p>
   The syntax of functor application is also similar to that of a
   function application, and the result must be bound to the name of a
   module:
   <br/>
   <br/>
   <pre class="prettyprint ml">
   module &lt;Name&gt; = &lt;Functor&gt; (&lt;Argument&gt);;
   </pre>
   <br/> <br/> where <code>&lt;Argument&gt</code> is a module
   statisifying the signature of the parameter
   of <code>&lt;Functor&gt;</code>. For example, here is an instance
   of the signature <code>S</code> of the preceding section:
   <pre class="prettyprint ml">
   module Increm = struct
     type t = int
     let f x = x + 1
   end;;
   </pre>
   It is then possible to apply the functor <code>F</code>:
   <pre class="prettyprint ml">
   # module M1 = F (Increm);;
   </pre>
   The use of the module <code>M1</code> is as usual:
   <pre class="prettyprint ml">
   # M1.pair 1;;
   - : Increm.t * Increm.t = (1, 2)

   # M1.pair 2;;
   - : Increm.t * Increm.t = (2, 3)
   </pre>

    Here are some precise illustrations of two points relating to the
    rule of definition and application of a functor:
    <ul>
    <li>
    <i>The evaluation of the elements of a functor takes place at the
    moment of application.</i>
    <br/>
    <br/>
    For example:
    <pre class="prettyprint ml">
    # module Div_zero (M : sig end) = struct
        print_endline "In division by zero"
        let x = 1 / 0
      end;;

    # module M1 = Div_zero (struct end);;
    In division by zero
    Exception : Division_by_zero
    </pre>
    <br/>
    <br/>
    </li>
    <li>
    <i>Each application of a functor produces a new distinct
    module.</i>
    <br/>
    <br/>
    In particular, if a functor produces modules with internal state,
    those states are distinct. For example:
    <pre class="prettyprint ml">
    module Count_state (M : sig end) = struct
      let count = ref 0
    end;;

    # module V1 = Count_state (struct end)
      module V2 = Count_state (struct end);;
    module V1 : sig val count : int ref end
    module V2 : sig val count : int ref end

    # incr V1.count;;
    - : int ref = { contents = 1}

    # V2.count ;;
    - : int ref = { contents = 0}
    </pre>
    </li>
    </ul>
   </p>

   <h5>Explicit typing of the results of functors</h5>

   <p>
   As functors are part of the operation of language types it is
   naturally possible to render explicitly the signature of their
   results. For this purpose, we use the same notation as for
   functions. Consider for example the following signature:
   <pre class="prettyprint ml">
   module type S_RESULT = sig
     type s
     val pair : s &rarr; s * s
   end;;
   </pre>
   We can then reconsider an earlier example and explicitly type the
   result fo the functor <code>F</code> in two different ways:
   <pre class="prettyprint ml">
   module F_explicit (M : S) : S_RESULT = struct
     type s = M.t
     let pair x = (x, M.f x)
   end;;

   module F_explicit (M : S) = (struct
     type s = M.t
     let pair x = (x, M.f x)
   end : S_RESULT);;
   </pre>
   Explicit typing induces information hiding of the elements
   contained in the body of the functor. The rules are the following
   and reflect directly those which apply to modules:
   <br/>
   <br/>
   <b>Rule (1) : the visibility of the result of a functor : </b> The
   result of a functor unless explicitly typed by a signature has
   public contents.
   <br/>
   <br/>
   <b>Rule (2) : the visibility of the result of a functor : </b> The
   result of a functor explicitly typed by a signature <code>S</code>
   has public contents limited to those defined in the definition
   of <code>S</code> (with the exception of abstract types).  
   <br/>
   <br/>
   We can verify the safe application of the
   functor <code>F_explicit</code> above:
   <pre class="prettyprint ml">
   module Increm = struct
     type t = int
     let f x = x + 1
   end;;

   # module M1 = F_explicit (Increm);;

   # M1.pair 1;;
             ^
   Error: This expression has type int but an expression was expected
         of type M1.s = F_explicit(Increm).s
   </pre>
   The abstract type <code>s</code> of <code>M1</code>
   (from <code>t</code> of <code>Increm</code>) has become private
   since the functor result is explicitly typed.
   </p>
   <p>
   Evidently, individual masking of abstract types and abstract
   sub-modules by the constructions <code>with</code> adapt too to the
   case of the results of functors. One may then apply rigorous
   masking when programming with functors:
   <br/>
   <br/>

   <b>Modular programming with functors and rigorous masking:</b>
   <ol>
   <li>Every functor sees its result explicitly typed by a signature.</li>
   <li>The constructions <code>with type</code> (resp. <code>with
   module</code>)</li> are applied to the types (resp. sub-modules)
   aas necessary.
   </ol>
   <br/>
   <br/>
   </p>

   <h5>Shared types and transmission of types</h5>
   <p>
   If the explicit typing of the result of a functor can also benefit
   from type constraints, a new one appears however here : these
   constraints are able to be established between the types of the
   parameters of a functor and the types that appear in the body of
   this same functor. One may recreate the example from the preceding
   section in the manner following:
   <pre class="prettyprint ml">
   module F_explicit (M : S) :
     S_RESULT with type s = M.t =
   struct
     type s = M.t
     let pair x = (x, M.f x)
   end;;
   </pre>
   The result signature <code>S_RESULT</code> depends here
   on <code>M</code> which is permissible since it is part of the
   environment of constraint : the type <code>s</code> is
   systematically rendered concrete by the relationship to
   type <code>t</code> of the argument <code>M</code>. Therefore, the
   application of the functor makes it possible to export a type
   without having to know <i>a priori</i> the identity:
   <pre class="prettyprint ml">
   # module M1 = F_explicit (Increm);;
   
   # M1.pair 1;;
   - : M1.s * M1.s = (1, 2)
   </pre>
   Contrary to the example of the preceding section, the type of the
   result module remains public thanks to the type constraint. The
   type has been transmitted and made concrete through application of
   the functor. In fact, functors offer the opportunity to use
   constraints which are concerned with such "type sharing".
   </p>

   <h5>Non-module parameters</h5>
   <p>
   It is sometimes desirable to parametrize a functor by not only
   modules but also simple values. OCaml does not directly allow this
   mixing of genres. It suffices however to encapsulate the value to
   be transmitted in a module to obtain the desired effect. For
   example:
   <pre class="prettyprint ml">
   # module F (M : sig val x : int end) = struct
       let v = M.x
     end;;

   # module M = F (struct let x = 3 end);;

   # M.v;;
   - : int = 3
   </pre>
   Here is a less formal example. Its about matrices on integers of a
   certain size (without masking and reduced to a simple operation):
   <pre class="prettyprint ml">
   module Int_matrix (S : sig val size : int end) = struct
     type mat = int array array
     let add m1 m2 =
       let mat = Array.create_matrix S.size S.size m1.(0).(0) in
       for i = 0 to (S.size - 1) do
         for j = 0 to (S.size - 1) do
           mat.(i).(j) <- m1.(i).(j) + m2.(i).(j)
         done
       done;
       mat
   end;;
   </pre>
   For example:
   <pre class="prettyprint ml">
   # module Int_matrix_3x3 = Int_matrix (struct let size = 3 end);;

   # let m = [|[|1; 1; 1|]; [|1; 0; 1|]; [|1; 1; 1|]|];;

   # Int_matrix_3x3.add m m;;
   - : int array array = [|[|2; 2; 2|]; [|2; 0; 2|]; [|2; 2; 2|]|]
   </pre>
   By means of a functor, we remedy here the fact of not being able to
   define "dependant types". In fact, it is not possible in OCaml to
   give a type parameter on values such that:
   <pre class="prettyprint ml">
   # type (n : int, &alpha;) matrix = ...
   </pre>
   or <code>n</code> would be instantiated by an integer.
   </p>

   <h5>Functors : a generic modular programming type</h5>
   <p>
   Functors constitute in ML, the principal tools of generic modular
   programming, that is to say, the expression of abstractions over
   modules. It is necessary to remark however that modular
   generiticity is not a possibility exclusive to the ML languages and
   that it does not necessarily take this form:
   <ul>
   <li>C++ offers "parameteric classes" or "class templates". The
   parameters of these constructions are not however types but simply
   instansiable by a rewriting mechanism proceeding compilation. The
   parametrized components therefore are not completely compilable
   without being instantiated and type control can only be established
   when they are actually used. On the other hand, for reasons of
   optimization, each instantiation generates independent code
   distinct from the others.</li>
   <li>The languages Eiffel and Java 1.5 offer generic constructions
   with standard parameters : their instantiations must then satisfy a
   class type or an interface. One speaks here of "generiticity
   constraints". However, these type constraints do not allow a fine
   analysis of typing in all situations : in these languages, the
   instantiation of the parameters is often dependent on the inclusion
   polymorphism which benefits the objects.
   </li>
   <li>In Ada, generiticity over modules may equally be constrained
   and is strictly typed. That generiticity is however somewhat
   obstructed by cumbersome writing and use.
   </li>
   </ul>
   This rapid inventory leads us to hightlight the advantages of
   modular generiticity of the ML languages:
   <br/>
   <br/>
   <b>The specification of generic modular programming in ML : </b>
   Functors are autonomous components, individually compilable, easy
   to use, strictly typed and generiticity constrained. As modular
   components they are integrally integrated into the type system.
   <br/>
   <br/>
   Let us develop the last point of this box. We saw earlier that the
   relationship between signature/module is similar to the relationsip
   of type/value.
   \[
     \begin{eqnarray}
      value    &\leftrightarrow&   module \nonumber \\
      type     &\leftrightarrow&   signature \nonumber \\
      function &\leftrightarrow&   functor \nonumber
     \end{eqnarray}
   \]
   Modules are defined and indeed typed like other values in the
   language, and signatures may have multiple instantiations. Fron now
   on, we also know that functors allow to pass modules as arguments
   and return modules as results. We shall see later that they have
   their own signatures and they accept other functors as
   arguments. Thus very clearly, functors extend the parallel between
   the world of typical values and the world of modules. Generic
   modular programming is similar to a language with typical functions
   which favors a functional style. We will return to these general
   questions when functors have been presented in more detail.
   </p>

   <h4>Techniques for using functors</h4>
   <p>
   Use of functors is expressed in terms of natural and recurring
   forms. It is also possible to extract "conceptual models". We
   present here some of them which consist for the most part in
   generalizations of modular programming techniques of which we have
   already spoken:
   <ul>
   <li>Generic inheritance</li>
   <li>Generic adaption</li>
   <li>Generic decoration</li>
   <li>Generic composition</li>
   <li>Types of generic data</li>
   </ul>
   We will also develop the model of "control of generiticity".
   </p>

   <h5>Generic module inheritance</h5>
   <p>Functors permit inclusion of modules to be generic and with
   them, the techniques wich which are associated. We had for example
   earlier pointed out that inclusion is like inheritance.
   <br/>
   <br/>
   <b>Definition : </b> Generic module inheritance is inheritance
   expressed by inclusion of modules and generalized to functors.
   <br/>
   <br/>

   The extension of the type of complex numbers earlier illustrated an
   example of generic inheritance. First of all, recall a signature
   for simple sequential data:
   <pre class="prettyprint ml">
   module type LINEAR_CONTAINER = sig
     type &alpha; t
     val empty : unit &rarr; &alpha; t
     val add : &alpha; &rarr; &alpha; t &rarr; &alpha; t
     val mem : &alpha; &rarr; &alpha; t &rarr; bool
     val length : &alpha; t &rarr; int
     val nth : &alpha; t &rarr; int &rarr; &alpha;
   end;;
   </pre>
   Suppose we wished to add functions that return the first and last
   element of a container. The resulting signature would then be
   defined by inheritance of <code>LINEAR_CONTAINER</code>:
   <pre class="prettyprint ml">
   module type LINEAR_CONTAINER_EXT = sig
     include LINEAR_CONTAINER
     val first : &alpha; t &rarr; &alpha;
     val last : &alpha; t &rarr; &alpha;
   end;;
   </pre>
   So, the operation of extending an instance
   of <code>LINEAR_CONTAINER</code> can be summed up by a functor:
   <pre class="prettyprint ml">
   module Lin_ext (L : LINEAR_CONTAINER) : LINEAR_CONTAINER_EXT = struct
     include L
     let first l = L.nth l 0
     let last l = L.nth l ((L.length l) - 1)
   end;;
   </pre>
   One notes here a property which echoes the case of modules :
   functors do not have privileged access to their arguments. They
   must therefore use the avaialable constructors and accessors. Here
   are two implementations of <code>LINEAR_CONTAINER</code>, one based
   on lists, the other on arrays:
   <pre class="prettyprint ml">
   module Simple_list : LINEAR_CONTAINER = struct
     type &alpha; t = &alpha; list
     let empty () &rarr; []
     let add x l = x :: l
     let mem = List.mem
     let length = List.length
     let nth = List.nth
   end;;

   module Simple_array  : LINEAR_CONTAINER = struct
     type &alpha; t = &alpha; array
     let empty () = [||]
     let add x l =
       let a = Array.make l x in Array.append a l
     let mem x l = List.mem x (Array.to_list l)
     let length = Array.length
     let nth l x = l.(x)
   end;;
   </pre>
   By application of only the one functor <code>Lin_ext</code> is is
   then possible to obtain two distinct implementations that
   satisfy <code>LINEAR_CONTAINER_EXT</code>:
   <pre class="prettyprint ml">
   # module L_ext = Lin_ext (Simple_list);;
   # module A_ext = Lin_ext (Simple_array);;
   </pre>
   The extension of an instance <code>M</code>
   of <code>LINEAR_CONTAINER</code> does not therefore depend on the
   implementation of <code>M</code>. The extension is the result of
   application of the functor <code>Lin_ext</code>.
   <br/>
   <br/>
   <b>Specificity of the link defined by generic modular inheritance
   :</b> The link between two modules is not established by their two
   signatures, but between a signature and a functor. Application of
   an "inheritance functor" solely realizes the particular
   implementation inheritance between the two modules.
   <br/>
   <br/>
   </p>

   <h5>Generic modular adaption</h5>
   <p>
   One of the common forms of inheritance is that of adaption of
   modules by inclusion. This form or reutilisation may equally be
   rendered generic:
   <br/>
   <br/>
   <b>Definition : </b> Generic module adaption is a form of
   inheritance in which it is not necessary to extend or specialize.
   <br/>
   <br/>
   For example, let us discuss a datatype for "structured arithmetic"
   which needs to be adapted from the point of view of the naming of
   its elements and masking conventions. We can generalise this
   example to generic adaption. Recall first of all, the signature we
   had been using:
   <pre class="prettyprint ml">
   module type ARITH = sig
     type nb                            
     type extern_nb
     val make : extern_nb &rarr; nb
     val show : nb &rarr; extern_nb
     val zero : nb
     val one : nb
     val add : nb &rarr; nb &rarr; nb
     val sub : nb &rarr; nb &rarr; nb
     val mul : nb &rarr; nb &rarr; nb
     val div : nb &rarr; nb &rarr; nb
   end;;
   </pre>
   This is very similar to a signature that could be used for the
   datatypes <code>Int32</code> and <code>Int64</code> of the OCaml
   standard library. For example:
   <pre class="prettyprint ml">
   module type ARITH_STRING = sig
     type t
     val of_string : string &rarr; t
     val to_string : t &rarr; string
     val zero : t
     val one : t
     val add : t &rarr; t &rarr; t
     val sub : t &rarr; t &rarr; t
     val mul : t &rarr; t &rarr; t
     val div : t &rarr; t &rarr; t
   end;;
   </pre>
   An "adaption functor" from one to the other can therefore be:
   <pre class="prettyprint ml">
   module Arith_adapater (A : ARITH_STRING) : ARITH 
     with type extern_nb = string = struct
     include A
     type nb = A.t
     type extern_nb = string
     let make = A.of_string
     let show = A.to_string
   end;;
   </pre>
   We have generalized here the adaption of names and masking
   conventions of all modules that
   satisfy <code>ARITH_STRING</code>. Assuredly, this genre of
   manipulation is important for remedying those situations where
   signatures are incompatible for reasons benign. The reusing of
   modular components is in its favor.
   </p>

   <h5>Generic modular decoration</h5>
   <p>One particular case of generic adaption occurs sufficiently
   often to be distinguished from the others:
   <br/>
   <br/>
   <b>Definition : </b> Generic module adaption is a generic adaption
   which consists of plunging the elements of one module into another
   in order to add new traits of behavior without changing the
   signature.
   <br/>
   <br/>
   For example, such a "decoration" may systematically transform
   calculated values into rendered viewable graphics or generally
   enrich their appearance. A decoration may equally well permit rapid
   verification, saving to a memory device, validation of their
   associated exceptions or assertions and tests. Additionally, as the
   signature is held fixed it is possible to compose decorations and
   attain a superposition of their respective behaviors. Reconsider
   the example of a two-dimensional space with a distance:
   <pre class="prettyprint ml">
   module type METRIC_SPACE_2D = sig
     type point
     type make_point : float * float &rarr; point
     type dist : point &rarr; point &rarr; float
   end;;
   </pre>
   One might wish to obtain a trace of the calculations when using an
   instance of the signature. For example, here is a generic
   decoration which provides display of such information on the
   standard output device:
   <pre class="prettyprint ml">
   module Metric_print (M : METRIC_SPACE_2D) : METRIC_SPACE_2D = struct
     type point = M.point

    let make_point (x, y) =
      Printf.printf "POINT CREATION : (%g, %g)\n" (x, y) ;
      M.make_point (x, y)

    let dist x y =
      let d = M.dist x y in
      Printf.printf "COMPUTED DISTANCE : %g\n" d; d
   end;;
   </pre>
   All of the implementations of planes we have introduced are then
   transformable into impenitent chatter. For example:
   <pre class="prettyprint ml">
   # module Plane_print = Metric_print (Plane);;

   # let p1 = Plane_print.make (1., 1.);;
   POINT_CREATION : (1, 1)
   val p1 : Plane_print.point = &abstr;abstr&gt;

   # Plane_print.dist p1 p1;;
   COMPUTED_DISTANCE : 0
   - : float = 0.
   </pre>
   </p>

   <p>Here is another important example of generic decoration. Recall
   firstly that the means of specification in ML languages are limited
   since they can only describe algorithmic properies. The
   function <code>dist</code> of the signature above is far from
   specifying what is a function of distance in the mathematical
   sense. Reconsider the example of the
   module <code>Bugged_plane</code> which satisfies the
   signature <code>METRIC_SPACE_2D</code> with a
   function <code>dist</code> which is not a distance. It is possible
   to remedy the situation there and directly associate checks and
   link tests to the relevant properties. This can be done
   indpendently of any particular implementation. It is therefore
   natural to employ a generic program. Here is a generic decoration
   that checks the definition axioms of distance over all instances
   that satisfy <code>METRIC_SPACE_2D</code>:
   <pre class="prettyprint ml">
   module Metric_test (M : METRIC_SPACE_2D) : METRIC_SPACE_2D = struct
     type point = M.point

     let make_point = M.make_point

     let dist x y =
       let dxy = M.dist x y in
       if not (dxy >= 0.) then failwith "Negative distance";
       if not ((M.dist x x) = 0.)
       || not ((M.dist y y) = 0.) then failwith "Non zero distance";
       if dxy <> (M.dist y x) then failwith "Non commutative distance"
       let rand =
         M.make_point (Random.float 1., Random.float 1.) in
         if not ((M.dist x rand) < dxy +. (M.dist y rand)) then
           failwith "Non triangular distance"
         dxy
   end;
   </pre>
   The idea of this functor then is to enforce checks over the
   distance function on each calculation. Obviously, it is not a
   question here of formal verification or exhaustive of an
   implementation but to ensure at least a bit that it is well
   founded. So, for example:
   <pre class="prettyprint ml">
   # module M_test = Metric_test (Bugged_plane);;

   # let p1 = M_test.make_point (1., 1.);;
   val p1 : M_test.point = &lt;abstr&gt;

   # M_test.dist p1 p1;;
   Exception : Failure "Non zero distance"
   </pre>
   </p>
   <p>Conforming to the definition of decoration, the modules
   issuedfrom <code>Metric_test</code>
   satisfy <code>METRIC_SPACE_2D</code>. The modules are then
   substituable in all circumstances. Additionally, such a test
   functor may pre-exist any instance module
   of <code>METRIC_SPACE_2D</code> : it may then be made part of the
   specification. Finally, we remark that the two preceding functors
   may be chained to superimpose their respective decorations:
   <pre class="prettyprint ml">
   # module M_TP = Metric_print (Metric_test (Bugged_plane));;

   # let p1 = M_TP.make_point (1., 1.);;
   POINT_CREATION (1, 1)
   val p1 : M_TP.point = &lt;abstr;&gt;

   # M_TP.dist p1 p1;;
   Exception : Failure "Non zero distance"
   </pre>
   </p>

   <h5>Generic modular composities</h5>
   <p>
   There exists another characteristic case of generic adaptions,
   namely those that are related to generic decorations of data types:
   <br/>
   <br/>
   <b>Definition : </b> A generic composition is a generic adaption
   wich transforms a datatype <code>T</code> into a datatype on sets
   of instances.
   <br/>
   <br/>

   For example, consider a type for graphical elements of which here
   is one possible signature:
   <pre class="prettyprint ml">
   module type GRAPHIC_ELEM = sig
     type t
     type extern_t
     val make : extern_t &rarr; t
     val draw : t &rarr; unit
     val translate : int * int &rarr; t &rarr; t
   end;;
   </pre>
   The adaption functor following permits obtaining a type of lists of
   graphical elements from any implementation of a type of graphical
   element which satisfies <code>GRAPHIC_ELEMEM</code>:
   <pre class="prettyprint ml">
   module Picture (G : GRAPHIC_ELEM) : GRAPHIC_ELEM
     with type extern_t = G.t list = 
   struct
     type t = G.t list
     type extern_t = G.t list
     let make l = l
     let draw l = List.iter G.draw l
     let translate (t1, t2) l = List.map (G.translate (t1, t2)) l
   end;;
   </pre>
   Here is a simple instansiation of <code>GRAPHIC_ELEM</code>
   suitable for application of this functor:
   <pre class="prettyprint ml">
   module Disk2D (S : sig val radius : int end) : GRAPHIC_ELEM
     with type extern_t = int * int =
   struct
     module G = Graphics
     let radius = S.radius
     type t = {x : int; y : int}
     type extern_t = int * int
     let make (x, y) = {x = x; y = y}
     let draw p = G.fill_circle p.x p.y radius
     let translate (t1, t2) {x = x; y = y} = {x = x + t1; y = y + t2}
   end;;
   </pre>
   <pre class="prettyprint ml">
   # module Disk = Disk2D (struct let radius = 4 end) ;;
   # module Pic2D = Picture (Disk);;
   # let coord_list = [(50, 55); (60, 70); (57, 85); (60, 100);
                       (50, 115); (65, 135); (80, 130)];;
   # let casserole = Pic2D.make (List.map Disk.make coord_list);;
   val casserole : Pic2D.t = &lt;abstr;&gt;
   </pre>
   We can also create a type consisting of sets of sets and thus
   describe easily a graphical element of a more substantial
   complexity:
   <pre class="prettyprint ml">
   # module PPic2D = Picture (Pic2D);;

   # let supercasserole =
       PPic2D.make
       (List.map (fun c &rarr; Pic2D.translate c casserole)
                  List.map (fun (x, y) &rarr; (y * 3 - 150, x * 3 1 150))
                  coord_list));;
   val supercasserole : Pic2D.t = &lt;abstr&gt;

   # PPic2D.draw supercasserole;;
   </pre>
   We reused here the list of coordinates <code>coord_list</code>
   above as a set of translations of the graphical elements.
   </p>
   <p>We note that the modular framework in OCaml limits the
   possibilities of generic composites since the different types
   obtained are not directly compatible with each other: it is not
   because two types of data are derived from modules of the same
   signature that these types are compatible. We will talk again about
   this important point.
   </p>

   <h5>Types of generic data</h5>
   <p>
   Relationships between modules defined by inclusion are also well
   suited to generalisation by interposing by functor. For example,
   module aggregation and module association between types of data may
   be rendered generic. That idea motivates the following definition:
   <br/>
   <br/>
   <b>Definition : </b> A generic module data type is one such that
   the representation of its values is generalized by functor.
   <br/>
   <br/>
   Conforming to the idea of generiticity, only the application of a
   generic data type will make it possible to produce a particular
   data type. Reconsider the example of graphical environments
   according to the "data-driven" programming technique:
   <pre class="prettyprint ml">
   module type GRAPHIC_ENVIRONMENT = sig
     module T : ASSOC_TABLE
     type action = int &rarr; int &rarr; int
     type behaviors = (char, action) T.assoc
     val empty : unit &rarr; behaviors
     ...
   end;;

   module G_env : GRAPHIC_ENVIRONMENT = struct
     module T = Assoc_rb_tree
     type action = int &rarr; int &rarr; int
     type behaviors = (char, action) T.assoc
     let empty () = T.empty ()
     ...
   end;;
   </pre>
   The type may be rendered generic by replacing the explicit link
   of <code>T</code> with the parameter of a functor:
   <pre class="prettyprint ml">
   module G_env (Assoc : ASSOC_TABLE) = struct
     module T = Assoc
     type action = int &rarr; int &rarr; int
     type behaviors = (char, action) T.assoc
     let empty () = T.empty ()
     ...
   end;;
   </pre>
   The functor permits then construction of modules adapted to each of
   implementation of association tables we have at our disposal, for
   example, one based on lists or, one based on red-black trees:
   <pre class="prettyprint ml">
   # module G_list = G_env (Assoc_list);;
   # module G_tree = G_env (Assoc_rb_tree);;
   </pre>
   </p>
   <p>More generally, if a signature of a data type is declared by
   inclusion, as in the case of the
   signature <code>GRAPHIC_ENVIRONMENT</code>, one may expect its
   implementations to take on the form of generic datatypes:
   <br/>
   <br/>
   <b>Abstract sub-modules and generiticity : </b> An abstract
   sub-module in a signature is generally translated into a functor
   parameter.
   <br/>
   <br/>
   </p>

   <h4>Functors and the control of the generiticity of signatures</h4>

   <h5>Signatures and universal type parameters</h5>

   <p>Universal parameters and abstract types may be seen as two
   distinct species of parameters for signatures. They are nonetheless
   very different. Indeed, if universal parameters benefit from an
   automation of their instantiation, they impose on the other hand
   the implementation itself being generic.
   </p>
   <p>Consider for example the specification of general containers
   which utilise a universal parameter <code>&alpha;</code> for
   describing the type of elements they contain:
   <pre class="prettyprint ml">
   module type UNIV_CONTAINER = sig
     type &alpha; t
     type empty : unit &rarr; &alpha; t
     val add : &alpha; &rarr; &alpha; t &rarr; &alpha; t
   end;;
   </pre>
   This signature imposes on the modules that instantiate it as
   consisting of generic functions and valid for any type. The
   implementation of these functions may mot make use of particular
   properties of these types. In other words, implemementation can
   only be established on "functions of structure". The elements of a
   container satisfying <code>UNIV_CONTAINER</code> are not thus <i>a
   priori</i> comparable, measurable, etc. They can only be in a way
   that will be ignored by an implementation
   of <code>UNIV_CONTAINER</code>. The universality of types
   associated with the parameter <code>&alpha;</code> imposes a
   neutrality on the implementations of <code>UNIV_CONTAINER</code>.
   </p>
   <p>
   Evidently, the predefined OCaml comparison predicates of OCaml
   given as <code>=</code>, <code>&lt;</code> or <code>&gt;</code>
   offer a default generiticity that might suggest the opposite. For
   example, here is a type of binary search trees which
   satisfy <code>UNIV_CONTAINER</code> which are ordered over their
   data:
   <pre class="prettyprint ml">
   module Tree : UNIV_CONTAINER = struct
     type &alpha; t = Bin_empty | Bin_node of &alpha; * &alpha; t * &alpha; t
     let empty () = Bin_empty
 
     let rec add x t = match t with
       | Bin_empty &rarr; Bin_node (x, Bin_empty, Bin_empty)
       | Bin_node (x, t1, t2) &rarr;
           if x = y then t else
           if x < y then Bin_node (y, add x t1, t2)
           else Bin_not (y, t1, add x t2)
   end;;
   </pre>
   However, this implementation is hampered by the generiticity of
   predefined comparison predicates. For example, this implementation
   does not permit the elements contained by <code>Tree</code> to be
   function values : not only can simple functions not be placed but
   more generally any representations that make use of functions such
   as frozen values. On the other hand, serious problems will arise
   when these values possess in them modifiable information such as
   due to "memoisation". The evolution of their internal
   representation will in fact lead to a complete incoherence of the
   search trees.
   </p>

   <h5>Signatures and abstract types</h5>
   <p>The control of the generiticity of a signatures and its
   instances is established by the use of abstract types. For example,
   the signature <code>UNIV_CONTAINER</code> above may be transformed
   into the following signature:
   <pre class="prettyprint ml">
   module type CONTAINER = sig
     type elt
     type t
     val empty : unit &rarr; t
     val add : elt &rarr; t &rarr; t
   end;;
   </pre>
   Therefore, the implmentation no longer has a duty to be generic. It
   may make use of proerties of the type instantiated as the
   abstract <code>elt</code>. Moreover, this type can be specified and
   constrainted by means of abstract sub-modules integrated into the
   signature. For example, in the case that it is desired to specify
   that the elements of a container are ordered, here is how to get
   it:
   <pre class="prettyprint ml">
   module type ORDER = sig
     type t
     val less_or_equal : t &rarr; t &rarr; bool
   end;;

   module type ORDERED_CONTAINER = sig
     module O : ORDER
     type elt = 0.t
     type t
     val empty : unit &rarr; t
     val add : elt &rarr; t &rarr; t
   end;;
   </pre>
   We have thus indicated here a dependance of the
   type <code>elt</code> to the properties specified
   by <code>ORDER</code> : the generiticity expressed in this
   signature is precise and constrained. On the other hand, the
   relationship beween the containers and their elements is generally
   a modular association where the latter are neither created nor
   accessed. This typing constraint can therefore be satisfied with a
   signature of "module records" as <code>ORDER</code> and this,
   even in the framework of rigorous masking.
   </p>
   <p>That said, the counterpart of this technique is real : the
   instaniation of an abstract type (or abstract sub-module) must be
   made explicit at the time of implementation. Functors play an
   important role in facilitating this instantiation. For example:
   <pre class="prettyprint ml">
   module Ord_list (Ord : ORD) : ORDERED_CONTAINER
     with module O = Ord =
   struct
     module O = Ord
     type elt = O.t
     type t = elt list
     let empty () = []
     let add x l = ....
   end;;
   </pre>
   Such a functor permits instantiation of <code>elt</code> to be
   carried out without modification of existing code. The
   signature <code>ORDERED_CONTAINER</code> would indeed not be really
   acceptable without functors, since one can expect a frequent
   variation of the type of the elements of these containers. If we
   were left with the modular programming techniques we covered
   earlier, this replacement of universal parameters with abstract
   types whould have been rather disadvantageous : any new
   instantiation would have required an explicit operation on the
   code. In those examples we were delibrately using links between
   modules that were less susceptible to variations than in the case
   of containers.
   </p>
   <p>
   Thus, we can specify the difference between the type parameters
   within signatures:
   <br/>
   <br/>
   <b>Differences between type parameters in signatures (precise) : </b>
   <ul>
   <li><i>Universal type parameters</i> impose an implementation be
   generic. Their instantiation is performed automatically by the type
   system. Nevertheless, no property can be associated with them
   (except those related to predefined predicates).</li>
   <li><i>Abstract types</i> do not impose an implementation be
   generic. They lend themselves to the setting up of contstraints and
   control of generiticity. Nevertheless, their instantiation must be
   established explicitly, case by case, facilitation depends on the
   utilisation of functors.</li>
   </ul>
   <br/>
   <br/>
   </p>

   <h5>How to switch from one type of generiticity to another?</h5>

   <p>In light of the distinctions between universal and abstract
   types, one could easily admit the following criterion: we will use
   universal parameters to represent types without specific properties
   and abstract types for the others.
   </p>
   <p>However, things are not so simple as it is often necessary to
   consider all the signatures available, their compatibility and
   their future evolution. Take again the earlier example of
   containers:
   <pre class="prettyprint ml">
   module type UNIV_CONTAINER = sig
     type &alpha; t
     val empty : unit &rarr; &alpha; t
     val add : &alpha; &rarr; &alpha; t &rarr; &alpha; t
   end;;
   </pre>
   Let us reconsider the specialized ordered elements version:
   <pre class="prettyprint ml">
   module type ORDERED_CONTAINER = sig
     module O : ORDER
     type elt = O.t
     val empty : unit &rarr; t
     val add : elt &rarr; t &rarr; t
   end;;
   </pre>
   These two signatures are incompatible. From the point of view of
   software design, it would be desirable for an implementation
   of <code>ORDERED_CONTAINER</code> to be seen as an implementation
   of <code>UNIV_CONTAINER</code>. The differing power of generiticity
   here offers an irreducible resistance. For example, the following
   adaption will not be enough to reduce all the generiticity
   specified in <code>UNIV_CONTAINER</code>:
   <pre class="prettyprint ml">
   module type ORDERED_CONTAINER_INST = sig
     module T : ORDER
     module C : UNIV_CONTAINER
     include UNIV_CONTAINER with type &alpha; t = T.t C.t
   end;;
   </pre>
   Indeed, the declaration of the function <code>add</code>
   of <code>UNIV_CONTAINER</code> has the type <code>&alpha; &rarr;
   &alpha; t &rarr; &alpha; t</code>. This declaration remains generic
   here because it uses an isolated instance of <code>&alpha;</code>
   out of reach of an explicit instantiation (whose result is the
   type <code>&alpha; &rarr; T.t C.t &rarr; T.t C.t</code>). In fact,
   the specialization capable of generalizing the
   signature <code>ORDERED_CONTAINER</code> is rather the following:
   <pre class="prettyprint ml">
   module type CONTAINER = sig
     type elt
     type t
     val empty : unit &rarr; t
     val add : elt &rarr; t &rarr; t
   end;;
   </pre>
   The signature <code>ORDERED_CONTAINER</code> is this time obviously
   comptabile. It can be rewritten more directly as:
   <pre class="prettyprint ml">
   module type ORDERD_CONTAINER = sig
     module O : ORDER
     include CONTAINER with type elt = O.t
   end;;
   </pre>
   The signature <code>CONTAINER</code> here has a particularity that
   it is necessary to underline: it type <code>elt</code> is an
   abstract type without it being nevertheless associated with
   properties. Its instantiation can assuredely be established by a
   functor but it is then necessary to use the signature of a trivial
   data type, that is to say a signature that consists of an abstract
   type:
   <pre class="prettyprint ml">
   module type TYPE = sig type t end;;

   module C (T : TYPE) : CONTAINER = stuct
     type elt = T.t
     type t = elt list

     let empty () = []
     let add x l = x :: l
   end;;
   </pre>
    The idea of "trivial datatype" must be compared to that of
    "non-module parameters". This form of type definition corresponds
    to that which appears very naturally in any language offering a
    share of generic modular programming and which would have at its
    disposal only abstract types (that is, without universal type
    parameters). The consequences of the example can be dealt with as
    summarized below:
   <br/>
   <br/>
   <b>Distinct signature hierarchies : </b>the two kinds of type
   parameters induce distinct hierarchies of compatibility between
   signatures : those that utilize universal type parameters and those
   which utilise abstract types.
   <br/>
   <br/>
   Univeral parameters make it possibly to quickly obtain generic
   components which benefit from automatic instantiation of their
   types but they cannot be associated with properties nor transmitted
   and used to give properties to other types. Only hierarchies of
   signatures with abstract types offer real control of the types
   accuracy as to their reciprocal links.
   <br/>
   <br/>
   <b>The technique of explicit generic modular programming : </b>
   Only abstract types are used as parameters in signatures. Functors
   become the essential means of instantiations of type parameters.
   <br/>
   <br/>
   </p>
   <p>It should be noted that since the generiticity of universal
   parameters is more powerful than that of abstract types, it is
   sometimes possible to reuse the associated implementations. The
   instantiation of the types will remain explicit and one can realize
   this reuse by means of generic adaptions.
   </p>

   <h4>Functors and their separate compilation</h4>

   <p>Functors are modular components in the same was as the
   others. They integrate equally with the means of separate
   compilation. However, they do not lend themselves directly to
   structuring in compilation units. Let us recall that the general
   form of these units is the following:
   <pre class="prettyprint ml">
   module Name : sig (*contents of name.mli*) end
     = struct (*contents of name.ml*) end;;
   </pre>
   Units of compilation are then necessarily modules without
   parameters. As a consequence, separate compilation of functors is
   achieved by the technique of parent modules in the form of
   packages. For example, reconsider the type of sequential containers
   and transform it in such a way that it lends itself to separate
   compilation. Here first of all is the package specifying the
   content of the signatures (<code>linear_containers_spec.ml</code>):
   <pre class="prettyprint ml">
   module type LINEAR_CONTAINER = sig ... end;;
   module type LINEAR_CONTAINER_EXT = sig ... end;;
   </pre>
   Next, here is the implementation package
   (<code>linear_containers_impl.ml</code>):
   <pre class="prettyprint ml">
   open Linear_containers_spec

   module Simple_list : LINEAR_CONTAINER = struct ... end;;
   module Simple_array : LINEAR_CONTAINER = struct ... end;;
   </pre>
   The extending functor can be placed in another package
   (<code>linear_containers_ext_impl.ml</code>)
   <pre class="prettyprint ml">
   open Linear_containers_spec

   module Lin_ext (L : LINEAR_CONTAINER) : LINEAR_CONTAINER_EXT =
   struct
     include L
     let first l = L.nth l 0
     let last l = L.nth l ((L.length l) - 1)
   end;;
   </pre>
   A compilation of these units will be obtained with:
   <pre>
   $ ocamlc linear_containers_spec.ml linear_containers_impl.ml \
            linear_containers_ext.ml
   </pre>
   With this, in the top-level, the functor <code>Lin_ext</code> can
   be provided as will the modules <code>Simple_list</code>
   and <code>Simple_array</code>:
   <pre class="prettyprint ml">
   # #load "linear_containers_impl.cmo";;
   # #load "linear_containers_ext_impl.cmo";;

   # #open Linear_containers_impl;;
   # #open Linear_containers_ext_impl;;

   # module L_ext = Lin_ext (Simple_list);;
   # module A_ext = Lin_ext (Simple_array);;
   </pre>
   </p>
   <p>There is on the other hand a structuring of units associated
   with functors which makes them somewhat resemble the case of simple
   modules and thus to apply a modular program in the "C language"
   style:
   <ol>
   <li>The compilation unit is named for the name of the functor it
   contains.</li>
   <li>We place the necessary signatures for the functor.</li>
   <li>We put the functor there and we bind it to a neutral name
   like <code>F</code> or <code>Make</code></li>.
   </ol>
   The preceding example may then be adapted to use a file like this
   (<code>lin_ext.ml</code>):
   <pre class="prettyprint ml">
   module type LINEAR_CONTAINER = sig ... end;;
   module type LINEAR_CONTAINER_EXT = sig ... end;;

   module Make (L : LINEAR_CONTAINER) : LINEAR_CONTAINER_EXT = struct
     include L
     let first l = L.nth l 0
     let last l = L.nth l ((L.length l) - 1)
   end;;
   </pre>
   The functor now posses the name <code>Lin_ext.Make</code>. This
   structuring is close to the naming tactic "weakly algebraic" for
   data types. We try to reduce the distinction between the two
   modular levels contributed by giving a neutral name to the functor.
   </p>
   <p>This construction technique of compilation units is sometimes
   utilised in the OCaml standard library. Consider
   the <code>Set</code> module for example which defines a type for
   ordered sets of elements. The type is generic from the point of
   view of the ordering of the elements which is specified by a
   signature of a "module recording". The file <code>set.ml</code> in
   the standard library contains essentially the following two
   definitions:
   <pre class="prettyprint ml">
   module type ORDER = sig
     type t
     val compare : t &rarr; t &rarr; int
   end;;

   module Make (Ord : ORDER) = struct
     type elt = Ord.t
     ...
   end;;
   </pre>
   Thus, it is possible to instantiate this generic representation
   through a functor whose name is <code>Set.Make</code>:
   <pre class="prettyprint ml">
   # module Int_ord = struct
       type t = int
       let compare = Pervasives.compare
     end;;

   # module Int_set = Set.Make (Int_ord);;

   # let s1 = Int_set.add 100 (Int_set.empty);;
   val s1 : Int_set.t = &lt;abstr&gt;
   </pre>
   </p>
   <p>Within the OCaml standard library the
   modules <code>Hashtbl</code>, <code>Map</code>
   and <code>Weak</code> (hash tables with weak pointers) each
   implement datatypes that conform to this code
   structure. Nevertheless, as described herein, it induces
   duplications of signatures. It is possible to employ the idea of
   signature packages in order to remedy this.
   </p>

   <h4>N-ary functors</h4>

   <h5>Defining n-ary functors</h5>

   <p>Functors may have more than one parameter. It is thus possible
   to render a module generic from the point of view of multiple
   signatures. The base syntax of n-ary functors is an immediate
   extension of the unary functors:
   <pre class="prettyprint ml">
   module &lt;Name&gt; =
     functor (&lt;Paramter 1&gt; : &lt;SIGNATURE 1&gt;)  &rarr;
       ...
         functor (&lt;Paramter n&gt; : &lt;SIGNATURE n&gt;)  =
    struct
      ...
    end;;
   </pre>
   For example, reconsider the functor associated with matrices over
   integers of a certain size which we recall here with the important
   lines:
   <pre class="prettyprint ml">
   module Matrix (S : sig val int end) = struct
     type mat = int array array
     ...
       mat.(i).(j) &larr; m1.(i) + m2.(i).(j)
     ...
   end;;
   </pre>
   Despite a representation of the values based on the type parameter
   of <code>&alpha; array array</code>, the generiticity is not saved
   at the level of the type of matrices. The
   parameter <code>&alpha;</code> is in fact instantiated
   as <code>int</code> by the addition operatation "<code>+</code>"
   which is explicitly utilised in the implementation. Indeed, the
   generiticity of matrices can be established only through properties
   of their coefficients : the latter must constitute sets of
   structures with internal laws. In other words, the specification of
   a generic type of matrices must necessarily be precise. Here is
   such a specification:
   <pre class="prettyprint ml">
   module type OP = sig
     type t
     val op : t &rarr; t &rarr; t
   end;;

   module type MATRIX = sig
     module Coef : OP
     type &alpha; gen_mat
     type t = Coef.t gen_mat
     val op : t &rarr; t &rarr; t
   end;;
   </pre>
   One notices accordance with the idea that once can make
   matrices, <code>MATRIX</code> is compatible with <code>OP</code>:
   it is only a specialization. Here follows an implementation by
   means of a binary functor:
   <pre class="prettyprint ml">
   module Matrix (C : OP)
                 (S : sig val size : int end) =
   struct
     module Coef = C
     type &alpha; gen_mat = &alpha; array array
     type t = Coef.t gen_mat
     let op m1 m2 =
       let mat = Array.create_matrix S.size S.size m1.(0).(0) in
       for i = 0 to (S.size - 1) do
         for j = 0 to (S.size - 1) do
           mat.(i).(j) <- Coef.op.m1.(i).(j) m2.(i).(j)
         done
       done;
       mat
   end;;
   </pre>
   This new implementation of matrices thus proposes a complete
   generiticity.
   </p>

   <h5>Applying n-ary functors</h5>
   <p>The syntax for application of an n-ary functor is equally an
   extension for the unary case:
   <pre class="prettyprint ml">
   module &lt;Name&gt; = &lt;Functor&gt; (&lt;Argument 1&gt;) ... (&lt;Argument n&gt;);;
   </pre>
   The parentheses around each of the arguments in the n-ary functor
   call are required. The arguments cannot be separated by commas as
   for functions : there is no notion of tuple of modules. So, with
   the functor <code>Matrix</code> of the preceding example:
   <pre class="prettyprint ml">
   # module Simple_float = struct
       type t = float
       let op = ( + )
     end;;   

   # module Float_2x2 =
       Matrix (Simple_float) (struct let size = 2 end);;

   # module Simple_complex = struct
       type t = float * float
       let op (r1, i1) (r2, i2) = (r1 +. r2, i1 +. i2)
     end;;

  # module Complex_3x3 =
      Matrix (Simple_complex) (struct let size = 3 end);;
   </pre>
   We obtain here matrices of dimension $2$ of real coefficients and
   matrices of dimension $3$ of complex coefficients.
   </p>
   <p>
   The definition of an n-ary functor is be default under a curried
   form. This permits partial application. For example, the functors
   above may be specialized by partial applications:
   <pre class="prettyprint ml">
   # module Float_mat = Matrix (Simple_float);;
   functor (S : sig val size : int end) &rarr sig ... end

   # module Complex_mat = Matrix (Simple_complex);;
   functor (S : sig val size : int end) &rarr sig ... end
   </pre>
   This possibility of partial application illustrates a new
   relationship between functors and functions:
   <br/>
   <br/>
   <b>A property of functors : </b>The result of application of a
   functor may be a functor.
   <br/>
   <br/>
   </p>
   <p>Here is another example of an n-ary functor. Consider an
   optimisation process. The idea here is to construct a type for
   spaces in which it is possible to search for a minimum according to
   the following strategy : starting at a point $p_{0}$, observe the
   set of points a a fixed distance from $p_{0}$; calculate or
   approximate the minimum of values associated with this set of
   points; if this value is smaller than that for $p_{0}$, transport
   there and recommence; in the case where $p_{0}$ is the minium
   value, consider a local minima found. This search strategy is
   general and may be specified by the following signatures some of
   which have already been discussed:
   <pre class="prettyprint ml">
   module type METRIC_SPACE = sig
     type point
     val dist : point &rarr; point &rarr; float
     val ball : radius:float &rarr; point &rarr; point list
   end;;

   module type ORDER = sig
     type elt
     val compare : elt &rarr; elt &rarr; int
   end;;

   module type OPTIMISATION = sig
     module M : METRIC_SPACE
     module O : ORDER
     type valuation_t = M.point &rarr; O.elt
     val find_optimal : M.point &rarr; radius:float &rarr; valuation_t &rarr; M.point
   end;;
   </pre>
   The specification of the signature <code>OPTIMISATION</code> thus
   makes use of two structures : one describing the search space which
   must be provided with a distance (in order to define what is the
   neighbourhood of a point); the other describes the set of values of
   points of the space which must be ordered (in order to be able to
   determine the minimum of one of its sub-spaces). An implementation
   lends itself naturally to the form of a binary functor:
   <pre class="prettyprint ml">
   module Optimis (Metr : METRIC_SPACE)
                  (Ord : ORDER) 
   : OPTIMISATION
     with module M = Metr and module O = Ord =
   struct
     module M = Metr
     module O = Ord
     type valuation_t = M.point &rarr; O.elt

     let rec find_optimimum p ~radius f =
       let val_ball = List.map (fun x &rarr; (x, f x)) (M.ball radius p) in
       let sort_ball = List.sort (fun (_, y1) (_, y2) &rarr; O.compare y1 y2) val_ball in
       if O.compare (f p) (snd (List.hd sort_ball)) <= 0 then p
       else find_optimal (fst (List.hd sort_ball)) ~radius:radius f
   end;;
   </pre>
   The type constraints of the form <code>with module</code> indicate
   here is a double module association which can also be satisfied
   with "module records". Here a use is based over the space of
   integers with the usual distance, that is to say a discretized
   line:
   <pre class="prettyprint ml">
   module Discrete_line = struct
     type point = int
     let dist x y = float (abs (x - y))
     let ball ~radius p =
       let rec aux r p i =
         if i &lt;= r then p - i :: p + i :: (aux r p (i + 1))
         else [] in
       aux (int_of_float radius) p 1
   end;;
   </pre>
   This discretized line will be such that each point will carry a
   floating point number: 
   <pre class="prettyprint ml">
   module Order_float = struct
     type elt = float
     let compare = Pervasives.compare
   end;;
   </pre>
   Thenceforth, the search for a minimum over a function of that line
   in floats may be obtained by partial application of the
   functor <code>Optimis</code>:
   <pre class="prettyprint ml">
   # module Grad_line = Optimis (Discrete_line) (Order_float);;
   </pre>
   Here is a test over the function $f(x) = (x -50)^{2}$ with a
   neighbourhood of radius $2$ and a starting point of $0$:
   <pre class="prettyprint ml">
   # Grad_line.find_optimal 0 ~radius:2 (fun x &rarr; (float x -. 50.) ** 2.;;
   - Grad_line.M.point = 50
   </pre>
   So, the generiticy of the implementation makes it possible to
   search for minima in a variety of spaces. It is sufficient to have
   at its disposal instances of <code>METRIC_SPACE</code>
   and <code>ORDER</code> to apply the
   functor <code>Optimis</code>. Let us add that there are techniques
   for the generalization of algorithms that can be applied here in
   order to make the implementation of <code>Optimis</code> even more
   flexible, for example from the point of view of the search for a
   minimum in a neighborhood.
   </p>

   <h5>A more complete example : generic graphs</h5>
   <p>Directected graphs, labeled such that vertices can be reachable
   by keys can be made generic over their constiuants. Here first of
   all is a specification (with the number of functions deliberately
   constrained for the objective of an example illustrates type
   constructions):
   <pre class="prettyprint ml">
   module type EQUAL = sig
     type t
     val eq : t &rarr; t &rarr; bool
   end;;

   module type GRAPH = sig
     module Key : EQUAL
     module Label : EQUAL
     type vertex_data
     type vertex_key = Key.t
     type label = Label.t
     type graph
     type extern_graph
     val make : extern_graph &rarr; graph
     val show : graph &rarr; (vertex_key * vertex_data) list
     val assoc : vertex_key &rarr; graph &rarr; vertex_data
     val nexts : vertex_key &rarr; graph &rarr; (vertex_key * label) list
     val update : vertex_key &rarr; vertex_data &rarr; graph &rarr; unit
   end;;
   </pre>
   Observe that we have specified keys and lables as types with an
   equality function. On the other hand, the type of vertex data is
   not assumed to possess any particular properties. It is an an
   abstract type : the technique of "explicit generic modular
   programming". On the other hand, the specification
   of <code>update</code> announces an imperative implementation by
   way of its return type which is <code>unit</code>.
   </p>
   <p>Here is a functor that constructs modules the satisfy the
   signature <code>GRAPH</code>. It is based on adjaceny list
   representations of graphs. The type <code>extern_graph</code>
   corresponds to an adjacency list and the internal
   representation <code>graph</code> is composed of that adjacency
   list and a list of vertices (the second list permits simplifying
   the implementation of certain operations):
   <pre class="prettyprint ml">
   module type TYPE = sig type t end

   module Graph (T : TYPE) (Key : EQUAL) (Label : LABEL) : GRAPH
     with module Key = Key and module Label = Label
     with type vertex_data = T.t
     with type extern_graph = ((Key.t * T.t) * ((Key.t * Label.t) list)) list =
   struct
     module Key = Key
     module Label = Label
     type vertex_data = T.t
     type vertex_key = Key.t
     type label = Label.t
     type vertex = vertex_key * (T.t ref) (*imperative character*)
     type adjacency = vertex_key * (vertex_key * label) list
     type graph = Graph of adjency list * vertex list

     let rec assoc_gen eq f l x = (*generic association*)
      match l with
        | [] &rarr; raise Not_found
        | (a, b) :: l &rarr; if eq a x then f a b else assoc_gen eq f l x

     let assoc v_key (Graph (_, vertex_list)) =
       !(assoc_gen Key.eq (fun a b &rarr; b) vertex_list v_key)

     let make full_adjlist = (*simple formatting of the argument*)
       let adjlist =
         List.map (fun ((x, _), z) &rarr; x, z) full_adjlist in
       let vertex_list =
         List.map (fun ((x, y), _) &rarr; x, ref y)) full_adjlist in
      Graph (adj_list, vertex_list)

     let show (Graph (_, vertex_list)) =
       List.map (fun (x, y) &rarr; (x, !y)) vertex_list

     let update v_key v_data (Graph (_, vertex_list) as g) =
       assoc_gen Key.eq (fun a b &rarr; b := v_data) vertex_list v_key

     let next v_key (Graph (adjlist, _)) =
       try assoc_gen Key.eq (fun a b &rarr; b) adjlist v_key
       with Not_found &rarr; []

   end;;
   </pre>
   And here is an example of application of the functor which consists
   of contructing a graph where the keys are integers, the data are
   strings and the edges are distances in kilometers:
   <pre class="prettyprint ml">
   # module Eq_str = struct type t = string end;;
   # module Eq_int = struct type t = int let eq = ( = ) end;;
   # type kilometer  = Km of float;;
   # module Kilometer = struct type t = kilometer let eq = ( = ) end;;
   # module Geo = Graph (Eq_str) (Eq_int) (Kilometer);;
   </pre>
   Here is a graph of cities labeled with distances and represented as
   an instance of a graph derived from <code>Geo</code>:
   <pre class="prettyprint ml">
   # let g1 = Geo.make
     [ (1, "Hay River"),       [2, Km 120.; 3, Km 225.; 4, Km 275.];
       (2, "Fort Resolution"), [1, Km 120.];
       (3, "Fort Smith"),      [1, Km 225.; 4, Km 300.; 5, Km 175.];
       (4, "Fort Vermillon"),  [1, Km 275.; 3, Km 300.;
                                5, Km 275.; 6, Km 250.];
       (5, "Fort Chiewyan"),   [3, Km 175.; 4, Km 275.];
       (6, "Peace River"),     [4, Km 250.;]];;
   val g1 : Geo.graph = &lt;abstr&gt;
   </pre>
   <div align="center"><img src="img/north-east-canada.png"/></div>
   </p>
   <p>We have thus realized here a data structure in the framework of
   complete and controlled genericity. In addition there is an OCaml
   libries of modules, <code>OCAMLGRAPH</code> which implements graphs
   and their associated algorithms fully using generic modular
   programming.
   </p>

   <h5>Constraints over the parameters of functors</h5>
   <p>The body of a functor sometimes induces more constraints on
   types than the signatures of its parameters suggest. For example,
   consider the following functor:
   <pre class="prettyprint ml">
   module type OP = sig
     type t
     val op : t &rarr; t &rarr; t
   end;;

   module Pair (M : OP) = struct
     let make_pair x = (x, M.op x (x +. 1.))
   end;;
   </pre>
   This functor is misleading : it effectively announces itself as
   applicable to a module <code>M</code> that
   satisfies <code>OP</code>. However, in the implementation, the
   operation <code>M.op</code> is applicable only to floating
   numbers. In other words, the functor is unable to produce good
   modules over types <code>M.t</code> that are legal for anything
   other than floats. If the form above were accepted, type errors
   could be detected at the time of application of the functor, that
   is to say, too late. Recall that a functor is compiled and the
   result must be ensured not to generate type errors (this property
   represents an essential difference from C++).
   </p>
   <p>The remedy to this situation is to add a type constraint to the
   parameter of the functor in its signature:
   <pre class="prettyprint ml">
   module Pair (M : OP with type t = float) = struct
     let make_pair x = (x, M.op x (x +. 1.))
   end;;
   </pre>
   Here is an example use of <code>Pair</code> embedded in another
   functor:
   <pre class="prettyprint ml">
   # module Simple_float = struct
       type t = float
       let op = ( +. )
     end;;

   # module F1 (N : sig end) = struct
       module M = Pair (Simple_float)
     end;;
   module F1 : functor (N : sig end) &rarr; ...
   </pre>
   Type inference here can ensure the validity of the
   functor <code>F1</code> even if the functor <code>Pair</code> is
   not applied. This will be done when it is confirmed
   that <code>F1</code> conforms to the rules of the definition of a
   functor. To illustrate the fact:
   <pre class="prettyprint ml">
   # module Simple_int = struct
       type t = int
       type op = ( + )
     end;;

   # module F2 (N : sig end) = struct
       module M = Pair (Simple_int)
     end;;
   => TYPE ERROR
   </pre>
   Type inference is here capable of statically detecting the
   incoherence of the <code>Pair</code> call on an argument based on
   the type <code>int</code>. Situations similar to the preceding one
   occur when an explicit typing on a functor result is more
   constrained than it should be:
   <pre class="prettyprint ml">
   module type FLOAT_PAIR = sig
     val make_pair : float &rarr; float * float
   end;;

   module PAIR (M : OP) : FLOAT_PAIR = struct
     let make_pair x = (x, M.op x x)
   end;;
   </pre>
   The functor is incorrect in a new way. Indeed, the operation
   transmitted through <code>M.op</code> must be applied over floating
   point numbers by virtue of explicit typing
   by <code>FLOAT_PAIR</code>. The remedy is thus the same as before:
   <pre class="prettyprint ml">
   module Pair (M : OP with type t = float) : FLOAT_PAIR = struct
     let make_pair x = (x, M.op x x)
   end;;
   </pre>
   <br/>
   <br/>
   <b>Type constraints over a functor : </b> Consider $S_{F}$ the set
   of signatures associated with the parameters of a functor
   $F$. Then, any use or typing in $F$ more specific than what is
   described in $S_{F}$ will have to be reflected by type constraints
   associated with $S_{F}$.
   <br/>
   <br/>
   </p>
    <p>This use of type constraints may seem tedious. It nevertheless
    finds its place within the usual framework of static verification
    of the type links between modular components. Signatures are
    adapted to the needs of the good typing of a program. Let us give
    examples more formal than the one above and let us first take the
    case of complex numbers with a generalization on the external
    type:
   <pre class="prettyprint ml">
   module type COMPLEX = sig
     type complex
     type extern_complex
     val make : extern_complex &rarr; complex
     val show : complex &rarr; extern_complex
     ...
   end;;
   </pre>
   Generic inheritance will then require a type constraint on its
   parameter since it applies exclusively to pairs of floating point
   numbers:
   <pre class="prettyprint ml">
   module F (C : COMPLEX with type extern_complex = float * float) = struct
     include C
     let mul z w =
       let (r1, i1) = show z and (r2, i2) = show w in
       make (r1 *. r2 0. i1 * i2, i1 *. r2 +. i2 *. r1)
   end;;
   </pre>
   Consider also the transformation to a functor of the example of
   "apple men". The implementation proposed made explicit use of a
   constructor type of complex numbers of the form <code>float *
   float</code>. It is thus a type more specific than announced by the
   signature <code>COMPLEX_FUN</code>. Consequently, the complete
   header of this functor requires that this signature must be
   constrained:
   <pre class="prettyprint ml">
   module Appel_F
     (CFuns : COMPLEX_FUN with type C.extern_complex = float * float)
     (Set : SET)
   : APPLE_MEN
      with module CF = CFuns
      and type set_elements = (int * int) = 
   struct
     ...
   end;;
   </pre>
   This functor thus describes a generic version of the construction
   of "apple men" able to integrate an implementation of complex
   numbers (with an external representation <code>extern_comple</code>
   equal to <code>float * float</code>), an implementation of
   functions on these complex numbers and, an implementation of a type
   associated with the notion of a set. This example shows that the
   functor header can become very rich in type related
   information. Nevertheless, the rules to be applied are summarized
   in two points:
   <br/>
   <br/>

   <b>Construction of functor headers :</b>
   <ol>
   <li><i>Adaptions : </i> Each signature of a parameter of a functor
   $F$ must be adapted according to the type constraints issued by the
   implementation of $F$.</li>
   <li><i>Individual masking : </i>The explicit ytpe of a functor
   result follows the same rules of visibility control as of those for
   a simple module.</li>
   </ol>
   <br/>
   <br/>

   <br/>
   <br/>

   <b>The general form of a functor header : </b> The adatpion of
   signatures and the techniques of rigorous masking induce on functor
   headers the following general form:
   <pre class="prettyprint ml">
   module Name
     (P1 : SIGNATURE1 with type ...)
     ...
     (Pn : SIGNATUREn with type ...)
   : SIGNATURE_RESULT
       with type ... =
   struct
     ...
   end;;
   </pre>
   <br/>
   <br/>
   </p>

   <h5>Type sharing between functor parameters</h5>
   <p>Since n-ary functors are defined from by the nesting of unary
   functors their respective environments are also nested. So, type
   constraints on the signature of a parameter may use the types of
   parameter signatures that precede it. For example:
   <pre class="prettyprint ml">
   module type OP = sig
     type t
     val op : t &rarr; t &rarr; t
   end;;

   module Mixed_pair (M1 : OP) (M2 : OP with type t = M1.t) =
   struct
     let make_pair x = (M1.op x x, M2.op x x)
   end;;
   </pre>
   The second parameter of the functor is constrained by means of a
   type which comes from the first parameter. It is a new case of
   "type sharing" which this time over the parameters of
   functors. Observe first of all in this example the type constraint
   is not essential; it provides only a precise specification. There
   are however situations where explicit sharing of types is required
   for the system to type correctly. As in the case of the preceding
   section, the implementation of a functor may make use of
   compositions of types which impose constraints on the
   parameters. For example, consider the following functor:
   <pre class="prettyprint ml">
   module Compos (M1 : OP) (M2 : OP) =
   struct
     let f x = M1.op (M2.op x x) (M2.op x x)
   end;;
   </pre>
   The functor is incorrect when the function <code>f</code> applies a
   composition between the elements of <code>M1</code> and
   of <code>M2</code>. Their respective types <code>t</code> must be
   equivalent under penalty of error. In other words, this
   implementation of <code>Compos</code> possesses specifics which are
   not reflected in the signatures of the parameters. An exact version
   is thus the following:
   <pre class="prettyprint ml">
   module Compos (M1 : OP) (M2 : OP with type t = M1.t) =
   struct
     let f x = M1.op (M2.op x x) (M2.op x x)
   end;;
   </pre>
   So,
   <pre class="prettyprint ml">
   # module Simple_float = struct
       let t = float
       let op = ( +. )
     end;;

   # module M = Compos (Simple_float) (Simple_float);;

   # M.f 1.;
   = : Simple_float.t = 4.
   </pre>
   </p>
   <p>Here is a less formal example concerning the implementation of a
   set type whose elements are quantifiable according to thickness,
   depth, age etc. then associated with an order such that this
   quantification can be refined to become itself an order. For
   example, one may consider books ordered according to their
   publication date and when that date is equal ordered then
   alphabetically on their title. We can also consider horses ordered
   according to the speed of their gallop and then according to the
   brilliance of their coats. Here is one possible generic
   implementation:
   <pre class="prettyprint ml">
   module type VALUED = sig
     type elt
     type eval : elt &rarr; int
   end;;

   module type ORDER = sig
     type t
     val less_or_equal : t &rarr; t &rarr; bool
   end;;

   module Val_ordered (Val : VALUED)
                      (Ord : ORDER with type t = Val.elt) =
   struct
     type t = Val.elt
     let less_or_equal x1 x2 =
       let e1 = Val.eval x1 and e2 = Val.eval x2 in
       if e1 = e2 then Ord.less_or_equal x1 x2
       else e1 &lt; e2
   end;;
   </pre>
   The explicit indication of the sharing of types in the functor
   header is here obligated because the
   function <code>less_or_equal</code> uses the
   functions <code>Val.eval</code> and <code>Ord.less_or_equal</code>
   on the same parameters <code>x1</code> and <code>x2</code>. Other
   than books and horses, the most classic example applies to words in
   an order called "shortlex" : $x \le y$ if $x$ is a shorter word
   than $y$ and in the case where their lengths are equal, if $x$ is
   ordered before $y$ lexicographically. One may then express this
   order by a simple application of the
   functor <code>Val_ordered</code>:
   <pre class="prettyprint ml">
   # module Length_str = struct
       type elt = string
       let eval = String.length
     end;;

   # module Order_str = struct
       type t = string
       let less_or_equal = ( &lt;= )
     end;;

   # module Short_lex = Val_ordered (Length_str) (Order_str);;

   # Short_lex.less_or_equal "ding" "dong";;
   - : bool = true

   # Short_lex.less_or_equal "diiing" "dong";
   - : bool = false
   </pre>
   </p>

   <h5>A difficulty : shared types and masking</h5>
   <p>The functors of the preceding examples make use of parameters in
   the form of "module records". Their types were therefore not meant
   to be masked. We could therefore think of transforming them to
   integrate rigorous masking. The situation is however more delicate
   here since type sharing can only be concretely established between
   types considered equivalent by the system.
   </p>
   <p>Remember that a masked type is definitely distinguished and
   named through the module that contains it. This type is
   incompatbile with all other types except itself. There is thus an
   obvious difficulty in the direct composition of two abstract types:
   their representation of values being masked, the type system would
   not be able to <i>a priori</i> verify and validate. For example,
   reconsider the <code>Compos</code> functor applied to modules with
   masked implementations:
   <pre class="prettyprint ml">
   # module Compos (M1 : OP) (M2 : OP with type t = M1.t)  =
     struct
       let f x = M1.op (M2.op x x) (M2.op x x)
     end;;

   # module Simple_float1 : OP = struct
       type t = float
       let op = ( +. )
     end;;

   # module Simple_float2 : OP = struct
       type t = float
       let op = ( *. )
     end;;

   # module M = Compos (Simple_float1) (Simple_float2);;
   TYPE ERROR
   </pre>
   Although the respective abstract types <code>t</code> of the two
   modules passed in as arguments appear equal, masking renders them
   incomporable : <code>Simple_float1.t</code> is not equivalent
   to <code>Simple_float2.t</code>.
   </p>
   <p>The direct composition of representations of values of abstract
   types is thus generally impossible. This property could appear as a
   truism. Yet, in order to grasp it properly it is necessary to
   distinguish which is the order of the type abstractions and what is
   the order of masking : the functor <code>Compos</code> preceding
   usess <i>abstraction</i> over the types of the parameters, that is
   to say <code>M1.t</code> and <code>M2.t</code>. By the type
   constraint "<code>OP with type t = M1.t</code>" it is required that
   these be equivalents bu masking of the types
   of <code>Simple_float1</code> and <code>Simple_float2</code> make
   them different.
   </p>
   <p>There exists however sometimes a case where an equality maa be
   established over masked types. For example, the
   functor <code>Compos</code> applied with success if the parameters
   are instances of the same argument:
   <pre class="prettyprint ml">
   # module M = Compos (Simple_float1) (Simple_float1);;
   module M : sig val f : Simple_float1.t &rarr; Simple_float2.t end
   </pre>
   This equality between masked types is also possible when they come
   from the same chain of application of functors. For example:
   <pre class="prettprint ml">
   # module F (M : OP) : OP = struct
       type t = M.t
       type op x y = M.op (M.op x y) (M.op x y)
     end;;

   # module M = Compos (F (Simple_float1)) (F (Simple_float1));;
   module M : sig val f : F (Simple_float1).t &rarr; F (Simple_float1).t end
   </pre>
   In fact, it will be observed here that in the full name of the
   type <code>t</code>, the name of the applied functor makes an
   appearance; this is what makes it comparable to other occurences of
   the same name. In this capacity, it is said that functors in OCaml
   are applicative. The functionality simplifies the transmission of
   types for functor interposition but it also permis abstract data
   types to maintain relationships through their masked
   representations. These distinguished relations sometimes prevent
   full application of the "principle of substitutivity" and
   particularly when imperative programming intervenes within the
   modular components. There does not seem to be a perfect solution to
   this ambivalence due to the existence of generic abstract types end
   thir possibility of integrating imperative traits. The mix of
   styles could have reached a point where their respective
   characteristics are no longer wholly compatible.
   </p>

   <h5>The technique of "type nuserys"</h5>
   <p>The preceding section has show that it is rather rare to be able
   to compose abstract data types under good conditions. That said,
   "module records" are a construction available in the langauage and
   functors apply to them very well. One may thus imagine situations
   where at the outset of the first phase of building a program we
   would only manipulate data types without masking (for example, in
   the body of the same package). In this situation, the types may be
   considered as "basic seeds" permittin the construction of data
   types additionally elaborated through the application of
   composition functors, combinations, transformations etc. The types
   thus formed will then be able to benefit from masking <i>a
   posteriori</i> and then become abstract data types in their own
   right.
   </p>
   <p>Their exist a particular generic combinations of datatypes which
   are conceived only for types without masking. The most important is
   that of a union of properties of the two datatypes. Here is an
   illustration in the form of a functor which generates datatypes
   which present at the same time the properties of order and quantity
   over integers:
   <pre class="prettyprint ml">
   module type VALUED = sig
     type elt
     val eval : elt &rarr; int
   end;;

   module type ORDER = sig
     type t
     val less_or_equal : t &rarr; t &rarr; bool
   end;;

   module Val_and_order (Val : VALUED)
                        (Ord : ORDER with type t = Val.elt) =
   struct
     include Ord
     include Val
   end;;
   </pre>
   Note that the indication of type sharing is not required here
   because the two inclusions are independent (there are no
   compositions between the types); it is however from the point of
   view of what one wishes to express, that is to say, a sole datatype
   integrating thhe two properties at one time. For example:
   <pre class="prettyprint ml">
   # module Length_str = struct
       type elt = string
       let eval = String.length
     end;;

   # module Order_str = struct
       type t = string
       let less_or_equal = ( &lt;= )
     end;;

   # module OL_str = Val_and_order (Length_str) (Order_str);;

   # OL_str.less_or_equal "cycliophore" "gatrotriche";;
   - : bool = true

   # OL_str.eval "plathelminthe";;
   - : int = 13
   </pre>
   The union of the two types is realized and the representation of
   values of the result is public. We remain within the framework of
   the "nursery". Masking can be applied <i>a posteriori</i> using the
   following signatures:
   <pre class="prettyprint ml">
   module type ORDERED_VALUED = sig
     include ORDER
     include VALUED with type elt = t
   end;;

   module type ORDER_VALUED_MASK = sig
     include ORDERED_VALUED
     type extern_t
     val make : extern_t &rarr; t
     val show : t &rarr; extern_t
   end;;
   </pre>
   Let us add two remarks about this combination of types technique:
   <ul>
   <li><i>Possible type name conflicts.</i> Inclusion of multiple
   signatures and the preceding functors are only possible because the
   abstract types of <code>VALUED</code> and <code>ORDERED</code> are
   named differently. In the case name conflicts could occur, there
   will therefore be functors of adaption. It is a consequence of the
   "weakly algebraic" naming tactic.</li>
   <li><i>Effects of the limitation of the construction <code>with
   type.</code></i>In the preceding example, we used the predefined
   type <code>string</code>. This type then directly lends itself to
   the constraint <code>VALUED with type elt = Ord.t</code>. In
   contrast, in the case of record or sum types, it would be necessary
   to define them outside the modules. For example:
   <pre class="prettyprint ml">
   # type hash_set = Set of (char, unit) Hashtbl.t

   # module Order_set = struct
       type t = hash_set
       let less_or_equal = ( &lt;= )
     end;;

   # module Size_set = struct
       type elt = hash_set
       let eval (Set s) = Hashtbl.length s
     end;;

   # module OS_set = Order_val (Order_set) (Size_set);;
   </pre>
   </li>
   </ul>
   </p>

   <h4>Functor signatures</h4>

   <h5>Types for functors</h5>
   <p>The parameters of a functor have to explicit types by signatures
   and on the other hand the result of a functior may equally be typed
   by a signature. The linking of these signatures forms a functor
   type (on speaks here of the <i>signature of functors</i> by a
   somewhat abusive but convenient extension).The case is evidently
   closer to that of types of functions. A fact that until now has
   passed in silence, type inference produces functor types. For
   example:
   <pre class="prettyprint ml">
   # module type OP = sig
       type t
       val op : t &rarr; t &rarr; t
     end;;

   # module type PAIR = sig
       type t
       val make_pair : t &rarr; t * t
     end;;

   # module Pair (M : OP) : PAIR = struct
       let t = M.t
       let make_pair x = (x, M.op x x)
     end;;
   module Pair : functor (M : OP) &rarr; PAIR
   </pre>
   We see thus the usual form of a functional type based on the
   operator "<code>&rarr;</code>", and this in the modular
   framework. The definition of new signatures of functors is
   established in a natural syntax as follows:
   <pre class="prettyprint ml">
   module type &lt; Name of signatures &gt; =
     functor (&lt; Parameter &gt; : &lt; SIGNATURE &gt;) &rarr; &lt; SIGNATURE RESULT &gt;
   </pre>
   Such a functor signature thus describesa "functional type between
   two signatures". For example:
   <pre class="prettyprint ml">
   # module type PAIR_FUNCTOR =
       functor (M : OP) &rarr; PAIR;;
   </pre>
   </p>
   <p>The global explicit typing of a functor is also
   possible. However, to avoid a conflict with explicit typing of the
   result of a functor, it is necessary to return to its
   non-abbreviated notation, namely:
   <pre class="prettyprint ml">
   # module Pair : PAIR_FUNCTOR =
      functor (M : OP) &rarr; struct
        type t = M.t
        let make_pair x = (x, M.op x x)
      end;;
   module Pair : PAIR_FUNCTOR
   </pre>
   We type here the name of the functor and associate it with a
   "functor value". As usual, explicit typing induces a masking iof
   the elements contained in the body of the functor:
   <br/>
   <br/>
   <b>Rule (3) of the visibility of a functor result : </b> When a
   valid explicit typing of a functor $F$ by a signature $S1
   \rightarrow S2$, the masking applied is similar to the explicit
   typing of its result by $S2$.
   <br/>
   <br/>
   It is not thus far possible in OCaml to add a type constraint
   by <code>with</code> to a signature for functors. Type constrains
   must be part of the definition of the signature. For example, we
   may specify a systematic sharing between the types of the argument
   and the result of the functor:
   <pre class="prettyprint ml">
   # module type PAIR_FUNCTOR =
       functor (M : OP) &rarr; (PAIR with type t = M.t)
   </pre>
   </p>
   <p>As for simple signatures, explict typing for functor signatures
   is dependent on their compatibility.
   <br/>   
   <br/>   
   <b>Compatibility between signatures of functors : </b> The
   signature <code>SF : S1 &rarr; S2</code> is <i>compatible</i> with the
   signature <code>SF' : S1' &rarr; S2'</code> if <code>S1</code> is
   compatible with <code>S1'</code> and <code>S2</code> is compatible
   with <code>S2'</code>. In this case, if the functor <code>F</code>
   is an instance of <code>SF</code>, it is equally an instance
   of <code>SF'</code>.
   <br/>   
   <br/>   
   We illustrate this rule by the aid of a formal set of signatures:
   <pre class="prettyprint ml">
   module type S_SMALL = sig end;;
   module type S       = sig val x1 : int end;;
   module type S_LARGE = sig val x1 : int val x2 : int end;;
   module type SF1 = functor (M1 : S) &rarr; S;;
   module type SF2 = functor (M1 : S) &rarr; S_SMALL;;
   module type SF3 = functor (M1 : S) &rarr; S_LARGE;;
   module type SF4 = functor (M1 : S_SMALL) &rarr; S;;
   module type SF5 = functor (M1 : S_LARGE) &rarr; S;;
   </pre>
   Here, <code>S_LARGE</code> is evidently comptabile
   with <code>S</code> which is compatible
   with <code>S_SMALL</code>. But what about the signatures of
   functors? Consider the following functor which is assuredly an
   instance of the signature <code>SF1</code>:
   <pre class="prettyprint ml">
   # module F1 : SF1 = functor (M : S) &rarr; struct let x1 = M.x1 end;;
   </pre>
   Without danger, it is possible to type the body of the
   functor <code>F1</code> by a signature computed to be compatible
   with <code>S</code> which is in this case <code>S_SMALL</code>. In
   other words, <code>SF1</code> is compatible with <code>SF2</code>
   and the functor <code>F1F1</code> is an instance
   of <code>SF2</code>:
   <pre class="prettyprint ml">
   # module F2 : SF2 = F1;;
   module F2 : SF2
   </pre>
   On the other hand, the body of the functor may not be treated as an
   instance of <code>S_LARGE</code>, that is it is merely
   an <code>S</code> and thus:
   <pre class="prettyprint ml">
   # module F3 : SF3 = F1;;
   TYPE ERROR
   </pre>
   Secondly, the parameter <code>M</code> is not instansiable for a
   moule which doesn't satisfy <code>S_SMALL</code> because the body
   of <code>F1</code> would no longer be coherent with its parameter:
   <pre class="prettyprint ml">
   # module F4 : SF4 = F1;;
   TYPE ERROR
   </pre>
   Finally, the parameter <code>M</code> may be instantiated for a
   module that satisfies <code>S_LARGE</code> that is, a module richer
   than necessary:
   <pre class="prettyprint ml">
   # module F5 : SF5 = F1;;
   module F5 : SF5
   </pre>
   This compatibility rule thus provides a rigorous framework for the
   re-use of functors with respect to a fixed specification.
   </p>

   <h5>Specification of functor signatures</h5>
   <p>In the framework of explicit typing, functor signatures somewhat
   duplicate with simple signatures. We can therefore limit ourselves
   to one of these means and prefer the explicit typing of functor
   results since it allows adaptions <i>a posteriori</i> for type
   constraints. However:
   <br/>
   <br/>
   <b>Signatures of functors and specification : </b> The signatures
   of functors may take place in a global specification so that no
   modular components are presented without an associated signature.
   <br/>
   <br/>
   </p>
   <p>On the other hand, signatures of functors permit somemtimes to
   replace a specification expressed by simple signatures. Indeed,
   type constraints within a signature may often be direct reportees
   over the signature of the corresponding functor. Reconsider the
   example of the specification of a container:
   <pre class="prettyprint ml">
   module type CONTAINER = sig
     type elt
     type t
     val empty : unit &rarr; t
     val add : elt &rarr; t&rarr; t
     ...
   end;;
   </pre>
   Here first of all is a derived signature for containers of ordered
   elements according to the classical technique:
   <pre class="prettyprint ml">
   module type ORDER_CONTAINER = sig
     module O : ORDER
     include CONTAINER with type elt = O.t
   end;;
   </pre>
   And here is a functor signature that imposes directly a link
   between the instances of <code>ORDER</code>
   and <code>CONTAINER</code>:
   <pre class="prettyprint ml">
   module type ORDER_CONTAINER_F =
     functor (Ord : ORDER) &rarr; CONTAINER with type elt = Ord.t;;
   </pre>
   It is then possible to use this functor signature for the
   explicitly typing an implementation. The
   functor <code>Ord_list</code> is also directly implementable:
   <pre class="prettyprint ml">
   module Ord_list : ORDER_CONTAINER_F =
     functor (Ord : ORDER) &rarr;
   struct
     type elt = Ord.t
     type t = elt list
     ...
   end;;
   </pre>
   We note nevertheless that such a specification by functor signature
   is not entirely equivalent to a specification obtained by simple
   signatures. It imposes necessarily a construction via interposed
   functor. In the example above, <code>ORDER_CONTAINER_F</code>
   imposes that containers with ordered elements are all issued from
   the application of a functor. The derived
   signature <code>ORDER_CONTAINER</code> does not.
   </p>

   <h4>Functors of functors</h4>

   <h5>A first use of functors of functors</h5>
   <p>We have shown in the preceding that functors offer a complete
   means of specification. But the signatures are also justified
   equally by another natural possibility of the language: the passing
   of functors as arguments to other functors. <i>Functors of
   functors</i> (called also "higher order functors") in fact a
   construction available in OCaml. The signatures of functors here
   take on all their importance because as in the case of simple
   module parameters, it is necessary to explicitly type "fonctorial
   parameters".
   </p>
   <p>Here first of all an example of the formal manipulation of
   functors. Recall that n-ary functors are currified. On may thus
   partially apply and so specialize. As for functions, this operation
   depends on the order which the parameter arguments appear. We could
   then argue on this order. Reconsider the example of the binary
   functor <code>Optimis</code>. The signature follows:
   <pre class="prettyprint ml">
   module type OPTIMISATION_F =
     functor (Metric : METRIC_SPACE) &rarr;
       functor (Ord : ORDER) &rarr; OPTIMISATION;;
   </pre>
   A functor to invert these parameters is thus as follows:
   <pre class="prettyprint ml">
   module Inv (F : OPTIMISATION_F) (O : ORDER) (M : METRIC_SPACE) = 
     struct
       include F (M) (O)
     end;;
   </pre>
   Evidently, in the bodies of functors, this inversion may not be as
   generic as in the case of functions. It can only be on
   implementations that satisfy the functorial
   parameter <code>F</code> to be inverted. The
   functor <code>Optimis</code> is one such and is made partially
   applicable on the second parameter:
   <pre class="prettyprint ml">
   # module Inv_optimis = Inv (Optimis);;
   # module Grad_float = Inv_optimis (Order_float);;
   module Grad_float :
     functor (M : METRIC_SPACE) &rarr; sig ... end
   </pre>
   </p>

   <h5>Constraints over functorial parameters</h5>
   <p>The signatures of functorial parameters necessarily have the
   same precision as those of module parameters : they have to
   integrate all the type constraints necessary to specify the
   implementation. For example, consider the following situation:
   <pre class="prettyprint ml">
   module type OP = sig
     type t
     val op : t &rarr; t &rarr; t
   end;;

   module type PAIR = sig
     type t
     val make_pair : t &rarr; t * t
   end;;

   module type PAIR_FUNCTOR = functor (M : OP) &rarr; PAIR;;

   module F (Internal : PAIR_FUNCTOR) = struct
     module Int = struct type t = int let op = ( + ) end
     module Pair = Internal (Int)
     let less_than_origin x =
       Pair.make_pair x < (0, 0) (*comparison of a pair of integers*)
   end;;
   </pre>
   The functor <code>F</code> is incorrect because the
   function <code>less_than_origin</code> imposes the
   function <code>Pair.make_pair</code> produce pairs of integers. On
   the other hand, the functor <code>Internal</code> must necessarily
   generate modules that manage these entities. Consequently, the
   functor <code>PAIR_FUNCTOR</code> must be made precise:
   <pre class="prettyprint ml">
   module type PAIR_FUNCTOR =
     functor (M : OP) &rarr; PAIR with type t = int;;
   </pre>
   Based over this signature, the functor <code>F</code> above will
   type fine. In order to make it really usable it would be preferable
   to consider the following signature:
   <pre class="prettyprint ml">
   module type PAIR_FUNCTOR =
     functor (M : OP with type t = int) &rarr; PAIR with type t = int;;
   </pre>
   The type of parameter <code>M</code> of the functor is indeed the
   thing that will probably affect the type of the
   function <code>less_than_origin</code>. The signatures of functors
   can also contribute to the proper transmission of types.
   </p>

   <h5>Control of generiticity of functors of functors</h5>
   <p>A common situation in the use of functors is to simplify the
   functors who are overly generic. For example, the implementation of
   graphs proopsed a generticity over its elements : the keys, the
   data and the edges. That exhaustive generiticity is not always
   desirable. To rememdy this, it is sometimes possible to use a
   partial instantiation of parameters of such a functor. But, we may
   equally pass the functor an argument to be applied as a second step
   according to the following model:
   <br/>
   <br/>
   <b>Control of the generiticity of a functor : </b> A
   functor <code>F1</code> is passed an argument of another
   functor <code>F2</code> in a manner that the body
   of <code>F2</code> is applied to <code>F1</code> in a specific
   environment.
   <br/>
   <br/>

   The generiticity expressed here thus is over the
   functor <code>F1</code> and not over the different parameters. That
   situation was given in the preceding example. In the case of
   graphs, on may want focus on the generiticity from the point of
   view of the construction of graphs, and not the keys, the data or
   the edges. Here is an example based on the notion of finite
   automata which are directed graphs, the vertices representing
   states and the edges transitions between those states. These
   automatons are very useful for example in compilers and
   communication protocols or, more generally, for describing discrete
   dynamic systems which have a finite number of states. For example,
   consider the automaton describing the life of beasts consisting of
   two states $1$ (quiet) and $2$ (excited) and the set of transitions
   $1 \rightarrow 1$ labelled "quiet", $1 \rightarrow 2$ labelled
   "excite" and $2 \rightarrow 1$ labelled "calm down":
   <div align="center"><img src="img/life-of-beast.png"/></div>
   </p>
   <p>Automatons thus are above all graphs of specific
   behaviors. Here, we now donsider them according to two
   simplifications:
   <ul>
   <li>The vertices do not contain data</li>
   <li>Identification of vertices is with simple integers</li>
   </ul>
   Here first of all is a set of signatures associated with these
   automatons which suggests their generiticity will therefore mainly
   be expressed on the labels of their arcs:
   <pre class="prettyprint ml">
   module type EQUAL = sig
     type t
     val eq : t &rarr; t &rarr; t
   end;;

   module type AUTOMATON = sig
     module Label : EQUAL
     type label = Label.t
     type automaton
     type extern_automaton
     val make : extern_automaton &rarr; automaton
     val path_exist : automaton &rarr; label list &rarr; bool
   end;;
   </pre>
   Here too a signature of functors associated with graphs and which
   integrate type constraints linked with masked implementation (it
   will be noted that they are a recap of the header of the graph
   functor; their necessity is explained in the preceding section):
   <pre class="prettyprint ml">
   module type GRAPH_F =
     functor (T : TYPE) &rarr;
       functor (Key :  EQUAL) &rarr;
         functor (Label : EQUAL) &rarr;
         GRAPH with module Key = Key and module Label = Label
         with type vertex_data = T.t
         with type extern_graph =
          ((Key.t * T.t) * ((Key.t * Label.t) list)) list;;
   </pre>
   With this, an automaton constructor functor may use an argument of
   signature <code>GRAPH_F</code> and apply it in order to specialize:
   <pre class="prettyprint ml">
   module Automaton (Label : EQUAL) (Graph_F : GRAPH_F)
     : AUTOMATON
       with module Label = Label
       with type extern_automaton = (int * ((int * label) list)) list =
   struct
     module Label = Label
     module State = struct type t = int let eq = ( = ) end
     module Data_dummy = struct type t = unit end
     module G = Graph_F (Data_dummy) (State) (Label)

     type label = label.t
     type automaton = G.graph
     type extern_automaton = (G.Key.t * ((G.Key.t * Label.t) list)) list

     let make l = G.make (List.map (fun (x, y) &rarr; ((x, ()), y)) y)) l)

     let path_exist autom word =
       let rec aux visited word = match word with
         | [] &rarr; true
         | first :: tail &rarr; List.mem true
               (List.map (fun v &rarr;
                  let nexts = List.filter (fun (), lab) &rarr; lab = first)
                                          (G.nexts v autom) in
                  if nexts = [] then false
                  else aux (List.map fst nexts) tail)
                visited)
       in
        aux [1] word (*the starting state is 1 by default*)
   end;;
   </pre>
   In the functor, on application of the argument <code>Graph_F</code>
   to the private modules <code>Dummy_data</code>
   and <code>State</code> we fix the particular form of the graphs
   under the identifier <code>G</code> (which correspond to our
   simplifications). The constructor <code>make</code> is based over
   an application of the specialized constructor <code>G.make</code>
   and the search function on a path of edges makes use of the
   extraction function of a neighbourhood <code>G.nexts</code>. So, a
   functor permits making an abstraction over the representation of
   graphs and not pass certain parameters.
   </p>
   
   <p>Here is an example of the construction of an automaton type with
   edges strings end the functor passed as an argument
   is <code>Graph</code> (from the earlier example):
   <pre class="prettyprint ml">
   # module Label = struct type t = string let eq = ( = ) end;;
   # module A = Automaton (Label) (Graph);;
   </pre>
   One may test using the life of a beast example:
   <pre class="prettyprint ml">
   # let life = A.make [1, [1, "quiet"; 2, "excite"];
                        2, [1, "calm down"]];
   val life : A.automaton = &lt;abstr&gt;

   # A.path_exist life ["excite"; "calm down"];;
   - : bool = true

   # A.path_exist life ["excite"; "excite"];;
   - : bool = false

   # A.path_exist life ["excite"; "calm down"; "quiet"; "excite"];;
   - : bool = true
   </pre>
   </p>

   <h5>Remarks about generalization for functors</h5>
   <p>As in the case of functions, generalizations established from
   functors of functors can sometimes be exaggerated. It is always
   possible to transform a simple parameter <code>M1</code> into a
   functor parameter capable of generating <code>M1</code>. More
   precisely, consider a functor such as :
   <pre class="prettyprint ml">
   module F1 (M1 : S1) = ...
   </pre>
   The above can always be transformed into a functor of functors:
   <pre class="prettyprint ml">
   module type SF1 = functor (M0 : S0) &rarr; S1

   module FF (F1 : SF1) (M0 : S0) = struct
     module M1 = F1 (M0)
     ...
   end;;
   </pre>
   A functor may effectively encompass a part of the applications of
   susceptible functors and generate the arguments. This avoids the
   user having to construct them themselves as was the case in the
   preceding example. This form provides little benefit if it is
   applied in a systematic way adding much more complexit to the
   technique of realization. A generalization is obviously not
   justified just for it's own sake.
   </p>

   <h5>Almost first class modules and functors </h5>
   <p>Modules and functors are elements of a language whose behaviors
     resemble the usual values. In their own world, modules and
     functors are manipulated as typable elements which are not far
     from being first class : one may pass arguments to a functor and
     they can be the result of the application of a functor. However,
     there are substantial differences between simple values and
     modular components. Recall the fact that functions have types
     that can be completely inferred whereas for functors, it is
     necessary to explicitly type their parameters. The limits of the
     reach of type inference is shown here (the case of modules is
     undecidable).
   </p>
   <p>In OCaml, the two worlds of values remain thus essentially
   parallel. This gap is all the more tangible in that modules cannot
   appear in expressions such as the
   classic <code>if-then-else</code>:
   <pre class="prettyprint ml">
   # if test then Complex else Complex_memo;;
   TYPE ERROR
   </pre>
   In fact, modules in OCaml do not meet the third condition for being
   first class, that is, "storable in a data structure". A data
   structure is a purely dynamic element. In contrast, modules and
   functors in OCaml are elements of a static nature.
   </p>
   <p>Nevertheless, that restriction is not inherent to the ML
   languages. It is a choice of the OCaml language designers and in
   this situation could quite possibly be made to evolve in the
   future. In this respect, local modules already allow to make it
   possible to use in a dynamic framework. For example, consider the
   following functor:
   <pre class="prettyprint ml">
   module type S = sig
     val f : int &rarr; int
   end;;

   module F_add (M : S) = struct
     let g = M.f x + 3
     let () = print_endline "F_add applied"
   end;;
   </pre>
   With the combination of local modules and imperative traits it is
   possible to effect a dynamic choice of module code during
   evaluation:
   <pre class="prettyprint ml">
   # module Increm_1 = struct let f x = x + 1;;
   # module Increm_2 = struct let f x = x + 2;;
   
   # let dynamic_module_choice x =
     let f = ref (fun x &rarr; x) in (*initialization*)
     (if x = 0
        then let module N = F_add (Increm_1) in
          f := N.g
      else let module N = F_add (Increm_2) in
          f := N.g);
      !f
   val dynamic_module_choice : int &rarr; int &rarr; int

   # dynamic_module_choice 0 1;;
   F_add APPLIED
   - : int = 5

   # dynamic_module_choice 222 1;;
   F_add APPLIED
   - : int = 6
   </pre>
   Only one of the two applications of <code>F_add</code> is effected
   when the function <code>dynamic_module_choice</code> is called.
   </p>

   <h4>The choice of generic modules</h4>
   <p>The preceding sections have illustrated how functors are the
   effective tools of generic modular programming. They permit
   inheritance, adaption, links of of association and aggregation of
   types in general environments, and offer a mechanism to control
   instantiation of type parameters. Nevertheless, two properties
   deserve further development:
   <ul>
   <li><i>"Functorial development".</i> Functors make possible a
   modular incremental programming, in the same fashion as functions
   make possible an incremental functional programming.</li>
   <li><i>The setting for a means of specification.</i> Functors
   highlight the importance and the benefits of a language means of
   specification on which their implementation can depend in a manner
   both explicit and effective.</li>
   </ul>
   These two points express to what extent functors are able to play a
   role at the level of development of programs, that is software
   engineering. Further, they show how functors it is possible to
   profit fully from the type system which extends its action in the
   modular framework and take part tangibly in the elabration of a
   valid logical archiecture. Understanding of these points is thus
   important for precisely these advantages of generic modular
   programming and we will dicusss them once more in what follows.
   </p>

   <h3>Functors : another form of functional programming</h3>
   <p>Functors induce conditions of development of programming which
   are similar to that of functional programming. In particular, it is
   possible to practice an "modular incremental programming" in
   favorable conditions.
   <br/>
   <br/>

   <b>Functors and "functorial programming":</b>
   <ol>
   <li><i>Localization of effects.</i> Functors may constitute total
   functions on modules. They can be implemented in the manner of a
   "black box" such that their behaviors are independant of the
   environment and the conditionso of their applications.</li>
   <li><i>Interactive development.</i> The development of a set of
   functors may be realized in an interactive environment, that is,
   under the same conditions as functions.</li>
   </ol>
   <br/>
   <br/>
   </p>
   <p>This "functorial programming" is established in a principally
   static framework. In other words, functors participate mostly in
   the construction of programs. We can also envisage functors as a
   tool of "edition of links" between modular components. Their
   specificity consists however between direct integration in the
   language and the type system. Thus, we no longer delegate
   implementations of the relations of the different components to
   external processes.
   </p>

   <h5>Functors : a software engineering tool</h5>
   <p>Functors must be located in the global context of modular
   programming if one wishes to be able to appreciate the full
   scope. First of all, recall that modular programming induces an
   essential difficulty : it must separate without isolating. The
   relative complexity of the preceding pages is a definition
   reflection of this. It is not surprising therefore to find the
   links between the modular components take on multiple forms. We
   summarize them here:
   <ol>
   <li><i>Links of direct utilization : </i>We draw directly on the
   public elements of the available modules. Opening of modules make
   these links even more direct.</li>
   <li><i>Links of utilization by inclusion : </i>Elements of
   signatures and modules are included by the
   directive <code>include</code> and they take their place at the
   same level as the other elements.</li>
   <li><i>Links of utilization by sub-modules : </i>The signatures and
   the modules are included by embedding as sub-signatures and
   sub-modules.</li>
   <li><i>Links of generic utilization (links by functors) : </i>The
   use of modules is not specified; it is made effective only at the
   very last extremeity, that is, on the applications of functors.</li>
   </ol>
   The links are distinguished essentially by their tendancy to fix
   their elements, either at the level of implementation or at the
   level of specification. To illustrate that idea and make a fair
   synthesis of what it covers, we will combine the same example
   according to each of them. Reconsider first of all a version of the
   signature <code>ARITH</code> which specifies a very general type of
   values:
   <pre class="prettyprint ml">
   module type ARITH = sig
     type nb
     val make : string &rarr; nb        val show : nb &rarr; string
     val zero : nb                  val one : nb
     val add : nb &rarr; nb &rarr; nb       val sub : nb &rarr; nb &rarr; nb
     val mul : nb &rarr; nb &rarr; nb       val div : nb &rarr; nb &rarr; nb
   end;;
   </pre>
   Here's one instance provided by a simple adaptation of the
   module <code>Int64</code> of base-64 integers from the standard
   library:
   <pre class="prettyprint ml">
   module I64 : ARITH = struct
     include Int64
     type nb = Int64.t
     let make = of_string        let show = to_string
   end;;
   </pre>
   Consider now the problem of using the module <code>I64</code> for
   numerical calculations in another module, for example in a module
   which resembles the mathematical functions module of an earlier
   example. Here first of all is a solution based on the "links by
   direct use":
   <pre class="prettyprint ml">
   module type MATH1 = sig
     val fact : I64.nb &rarr; I64.nb
     val fib : I64.nb &rarr; I64.nb
     val sum : (I64.nb &rarr; I64.nb) &rarr; I64.nb &rarr; I64.nb &rarr; I64.nb
   end;;

   module Math : MATH1 = struct
     let rec fact n =
       if n &lt;= I64.one then I64.one
       else I64.mul n
          (fact (I64.sub n I64.one))
      ...
   end;;
   </pre>
   In this example, the module <code>Math</code> and the
   signature <code>MATH1</code> integrate directly the elements of the
   implementation <code>I64</code> (the case above is similar to using
   the global type <code>int</code>). Such "links of direct use" are
   those found in most of languages which posses an elementary modular
   layer (e.g. C). This technique requires little effort on the part
   of the programmer since it consists of exploiting that which is
   public. The relationships between components are based on a simple
   pooling of elements at our disposal. If this technique is
   immmeidate and easy to implement, its disadvantages are far from
   being negligble:
   <ul>
   <li><i>Difficult substitutions : </i>The use of the
   module <code>I64</code> is definitely fixed in the
   implementation. The replacement by another module thus must be
   achieved by an explicit modification of the code or a reutilization
   of the name <code>I64</code>. In this case, in additino to the
   obvious management difficulties, multiple implementations can not
   coexist in the same program.<br/></li>
   <li><i>"Soft dependencies" : </i>By reason of the pair formed
   by <code>Math</code> and <code>MATH1</code>, we are not obliged to
   use an implementation which satisfies the
   signature <code>ARITH</code>. The module <code>Math</code> and the
   signature <code>MATH1</code> constitute disparate elements derived
   from various modules whose coherence would then be
   approriate. Analysis of the set of elements of <code>I64</code>
   uses falls on the programmer. However, a good definition for a
   module client depends on the stability of the imported modules. The
   direct use of simply what is available leads to a weakening of
   coherence and intelligibility of the partitioning put in place
   between the components.<br/></li>
   <li><i>Fixed scheduling of the implementation : </i>The direct
   links impose which modules must be implemented ahead of the modules
   that use them.</li>
   </ul>
   </p>
   <p>The "links of using by inclusion" induce a significant
   improvement over direct links and offer an explicit and effective
   place to put the signatures and modules used:
   <pre class="prettyprint ml">
   module type MATH2 = sig
     include ARITH
     val fact : nb &rarr; nb
     ...
   end;;

   module Math : MATH2 = struct
     include I64
     let rec fact n = 
       if n &lt;= one then one
       else mul n (fact (sub n one))
     ...
   end;;
   </pre>
   In this variation, the signature <code>ARITH</code> appears in the
   signature <code>MATH2</code>. The dependence
   between <code>Math</code> and <code>ARITH</code> can be expressed
   and verified by explicit typing by <code>MATH2</code>. On the other
   hand, the module <code>Math</code> depends always on the
   implementation <code>I64</code>. Also, the inclusions involve
   extensions of multiple modules to establish usage links because
   everyting included is definied newly at the level of the
   inclusion. The modules and the signatures can then become
   voluminous, upon which, even this pooling is not always justified.
   </p>
   <p>The "usage links by sub-structures" equally make apparent the
   signatures and modules used, but retain their individual properties
   (contrary to inclusion):
   <pre class="prettyprint ml">
   module type MATH3 = sig
     module M : ARITH
     val fact : M.nb &rarr; N.nb
     ...
   end;;

   module Math : MATH3 = struct
     module M = I64
     let rec fact n =
       if n &lt;= M.one then M.one
       else M.mul n
          (fact (M.sub n M.one))
      ...
   end;;
   </pre>
   The signature <code>MATH3</code> makes apparent here the link to
   signature <code>ARITH</code>. The implementation <code>Math</code>
   may make use of a module verified compatible
   with <code>ARITH</code>, but this time without mixing it with other
   definitions. However this technique gives rise again to a
   dependence on a definite implementation <code>I64</code>.
   </p>
   <p>The "links of use by functor" definitively frees the code of a
   module from its dependence on existing implementations whether in
   the form of sub-modules or in the form of signatures of functors:
   <pre class="prettyprint ml">
   (*The same as above*)
   module type MATH3 = sig
     module M : ARITH
     val fact : M.nb &rarr; N.nb
     ...
   end;;

   module Math (Ar : ARITH) : MATH3 = struct
     module M = Ar
     let rec fact n =
       if n &lt;= M.one then M.one
       else M.mul n
          (fact (M.sub n M.one))
      ...
   end;;

   module Math_64 = Math (I64);;
   </pre>
   Here the use of the module <code>I64</code> does not emerge
   in <code>Math</code>. It only intervenes when it is applied
   (<code>Math</code> is now a functor). On the other hand, the
   signature <code>ARITH</code> makes its appearance in the
   implementation of <code>Math</code> which makes it possible to
   verify the adequacy of its use. The "usage links by functor"
   abstract in effect the essence of generic modular programming:
   <br/>
   <br/>
   <b>Generic links : </b> Setting a usage link between two modular
   components so that it no longer depends on a particular
   implementation.
   <br/>
   <br/>
   We can also gather here the arguments in favor of this extra level
   of abstrction which remedies effectively the disadvantages of
   direct usage links.
   <ul>
   <li><i>Substitutions are facilitated : </i>In the example, it is
   now easy to obtain an implementation of <code>Math</code> based on
   another instance of the signature <code>ARITH</code>.</li>
   <li><i>Validation of dependencies and substitutions : </i>By virtue
   of the type system, the links between modules can be specified by
   interposed signatures then concretized by functors without the
   above using any particular implementation. Also, the type system
   may validate these links with the parameter signatures and functor
   applications. The "principle of substitutivity" is thus verifiable
   in as much as the means of specification permits.</li>
   <li><i>Freed scheduling of implementation : </i>Functors are
   implementable and compilable and this even though only even part of
   their code has been specified. The order of implementation may then
   adapt according to the contingencies of program development.</li>
   </ul>
   <br/>
   <br/>
   <b>Functors and software engineering : </b> The control exhibited
   by the type system and the existence of functors permit techniques
   of software engineering to find their place int he very heart of
   the language to be integrated, assisted and promoted.
   <br/>
   <br/>
   </p>

   <h5>Generic modular programming in question</h5>
   <p>The advantages due to the use of functors are obviously not
   without counterparts:
   <ul>
   <li><i>Program complexity. </i>Functor make programming more
   complicated and more technical.</li>
   <li><i>Applications of functors.</i> Functors must be applied to
   generate modules. These applications are added to the program and a
   spot must be found for them.</li>
   <li><i>Dependancy of functors on the set of existing
   signatures. </i> The type of parameters of functors make necessary
   the use of available signatures. Nothing however prevents the body
   of a functor to use only a very small part of what is specified in
   these signatures. In this case, to implement modules that satisfy
   these requirements may require a much greater effort than is <i>a
   priori</i> necessary</li>
   </ul>
   The third point is in fact an old problem common in all programming
   languages which include a means of specification. It corresponds to
   the counter impact of the treatment of "soft dependencies" by
   depdencies expressed by the explicit specialization. The relations
   between modules my in fact be "over specified".
   </p>
   <p>For example, reconsider the case of a signature that describes
   the behaviors of an association table. In a realistic situation of
   software development, this signature could quickly take important
   proportions:
   <pre class="prettyprint ml">
   module type ASSOC_TABLE = sig
     module Key : EQUAL
     type &beta; assoc
     val empty : unit &rarr; &beta; assoc
     val get_pair : &beta; assoc &rarr; Key.t * &beta;
     val add : &beta; assoc &rarr; Key.t &rarr; &beta; &rarr; &beta; assoc
     val assoc : &beta; asoc &rarr; Key.t &rarr; &beta;
     val assocq : &beta; assoc &rarr; Key.t &rarr; &beta;
     val remove_assoc : Key.t &rarr; &beta; assoc &rarr; &beta; assoc
     val remove_assocq : Key.t &rarr; &beta; assoc &rarr; &beta; assoc
     val length : &beta; assoc &rarr; int
     val iter : (&beta; &rarr; unit) &rarr; &beta; assoc &rarr; unit
     val map : (&beta; &rarr; &beta;) &rarr; &beta; assoc &rarr; &beta; assoc
     val map_full : (Key.t &rarr; &beta; &rarr; &beta;) &rarr; &beta; asoc &rarr; &beta; assoc
     val fold_right : (Key.t &rarr; &beta; &rarr; &beta; &rarr; &beta;) &rarr; &beta; assoc &rarr; &beta; &rarr; &beta;
     val for_all : (Key.t &rarr; bool) &rarr; &beta; assoc &rarr; bool
     val filter : (Key.t &rarr; bool) &rarr; &beta; assoc &rarr; &beta; assoc
     val append : &beta; assoc &rarr; &beta; assoc &rarr; &beta; assoc
     val concat : &beta; list assoc &rarr; &beta; assoc
     val split : &beta; assoc &rarr; Key.t list * &beta; list
     val combine : Key.t list &rarr; &beta; list &rarr; &beta; assoc
     ...
   end;;
   </pre>
   Thus, any module that indicates a link to this signature would be
   required to include the full implementation. For example, consider
   the signature <code>GRAPHIC_ENVIRONMENT</code> which specifies a
   type of adaptable graphic environments tables, precisely the
   signature <code>ASSOC_TABLE</code>. It's implementation in the form
   of the functor <code>G_env</code> exploited only four functions. It
   remains the case that the module imported must satisfy the full
   signature. In other words, there is sometimes a disproportion
   between the content of a signature and the actual use of its
   implementations. Here are several concrete elements in response to
   the problem:
   <ol>
   <li><i>Complete implementations. </i>The implementation of a
   complete module is always justified in anticipation of possible
   future developments.</li>
   <li><i>Falsely complete implementations. </i>The implementation of
   a complete module may be obtained "by shortcut" by replacing all
   the functions not used with ellipses as in for example:
   <pre class="prettyprint ml">
   # let short_cut x = failwith "Not implemented!"
   val shortcut : &alpha; &rarr; &beta;
   </pre></li>
   <li><i>Decompositions and recompositions of signatures and
   modules.</i> Signatures may be decomposed into sub-signatures,
   modules into sub-modules. The decompositions are then exploited by
   generic inclusions and embeddings to reconstruct instances
   approriate to the particular development situation.</li>
   </ol>
   </p>
   <p>However, the techniques of decomposition and recomposition of
   modular components in the actual state of things in OCaml are
   laborious (as is the case in most of the currently used
   languages). These techniques represent in fact one of the crucial
   points of research and the evolution of languages. One notes
   however that OCaml provides extension tools CamlP4 and ppx, which
   may facilitate the implementation of integrated solutions to this
   problem. For example, by virtue of these tools one may envisage the
   definition of operations specializing in signature construction and
   modules as for example those associated with their unions.
   </p>

   <h4>Representing a generic architecture</h4>

   <p>Up to now, we have considered small scale programs composed of a
   few modules and functors. In the usual framework of software
   development, the number of modular components contributed can of
   course become high. The elaboration and comprehension of a program
   then proceeds necessarily by structuring techniques and
   synthesis. For example, representations from UML have become
   standard in object oriented programming. On the other hand, the
   representations in the form of directed graphs are a base for
   modular programming : it simply indicates the use relationships
   that the modules maintain among themselves. In the framework of
   OCaml programming which is also based on such "links of direct
   use", it is assuredly possible it is certainly possible to be
   satisfied with such a representation. On the other hand, as generic
   programming and functors come into play, it is no longer
   sufficient. We thus offer here a graphical representation adapted
   to them. This will also give us the opportunity to clarify the
   relationship between functors and software development.
   </p>

   <h3>Software development and generic programming</h3>
   <p>The use of functors globally influences the manner of
   development of a program. First of all, the links specified between
   modules in the signatures can always be realized by interposed
   functors (by "generic links"). Reciprocally, functor make mandatory
   the prior definition of signatures since their parameters are
   explicitly typed. On the other hand, applications of functors are
   essential to generate the final program. We can thus distinguish
   three principal phases of software development with functors:
   <ol>
   <li><i>Specification :</i> The definition of signatures and the
   relations between them. It will be noted that this set of
   signatures is compilable and verifiable by the type system. In
   OCaml, this phase can include a decoupling into compilation units,
   that is to say package organization and signature coherence.</li>
   <li><i>Partial implementation of the specification :</i> The
   implementation of modules and of functors which satisfy ceterain
   signatures of the specification obtained in phase 1.</li>
   <li><i>Evolution of the implementation :</i> The application of
   functors to complete the implementation partially established in
   phase 2.</li>
   </ol>
   These phases may be clearly distinguished over these simple
   examples:
   <pre class="prettyprint ml">
   (*specification*)

   module type S1 = sig ... end
   module type S2 = sig ... end
   module type SF = functor (M : S1) &rarr; S2

   (*implementation*)

   module M1 : S1 = struct ... end
   module M2 : S1 = struct ... end
   module F : SF = functor (M : S1) &rarr; struct ... end

   (*evolution*)
   module M3 : S2 = F (M1)
   </pre>
   Therefore, the very notion of a software architecture is
   transformed.
   <br/>
   <br/>
   <b>Definition : </b> A <i>generic modular architecture</i> includes
   the organization of signatures, modules and functors of a program
   as well as possibilities for it's evolution by application of
   functors.
   <br/>
   <br/>
   On the hand, let us recall that the modules system in ML languages
   possess certain particularities which certainly play a role in such
   an architecture:
   <ul>
   <li><i>Multiplicity of implementations.</i> A signature may have
   multiple implementations. A signature is in effect an interface :
   it is a type to instantiate.</li>
   <li><i>Compatibility between signatures.</i> Signatures may be
   compatible with one another. A module or a functor may then satisfy
   multple signatures at one time.</li>
   </ul>
   Let us emphasize moreover that in OCaml, signatures of functors can
   be used explicitly during the specification of a
   program. nevertheless, they might sometimes seem redundant. For
   example, consider the following signature:
   <pre class="prettyprint ml">
   module type S1 = sig
     module M : S2
     ...
   end;;
   </pre>
   It will generally lead to the existence of a functor signature of
   the form:
   <pre class="prettyprint ml">
   module type SF = functor (M : S2) &rarr; S1
   </pre>
   That said, using the signatures of functors permits treating
   modules and functors at the same level. Recall in fact tht the
   multiplicity of implementations and compatibility apply equally to
   signatures of functors. Even if they are not expressed, these
   signatures must be included in an architecture so that any typable
   component can be found. These functor signatures may also be
   considered as implicit.
   </p>

   <h5>Specification graphs and automatons of architecture</h5>
   <p>We are thus far enough from the usual programming conditions. A
   graphical representation of a generic modular architecture in ML
   must be capable of integrating the three phases of development
   above and, on the other hand include the specific properties of ML
   languages.
   </p>
   <p>First of all, it is natural to ensure that the representation is
   founded over the specification phase. The set of signatgures at our
   disposal may be indeed organized in the form of a graph which we
   will call here the "specification graph". Each vertex will denote a
   particular signature of the architecture and we distinguish between
   two types of vertices (see diagram):
   <br/>
   <br/>
   <b>Definitions : </b>
   <ul>
   <li><i>Simple vertex : </i>denotes a module signature</li>
   <li><i>Transition vertex : </i>denotes a functor signature and
   posses a stramd that indicates its "applicability". The strand may
   be labelled in order to indicate type constraints.</li>
   </ul>
   <div align="center"><img src="img/narbel_00.png"/></div>
   <br/>
   <br/>

    We can always therefore identify a vertex of a specification graph
   with the signature it represents. On the other hand, the <i>arc</i>
   of such a graph are principally determined by two relations:
   <br/>
   <br/>
   <b>Definitions : </b>
   <ul>
   <li><i>Parameter arc : </i>connects a vertex <code>S</code> to the
   strand of a transition vertex <code>SF</code> if <code>S</code> is
   a signature of one of the parameters of <code>SF</code></li>
   <li><i>Result arc : </i>connects a strand of a transition
   vertex <code>SF</code> to a vertex <code>S</code> if <code>S</code>
   is a signature of a possible result of <code>SF</code> (recall that
   partial applications of functors are possible).</li>
   </ul>
   <br/>
   <br/>
   Consider again an earlier formal example. The specialization was
   summarized in the following three signatures:
   <pre class="prettyprint ml">
   module type S1 = sig ... end
   module type S2 = sig ... end
   module type SF = functor (M : S1) &rarr; S2
   </pre>
   The associated graph is thus
   : <div align="center"><img src="img/narbel_01.png"/></div> The implementations of
   modules and functors available at a given moment can then take
   place in a specification graph. It suffices to apply the following
   obvious rule:
   <br/>
   <br/>
   <b>Insertion of an implementation into a specification graph : </b>
   A module or functor is associated with a vertex <code>S</code> if
   it satisfies <code>S</code>.
   <br/>
   <br/>
   In the case of the example, the implementation definitely satisfies
   two modules and a functor:
   <pre class="prettyprint ml">   
   module M1 : S1 = struct ... end
   module M2 : S1 = struct ... end
   module F : SF = functor (M : S1) &rarr; struct ... end
   </pre>
   </p>
   <p>We can then complete the specification graph above (note
   that <code>M1</code> and <code>M2</code> are associated with the
   vertex <code>S1</code>):
   <div align="center"><img src="img/narbel_02.png"/></div> Thus,
   application of functors can allow for implementation to evolve and
   in the same way, the sets of modules and functors associated with
   vertices of the specification graph. The result of the application
   of a functor is denoted by the expression which corresponds to this
   application (it is therefore not necessary to explicitly name this
   result), or more directly by a link name if one exists. In an
   earlier example, the architecture evolved to the unique application
   following:
   <pre class="prettyprint ml">
   module M3 : S2 = F (M1);;
   </pre>
   On the specification graph, this evolution is made concrete by the
   simple addition of the module <code>M3</code>:
   <div align="center"><img src="img/narbel_03.png"/></div> This
   description now permits the essential characteristics of the
   proposed representation here:
   <br/>
   <br/>

   <b>Definition : </b><i>A software architecture</i> consists of
   three elements:
   <ol>
   <li>A graph of specification $G$.</li>
   <li>A state of the implementation in which each of the modules and
   functors available are associated with the vertices of $G$
   according to the insertion rule.</li>
   <li>The rule of evolution resultingfrom the applicability of
   functors are associated with transition vertices.</li>
   </ol>
   <br/>
   <br/>
   One notes that the definition recovers the three phases of software
   development of a generic program.
   </p>
   <p>To fix these ideas, here are some very simple architectures
   based on the examples of the preceding sections. To begin, the
   example of graphical environments based on association tables may
   be represented so (the transition vertices implicitly represent the
   signature of functors <code>ASSOC_TABLE &rarr;
   GRAPHIC_ENVIRONMENT</code>):
   <div align="center"><img src="img/narbel_04.png"/></div> The
   software architecture of the example of "generic composites" is the
   following (the transition vertex represents implicitly functors
   with the signature <code>GRAPHIC_ELEM &rarr; GRAPHIC_ELEM</code>):
   <div align="center"><img src="img/narbel_05.png"/></div> The
   example illustrates software architectures may posses
   loops. Finally, here is an architecture of a binary functor
   construting an optimisation method (the transition summit
   implicitly represents the signature <code>METRIC_SPACE &rarr; ORDER
   &rarr; OPTIMISATION</code>):
   <div align="center"><img src="img/narbel_06.png"/></div>
   </p>
 
   <h5>Representing the compatibility of signatures</h5>
   <p>Compatibility between signatures proves a very important point
   of generic modular architectures in ML. That property permits in
   fact an indication of immediate reusability and validates the
   modular components at our disposition. It is thus opportune to be
   able to represent that relation within a specification graph. To do
   this, one adds a new arc type:
   <br/>
   <br/>
   <b>Definition : </b>A <i>compatibility arc</i> relies on two simple
   vertices or two transition vertices <code>S1</code>
   and <code>S2</code> if <code>S1</code> is compatibile
   with <code>S2</code>.
   <br/>
   <br/>

   Graphically, compatibility arcs are distinguished from others by
   being dotted. Here is an example based on these three compatible
   signatures:
   <pre class="prettyprint ml">
   module type S3 = sig ... end
   module type S2 = sig include S3 ... end
   module type S1 = sig include S2 ... end
   module M1 : S1 = struct ... end
   </pre>
   By virtue of the inclusions, <code>S1</code> is compatible
   with <code>S2</code> which is compatible
   with <code>S3</code>. Also, the module <code>M1</code> satisfies
   all of <code>S1</code>, <code>S2</code> and <code>S3</code>. On the
   other hand, <code>M1</code> must be associated with all of the
   simple vertices which are accessible from <code>S1</code> by
   compatibility arcs. The architecture then corresponding to the
   example is the following:
   <div align="center"><img src="img/narbel_07.png"/></div>
   </p>

   <p>Compatibility arcs permit a particular representation of the
   model of "generic module inheritance". Here is general form of a
   model of the form abgridged and simple:
   <pre class="prettyprint ml">
   module type S1 = sig ... end
   module type S2 = sig include S1 ... end
   module type SF = functor (M : S1) &rarr; S2
   </pre> The model is represented by the specification graph
   following where inheritance implies generally a compatibility arc
   back to the top from which we inherit:
   <div align="center"><img src="img/narbel_08.png"/></div> 

   For example, the archtecture of extension of a type of containers
   is the the following (with application of a functor):
   <div align="center"><img src="img/narbel_09.png"/></div> 

   Generic multiple inheritance is simply obtained by multiple
   inclusion:
   <pre class="prettyprint ml">   
   module type S1 = sig ... end
   module type S2 = sig ... end
   module type S3 = sig include S1 include S2 ... end
   module type SF = functor (M1 : S1) (M2 : S2 with ...) &rarr; S3;;
   </pre>
   The corresponding specification graph is:
   <div align="center"><img src="img/narbel_10.png"/></div> 
   Here is the software architecture of a program which corresponds to
   the union of two data types:
   <div align="center"><img src="img/narbel_11.png"/></div> Finally,
   reconsider the "control of generiticity" example proposed for
   finite automata and which makes use of a higher order functor. Here
   is the software architecture:
   <div align="center"><img src="img/narbel_12.png"/></div>
   Notice that here the private modules of the
   functor <code>Automaton</code> do not appear in the architecture
   because they are only part of the specific implementation of the
   functor. Software architectures represent only the state of what is
   globally available.
   </p>

   <h4>Examples of software architectures</h4>
   <p>We will implement here some supplementary examples of modular
   and generic programs which will be a little more complete than the
   ones seen before. The specification graphs and the software
   architectures permit their representation in a synthetic manner.
   </p>

   <h5>Priority queues</h5>
   <p>Here first of all is an example that implies a chain of
   applications of two functors. It is a prototype which generates
   priority queue types for the execution of processes (<i>execution
   queues</i>) based on priority queues. Here is the the set of
   specification signatures:
   <pre class="prettyprint ml">
   module type ORDER = sig
     type t
     val compare : t &rarr; t &rarr; int
   end;;

   module type ORDER_MASK = sig
     type t
     type extern_t
     val make : extern_t &rarr; t
     val show : t &rarr; extern t
     val compare : t &rarr; t &rarr; int
   end;;

   module type ORDERED_CONTAINER = sig
     module O : ORDER
     type elt = O.t
     type t
     val empty : unit &rarr; t
     val add : elt &rarr; t &rarr; t
     val max_elt : t &rarr; elt
     val remove_max : t &rarr; t &rarr; t
   end;;

   module type ORDERED_CONTAINER_F =
     functor (Ord : ORDER) &rarr; ORDERED_CONTAINER;;

   module type EXEC_QUEUE = sig
     module C : ORDERED_CONTAINER
     type processus = C.elt
     type t = C.t
     val empty : unit &rarr; t
     val add : processus &rarr; t &rarr; t
     val execute : (processus &rarr; unit) &rarr; t &rarr; t
   end;;

   module type EXEC_QUEUE_F =
     functor (Ord : ORDERED_CONTAINER) &rarr; EXEC_QUEUE;;
   </pre>
   Let us emphasize again that this specification can be verified and
   compiled by the OCaml compiler in particular as regards relations
   between types. It is represented in the form of a specification
   graph in the following figure:
   <div align="center"><img src="img/narbel_13.png"/></div>
   
   Note that here we illustrate the technique of the double signature
   (with and without preparation for masking) for the sets of ordered
   data (<code>ORDER</code> and <code>ORDER_MASKED</code>
   respectively). In fact, the
   signature <code>ORDERED_CONTAINER</code> specifies a modular
   association and as a consequence it can be satisfied with a
   signature with a "module record".
   </p>
   <p>The second phase of development consists to give a minimal
   implementation to obtain the means of realising execution
   queues. Here two functors who correspond with priority queues
   implemented with simple lists and another a specialization of
   priority queues to obtain execution queues. We add a process type
   that saisfies <code>ORDER_MASK</code>. This contains the private
   elements which permit identifing processes in a unique manner (and
   for compatibility, it is equally an instance
   of <code>ORDER</code>):
   <pre class="prettyprint ml">
   module L (Ord : ORDER) : ORDERED_CONTAINER
     with module O = Ord =
   struct
     module O = Ord
     type elt = O.t
     type t = O.t list
     let empty () = []
     let add x l = List.sort O.compare (x :: l)
     let max_elt l = List.hd l
     let remove_max l = List.tl l
   end;;

   module Exec_Q (Cont : ORDERED_CONTAINER) : EXEC_QUEUE
     with module C = Cont =
   struct
     module C = Cont
     type processus = C.elt
     type t = C.t
     let emtpy = C.empty
     let add = C.add
     let execute apply_process q =
       apply_process (C.max_elt q); C.remove_max q
   end;;

   module Proc : ORDER_MASK
     with type extern_t = int * (float &rarr; unit) * float =
   struct
     type t = {priority : int;          pid : int;
               proc : float &rarr; unit;    para : float }
     let extern_t = int * (float &rarr; unit) &rarr; float
     let counter = ref 0
     let make (priority, proc, param) =
       incr counter;
       { priority = priority; pid = !counter;
         proc = proc;         param = param
        }
     let show_x = (x.priority, x.proc, x.param)
     let compare = Pervasives.compare
  end;;
   </pre>
   The corresponding software architecture is obtained by
   incorporating the implementations into the specification
   graph:
   <div align="center"><img src="img/narbel_14.png"/></div>
   From there evolution to process queues is summarized by the
   application of the two functors, that is:
   <pre class="prettyprint ml">
   # module Q = Exec_Q (L (Proc));;
   </pre>
   We can then use the module <code>Q</code> (processes here are
   reduced to simple input-output):
   <pre class="prettyprint ml">
   # let pretty_float x = Printf.printf "Very nice float : %f\n" x;;
   # let q = Q.add (Proc.make (10, (fun x &rarr; pretty_float x), 3.14))
                (Q.add (Proc.make (1, (fun x &rarr; pretty_float x), 40000.))
                  (Q.empty ()));;
   # let apply_process x = 
       let (_, proc, param) = Proc.show x in proc param;;
   val : apply_process : Proc.t &rarr; unit

   # let q = Q.execute apply_process q;;
   Very nice float : 40000.

   # let q = Q.execute apply_process q;;
   Very nice float : 3.14
   </pre>
   </p>

   <h5>Mangement of signature hierarchies</h5>
   <p>The representation of compatibility permits the visualization of
   the links that exist between specifications of modules and functors
   always more specialized. To the extent that such compatibility is a
   tributary of the names of elements of those signatures it is
   equally sometimes necessary to propose adaptions of those names
   after the creation of a principal hierarchy of compatibility. By
   way of example, the below includes three signatures of container
   types:
   <pre class="prettyprint ml">
   module type CONTAINER = sig
     type &alpha; t
     val empty : unit &rarr; &alpha; t
     val add : &alpha; &rarr; &alpha; t &rarr; &alpha; t
     val mem : &alpha; &rarr; &alpha; t  &rarr; bool
     val map : (&alpha; &rarr; &beta;) &rarr; &alpha; t &rarr; &beta; t
   end;;

   module type LINEAR_CONTAINER = sig
     include CONTAINER
     val build : (&alpha; &rarr; &alpha;) &rarr; &alpha; &rarr; &alpha; t
     val hd : &alpha; t &rarr; &alpha;
     val tl : &alpha; t &rarr; &alpha; t
     val npeek : int &rarr; &alpha; t &rarr; &alpha; list
     val length : &alpha; t &rarr; int
     val nth : &alpha; t &rarr; int &rarr; &alpha;
   end;;

   module type BINTREE_CONTAINER = sig
     type &alpha; bintree
     val make_empty : unit &rarr; &alpha; bintree
     val build (&alpha; &rarr; &alpha; * &alpha;) &rarr; int &rarr; &alpha; &rarr; &alpha; bintree
     val add : &alpha; &rarr; &alpha; bintree &rarr; &alpha; bintree
     val mem : &alpha; &rarr; &alpha; bintree &rarr; bool
     val height : &alpha; bintree &rarr; int
     val balance : &alpha; bintree &rarr; &alpha; bintree
   end;;
   </pre>
   So, the signature <code>LINEAR_CONTAINER</code> is evidently
   compatible with <code>CONTAINER</code>, the
   signature <code>BINTREE_CONTAINER</code> not but only due to the
   naming of its elements. Generic adaption of the names may be
   specified to realize that as:
   <pre class="prettyprint ml">
   module type BINTREE_CONTAINER' = sig
     include BINTREE_CONTAINER
     type &alpha; t = &alpha; bintree
     val empty : unit &rarr; &alpha; t
   end;;

   module type ADAPT_BIN_NAMES =
     functor (T : BINTREE_CONTAINER) &rarr; BINTREE_CONTAINER';;

   module Bin_adapt (T : BINTREE_CONTAINER) : BINTREE_CONTAINER' = struct
     include T
     type &alpha; t = &alpha; bintree
     let empty = make_empty
   end;;
   </pre>
   <div align="center"><img src="img/narbel_15.png"/></div> By this,
   all instances of <code>BINTREE_CONTAINER</code> may be integrated
   into the container hierarchy by post application of the functor:
   <pre class="prettyprint ml">
   module Tree : BINTREE_CONTAINER = struct
     type &alpha; bintree =
       | Bin_empty
       | Bin_node of &alpha; * &alpha; bintree * &alpha; bintree
     let make_empty () = Bin_empty
     let build f n x = ...
     let add x t = ...
     let mem x t = ...
     let height t = ...
     let balance t = ...
     let rec map f t = ...
   end;;

   # module Tree' = Bin_adapt (Tree);;
   </pre>
   The module <code>Tree'</code> is from now on an instance of the
   signature <code>BINTREE_CONTAINER</code> and the
   signature <code>CONTAINER</code>. We remark that we have here
   simplified the body of the example and utilized a universal
   type. It would be possible also to develop this with a parallel
   hierarchy of signatures using only abstract types according to the
   "explicit generic modular programming" and integrate the adatptions
   generically to reutilize them.
   </p>

   <h5>Building generic production lines</h5>
   <p>Here is a new implementation of "production lines". The idea
   here is to be able to connect lines which are not necessarily based
   on the same implementation and on the same types. The lines may be
   simple containers, flows, treadmills etc. Here, first of all the
   minimal specification of a general type of production lines, as
   well as one of its specializations which imposes a representation
   in the form of flows (according to an earlier presented technique).
   <pre class="prettyprint ml">
   module type P_LINE = sig
     type data_in               type data_out
     type &alpha; input_line         type &alpha; output_line
     val make : data_in input_line &rarr; data_out output line
     val read_fst : data_out output_line &rarr; data_out
     val delete_fst : data_out output_line &rarr; data_out output_line
   end;;

   module type STREAM = sig
     exception Empty
     type &alpha; stm
     val cons : (unit &rarr; &alpha;) &rarr; (unit &rarr; &alpha; stm) &rarr; &alpha; stm
     val hd : &alpha; stm &rarr; &alpha;
     val tl : &alpha; stm &rarr; &alpha; stm
     val npeek : int &rarr; &alpha; stm &rarr; &alpha; list
     val iterate : (&alpha; &rarr; &alpha;) &rarr; &alpha; &rarr; &alpha; stm
     val map : (&alpha; &rarr; &beta;) &rarr; &alpha; stm &rarr; &beta; stm
   end;;

   module P_LINE_STM = sig
     module St : STREAM
     include P_LINE with type &alpha; output_line = &alpha; St.stm
   end;;

   module type P_LINE_STM_F =
     functor (St : STREAM) &rarr; P_LINE_STM
   </pre>
   We can also give ourselves a signature of "functor connectors"
   which imposes the the entry of a production line necessarily comes
   from the exit of another production line:
   <pre class="prettyprint ml">
   module type P_LINE_TRANSFORM_STM_F =
     functor (St : Stm) &rarr;
       functor (P : P_LINE_STM) &rarr; 
         P_LINE_STM
           with type data_input = P.data_output
           with type &alpha; input_line = &alpha; P.output_line;;
   </pre>
   The set of signatures is represented in the following figure.
   <div align="center"><img src="img/narbel_15.png"/></div> Consider
   nowmaintaining two different implementations of the
   signature <code>STREAM</code>:
   <pre class="prettyprint ml">
   module St1 : STREAM = struct (*strictly functional*)
     exception Empty
     type &alpha; stm = Empty_stream | Cons of &alpha; * (unit &rarr; &alpha; stm)
     let cons x s = Cons (x (), s)
     ...
   end;;

   module St2 : STREAM = struct (*uses `lazy_t`*)
     exception Empty
     type &alpha; stm = Stm_emtpy | Cons of &alpha; lazy_t * &alpha; stm lazy_t
     let cons x s = Cons (lazy (x ()), lazy (s ()))
   end;;
   </pre>
   Here's a functor which satisfies the
   signature <code>P_LINE_STREAM_F</code>. It is also a generic
   representation of production lines which produces suites of random
   binary numbers:
   <pre class="prettyprint ml">
   module Rand_bin (STREAM : STREAM) : P_LINE_STREAM
     with type data_out = int
     with type &alpha; input_line = int =
   struct
     module St = Stream
     type data_in = unit
     type data_out = int
     type &alpha; input_line = int
     type &alpha; output_line = &alpha; St.stm

     let rec make init =
       Random.init; St.iterator (fun x &rarr; (Random.int 2)) 0

     let read_first s = St.hd s
     let delete_fst s = St.tl s
   end;;
   </pre>
   Finally, here is a functor that
   satisfies <code>P_LINE_TRANSFORM_F</code> permitting generation of
   compressed production lines according to the following principal :
   if the element $E$ is repeated into the production line $n$ times,
   then the production reduces this repetition into a unique element
   $(n, E)$ (run length encoding compression method):
   <pre class="prettyprint ml">
   module Compress (Stream : STREAM)
                    (P : P_LINE_STM)
     : P_LINE_STM
       with type data_in = P.data_out
       with type data_out = int * P.data_out =
   struct
     module St = Stream
     type data_in = P.data_out
     type data_out = int * P.data_out
     type &alpha; input_line = &alpha; P.output_line
     type &alpha; output_line = &alpha; St.stm

     let rec make s =
        let rec one_element e1 s n =
          if e1 = P.read_fst s
           then one_element el (P.delete_fst s) (n + 1)
           else ((n, e1), s) in
        let consx (pair, s) =
          St.cons (fun () &rarr; pair) (fun () &rarr; make s))
        in cons (one_element (P.read_fst s) (P.delete_fst) 1)

     let read_fst s = St.hd s
     let delete_fst s = St.tl s
   end;;
   </pre>
   Even if the compression of a an already compressed production line
   can have little "compressive effet", we can nevertheless show that
   its application is possible and thus obtain three chained
   production lines:
   <pre class="prettyprint ml">
   # module CCompressed_R = Compress (St2) (Compressed (R));;

   # let s3 = CCompressed_R.make s2;;
   - : CCompressed_R.data_out CCompressed_r.output_line = &lt;abstr&gt;

   # CCompressed_R.St.npeek 5 s3;;
   - : CCompressed_R.data_out list =
     [(1, (2, 0)); (1, (1, 1)); (1, (4, 0)); (1, (4, 1)); (1, (1, (1, 0)))]
   </pre>
   Production lines thus can be implemented in a variety of manners
   (and in particular here according to the modules <code>St1</code>
   and <code>S2</code>) and connected, all the while preserving the
   generic masking of their types.
   </p>

   <h5>Remarks on software architectures</h5>
   <p>After the examples of the preceding pages illustrating certain
   possibilities of software architectures, two remarks result:
   <ul>
   <li><i>The connection of architectures.</i> The more more an
   architecture expresses generic links (and thus in the form of
   functors), the more the better suited it is to adaptability and
   reusability and is furthermore precise in its relation to the
   specification. In other words, the more an architecture contains
   arcs, the more it represents an architecture of generic
   specification rich with possibilities. Certainly, there is no
   obligation to express the relations between modules by interposed
   functors. As has been remarked many times in the text, the choice
   of construction or a style will rarely dictate definitive
   rules. Generic programming is more complicated, more technical more
   technique and the generalizations it allows are not always
   indispensable. For example, it is usual to simplify a task and
   directly use the components of the statndard libries distributed
   with the language. It is also often convenient to associate modules
   of globably definitions with programs. However, each time a link is
   not expressed in a generic form - and thus vertices of the
   specification graph are not connected with others - it implies the
   links are fixed a the level of implementation ("direct links") with
   the associated inconveniences.
   <li><i>Exhaustiveness of the representation.</i> We deliberately
   limited software architectures to have a representation of the
   important properties, that being, the multiplicity of
   implementations, the compatibility of signatures and the evolution
   of architecture. We could certainly render more exhaustively (for
   example the poijn of view of sub-modules and super-modules) or more
   precise and more precisely and more formally (for example the point
   of view of functor application), but the idea was here to offer a
   simple graphical means of direct aid to the programmer. We note
   however that it is easy to add information related to the
   structuring that includes package sspecication : it is sufficient
   for example to enclose the respective vertices.</li>
   </ul>
   </p>

   <hr/>
   <p>
     References:<br/>
     "Programmation fonctionnelle, g&#233;n&#233;rique et objet: une introduction avec le langage OCaml" -- Narbel P., 2005
   </p>

  </body>
</html>
